unit apu(                                                                                                                       //Single channel audio output, outputs 8 bits for PWM. 25MHz
    simple_dualport_bram_port0  bit_samples,
    simple_dualport_bram_port0  wave_samples,
    simple_dualport_bram_port0  pcm_samples,
    input   uint3   waveform,
    input   uint13  frequency,
    input   uint16  duration,
    input   uint1   apu_write,
    input   uint8   staticGenerator,
    input   uint3   volume,
    output  uint1   audio_active,
    output  uint8   audio_output
) <reginputs> {
    waveform WAVEFORM(
        active <: COUNTER.active,
        bit_samples <:> bit_samples, wave_samples <:> wave_samples, pcm_samples <:> pcm_samples,
        start <: apu_write, update <: COUNTER.updatepoint,
        selected_waveform <: waveform,
        staticGenerator <: staticGenerator
    );
    audiocounter COUNTER( selected_frequency <: frequency, selected_duration <: duration, start <: apu_write, active :> audio_active );

    always_after {
        if( COUNTER.updatepoint ) { audio_output = WAVEFORM.audio_output >> ~volume; }
    }
}

unit waveform(
    simple_dualport_bram_port0  bit_samples,
    simple_dualport_bram_port0  wave_samples,
    simple_dualport_bram_port0  pcm_samples,
    input   uint1   start,
    input   uint1   update,
    input   uint3   selected_waveform,
    input   uint8   staticGenerator,
    output  uint8   audio_output,
    input   uint1   active
) <reginputs> {
    uint15  point = uninitialised;
    uint15  pointP1 <:: point + update;

    brom uint8 sines[256] = {
        128,131,134,137,140,144,147,150,153,156,159,162,165,168,171,174,
        177,179,182,185,188,191,193,196,199,201,204,206,209,211,213,216,
        218,220,222,224,226,228,230,232,234,235,237,239,240,241,243,244,
        245,246,248,249,250,250,251,252,253,253,254,254,254,255,255,255,
        255,255,255,255,254,254,254,253,253,252,251,250,250,249,248,246,
        245,244,243,241,240,239,237,235,234,232,230,228,226,224,222,220,
        218,216,213,211,209,206,204,201,199,196,193,191,188,185,182,179,
        177,174,171,168,165,162,159,156,153,150,147,144,140,137,134,131,
        128,125,122,119,116,112,109,106,103,100,97,94,91,88,85,82,
        79,77,74,71,68,65,63,60,57,55,52,50,47,45,43,40,
        38,36,34,32,30,28,26,24,22,21,19,17,16,15,13,12,
        11,10,8,7,6,6,5,4,3,3,2,2,2,1,1,1,
        1,1,1,1,2,2,2,3,3,4,5,6,6,7,8,10,11,
        12,13,15,16,17,19,21,22,24,26,28,30,32,34,36,38,
        40,43,45,47,50,52,55,57,60,63,65,68,71,74,77,79,
        82,85,88,91,94,97,100,103,106,109,112,116,119,122,125
    };
    sines.addr := point[0,8];                                                                                                   // POINTER INTO SINE TABLE
    bit_samples.addr0 := point[3,4]; wave_samples.addr0 := point[0,8]; pcm_samples.addr0 := point;                              // POINTERS INTO BITSAMPLES, USER WAVEFORM, PCM SAMPLES TABLES

    point := ~active ? 0 : pointP1;                                                                                             // WAVEFORM POINT ONLY RESETS WHEN AUDIO GOES INACTIVE, ALLOWS BIT SAMPLES TO REPEAT

    always_after {
        switch( selected_waveform ) {
            case 0: { audio_output = { point[7,1], 7b1111111 }; }                                                               // SQUARE
            case 1: { audio_output = point[0,8]; }                                                                              // SAWTOOTH
            case 2: { audio_output = ( point[7,1] ? ~{ point[0,7], 1b1 } : { point[0,7], 1b0 } ); }                             // TRIANGLE
            case 3: { audio_output = sines.rdata; }                                                                             // SINE
            case 4: { audio_output = staticGenerator; }                                                                         // NOISE
            case 5: { audio_output = wave_samples.rdata0; }                                                                     // USER DEFINED UD1 = 5
            case 6: { audio_output = {4{pcm_samples.rdata0}}; }                                                                 // PCM SAMPLES 2 bit -> 8 bit
            case 7: { audio_output = {8{bit_samples.rdata0[ point[0,3], 1]}}; }                                                 // 1 BIT SAMPLES, TRANSLATE TO SQUARE WAVE
        }
    }
}

unit audiocounter(
    input   uint1   start,
    input   uint13  selected_frequency,
    input   uint16  selected_duration,
    output  uint1   updatepoint,
    output  uint1   active(0)
) <reginputs> {
    uint13  counter50mhz = uninitialised;           uint13  counter50mhz_NEXT <:: counter50mhz - 1;
    uint16  counter1khz = uninitialised;            uint16  counter1khz_NEXT <:: counter1khz - 1;
    uint16  duration = uninitialised;               uint16  duration_NEXT <:: duration - 1;

    active := ( |duration ); updatepoint := active & ( ~|counter50mhz );

    always_after {
        if( start ) {
            counter50mhz = 0; counter1khz = 50000; duration = selected_duration;
        } else {
            if( updatepoint ) { counter50mhz = selected_frequency; } else { counter50mhz = counter50mhz_NEXT; }
            if( active & ( ~|counter1khz ) ) { counter1khz = 50000; duration = duration_NEXT; } else { counter1khz = counter1khz_NEXT; }
        }
    }
}

// GIVEN THE FREQUENCY INDEX, CONVERT TO 1 to 24, PLUS SHIFT AMOUNT
// ALLOWS FREQUENCY TABLE TO BE 25 ENTRIES LONG
unit octave(
    input   uint7   frequency,
    output  uint5   basefrequency,
    output  uint3   shift
) <reginputs> {
    always_after {
        shift = ( frequency > 120 ) ? 5 : ( frequency > 96 ) ? 4 : ( frequency > 72 ) ? 3 : ( frequency > 48 ) ? 2 : ( frequency > 24 ) ? 1 : 0;
        basefrequency = frequency - ( shift * 24 );
    }
}

// HANDLE WRITING TO THE DOOM PC SPEAKER SAMPLES MEMORY
unit doom_samples_writer(
    simple_dualport_bram_port1  doom_samples,
    input   uint7   samples,
    input   uint1   load,
    input   uint1   newsample,
    output  uint8   max
) <reginputs> {
    uint8   max_NEXT <:: max + 1;

    doom_samples.wenable1 := 1;

    always_after {
        if( newsample ) {
            max = 0;
        } else {
            if( load ) {
                doom_samples.addr1 = max; doom_samples.wdata1 = samples; max = max_NEXT;
            }
        }
    }
}

// HANDLE WRITING TO THE CHIP8 1 BIT SAMPLES MEMORY
unit bitsample_writer(
    simple_dualport_bram_port1  bit_samples,
    input   uint8   samples,
    input   uint1   load,
    input   uint1   newsample
) <reginputs> {
    uint4   max = uninitialised;                    uint4   max_NEXT <:: max + 1;

    bit_samples.wenable1 := 1;

    always_after {
        if( newsample ) {
            max = 0;
        } else {
            if( load ) {
                bit_samples.addr1 = max; bit_samples.wdata1 = samples; max = max_NEXT;
            }
        }
    }
}

// HANDLE WRITING TO THE USER DEFINED WAVEFORM MEMORY
unit wave_samples_writer(
    simple_dualport_bram_port1  wave_samples,
    input   uint8   samples,
    input   uint1   load,
    input   uint1   newsample
) <reginputs> {
    uint8   max = uninitialised;                    uint8   max_NEXT <:: max + 1;

    wave_samples.wenable1 := 1;

    always_after {
        if( newsample ) {
            max = 0;
        } else {
            if( load ) {
                wave_samples.addr1 = max; wave_samples.wdata1 = samples; max = max_NEXT;
            }
        }
    }
}

// HANDLE WRITING TO THE PCM SAMPLES MEMORY
unit pcm_samples_writer(
    simple_dualport_bram_port1  pcm_samples,
    input   uint4   samples,
    input   uint1   load,
    input   uint1   newsample
) <reginputs> {
    uint15   max = uninitialised;               uint15  max_NEXT <:: max + 1;

    pcm_samples.wenable1 := 1;

    always_after {
        if( newsample ) {
            max = 0;
        } else {
            if( load ) {
                pcm_samples.addr1 = max; pcm_samples.wdata1 = samples; max = max_NEXT;
            }
        }
    }
}
