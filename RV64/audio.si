// AUDIO MEMORY MAP CONTROLLER
unit audio_memmap(
    // Memory access
    input   uint5   memoryAddress,                                                                                              // BITS 1-5
    input   uint1   memoryWrite,
    input   uint16  writeData,
    output  uint16  readData,

    // AUDIO
    output  uint4   audio_l,
    output  uint4   audio_r,

    // RNG
    input  uint8   static8bit
) <reginputs> {
    // BLOCK STORAGE FOR "DOOM SAMPLES" - A SERIES OF NOTES TO BE PLAYED FOR A GIVEN NUMBER OF MILLISECONDS
    simple_dualport_bram uint7 samples_left[256] = uninitialized;
    simple_dualport_bram uint7 samples_right[256] = uninitialized;
    doom_samples_writer DSL( doom_samples <:> samples_left, samples <: writeData[0,7] );
    doom_samples_writer DSR( doom_samples <:> samples_right, samples <: writeData[0,7] );

    // BLOCK STORAGE FOR "BIT SAMPLES" - 128 x 1 bit SAMPLES ( very crude digital sounds ), STORED AS 16 x 8 bits PER CHANNEL
    simple_dualport_bram uint8 bit_samples_left[16] = uninitialized;
    simple_dualport_bram uint8 bit_samples_right[16] = uninitialized;
    bitsample_writer BSL( bit_samples <:> bit_samples_left, samples <: writeData[0,8] );
    bitsample_writer BSR( bit_samples <:> bit_samples_right, samples <: writeData[0,8] );

    // BLOCK STORAGE FOR USER DEFINED WAVEFORMS - 256 x 8 BIT SAMPLES
    simple_dualport_bram uint8 wave_samples_left[256] = uninitialized;
    simple_dualport_bram uint8 wave_samples_right[256] = uninitialized;
    wave_samples_writer WSL( wave_samples <:> wave_samples_left, samples <: writeData[0,8] );
    wave_samples_writer WSR( wave_samples <:> wave_samples_right, samples <: writeData[0,8] );

    // BLOCK STORAGE FOR PCM SAMPLES - 32768 x 2 bit SAMPLES
    simple_dualport_bram uint2 pcm_samples_left[$PCM$] = uninitialized;
    simple_dualport_bram uint2 pcm_samples_right[$PCM$] = uninitialized;
    pcm_samples_writer PSL( pcm_samples <:> pcm_samples_left, samples <: writeData[6,2] );
    pcm_samples_writer PSR( pcm_samples <:> pcm_samples_right, samples <: writeData[6,2] );

    // Left and Right audio channels
    audio apu_processor_L(
        samples <:> samples_left,
        bit_samples <:> bit_samples_left,
        wave_samples <:> wave_samples_left,
        pcm_samples <:> pcm_samples_left,
        staticGenerator <: static8bit,
        audio :> audio_l,
        samples_MAX <: DSL.max,
    );
    audio apu_processor_R(
        samples <:> samples_right,
        bit_samples <:> bit_samples_right,
        wave_samples <:> wave_samples_right,
        pcm_samples <:> pcm_samples_right,
        staticGenerator <: static8bit,
        audio :> audio_r,
        samples_MAX <: DSR.max
    );

    // SAMPLE MEMORY CONTROLS
    DSL.newsample := 0; DSR.newsample := 0; DSL.load := 0; DSR.load := 0;                                                       // DOOM STYLE PC SPEAKER SAMPLES
    BSL.newsample := 0; BSR.newsample := 0; BSL.load := 0; BSR.load := 0;                                                       // CHIP8 1 BIT SAMPLES
    WSL.newsample := 0; WSR.newsample := 0; WSL.load := 0; WSR.load := 0;                                                       // USER DEFINED WAVEFORM SAMPLES
    PSL.newsample := 0; PSR.newsample := 0; PSL.load := 0; PSR.load := 0;                                                       // PCM SAMPLES

    apu_processor_L.apu_write := 0; apu_processor_R.apu_write := 0;                                                             // HOLD WRITE TRIGGERS AT 0
    readData := memoryAddress[3,1] ? memoryAddress[0,1] ? apu_processor_R.audio_active : apu_processor_L.audio_active : $PCM$;  // RETURN AUDIO ACTIVE STATE TO CPU OR NUMBER OF PCM SAMPLES SUPPORTED

    algorithm <autorun> {
        apu_processor_L.volume = 7; apu_processor_R.volume = 7;                                                                 // RESET VOLUMES

        while(1) {
            // WRITE IO Memory
            if( memoryWrite ) {
                switch( memoryAddress ) {
                    case 5h0: { apu_processor_L.waveform = writeData; apu_processor_R.waveform = writeData; }                   // SET APU FROM CPU
                    case 5h1: { apu_processor_L.frequency = writeData; apu_processor_R.frequency = writeData; }
                    case 5h2: { apu_processor_L.duration = writeData; apu_processor_R.duration = writeData; }
                    case 5h3: { apu_processor_L.apu_write = writeData[0,1]; apu_processor_R.apu_write = writeData[1,1]; }
                    case 5h4: { DSL.newsample = writeData[0,1]; DSR.newsample = writeData[1,1]; }                               // RESET SAMPLES
                    case 5h5: { DSL.load = 1; }                                                                                 // WRITE TO LEFT DOOM SAMPLE MEMORY
                    case 5h6: { DSR.load = 1; }                                                                                 // WRITE TO RIGHT DOOM SAMPLE MEMORY
                    case 5h8: { apu_processor_L.volume = writeData; }                                                           // SET VOLUME LEFT
                    case 5h9: { apu_processor_R.volume = writeData; }                                                           // SET VOLUME RIGHT
                    case 5ha: { BSL.newsample = writeData[0,1]; BSR.newsample = writeData[1,1]; }                               // RESET BIT SAMPLES
                    case 5hb: { BSL.load = 1; }                                                                                 // WRITE TO LEFT BIT SAMPLE MEMORY
                    case 5hc: { BSR.load = 1;  }                                                                                // WRITE TO RIGHT BIT SAMPLE MEMORY
                    case 5hd: { WSL.newsample = writeData[0,1]; WSR.newsample = writeData[1,1]; }                               // RESET WAVE SAMPLES
                    case 5he: { WSL.load = 1; }                                                                                 // WRITE TO LEFT WAVEFORM MEMORY
                    case 5hf: { WSR.load = 1;  }                                                                                // WRITE TO RIGHT WAVEFORM MEMORY
                    case 5h10: { PSL.newsample = writeData[0,1]; PSR.newsample = writeData[1,1]; }                              // RESET PCM SAMPLES TO 0
                    case 5h11: { PSL.load = 1; }                                                                                // WRITE TO LEFT PCM SAMPLE MEMORY
                    case 5h12: { PSR.load = 1;  }                                                                               // WRITE TO RIGHT PCM SAMPLE MEMORY
                    default: {}
                }
            }
        }
    }
}

// AUDIO Channel Controller
unit audio(
    simple_dualport_bram_port0  samples,
    simple_dualport_bram_port0  bit_samples,
    simple_dualport_bram_port0  wave_samples,
    simple_dualport_bram_port0  pcm_samples,

    input   uint8   staticGenerator,
    input   uint5   waveform,
    input   uint7   frequency,
    input   uint16  duration,
    input   uint1   apu_write,
    input   uint3   volume,
    output  uint4   audio,
    output  uint1   audio_active,

    input   uint8   samples_MAX,
) <reginputs> {
    octave CPUINPUT( frequency <: frequency ); octave SINPUT( frequency <: samples.rdata0 );                                    // Generate base and shift for cpuinput / present doom sample input

    // Audio channel, 8 bit output from audio channel goes through PWM modulator
    apu apu_processor( bit_samples <:> bit_samples, wave_samples <:> wave_samples, pcm_samples <:> pcm_samples, volume <: volume, staticGenerator <: staticGenerator, audio_active :> audio_active );
    audio_pwm PWM( active <: apu_processor.audio_active, wave <: apu_processor.audio_output, audio :> audio );

    apu_processor.apu_write := 0;

    algorithm <autorun> {
        uint13 frequency_table[] = {
            0,
            6328, 6144, 5972, 5800, 5638, 5474, 5320, 5168, 5022, 4878, 4740, 4604,                                             // FREQUENCY TABLE - FIRST 24 NOTES, USE OCTAVE ALGORITHM TO GET ADDITIONAL NOTES
            4474, 4344, 4224, 4102, 3986, 3870, 3762, 3654, 3552, 3448, 3352, 3056                                              // 3 = c 2 , 5 = c#2, 7 = d 2... ( rest generated by shifts ) + 24 per octave
        };
        uint13  CPUfrequency <:: frequency_table[ CPUINPUT.basefrequency ] >> CPUINPUT.shift;                                   // COUNTER FOR CPU INPUT
        uint13  Sfrequency <:: frequency_table[ SINPUT.basefrequency ] >> SINPUT.shift;                                         // COUNTER FOR SAMPLE INPUT

        uint8   SAMP0P1 <:: samples.addr0 + 1;                                                                                  // NEXT ADDRESS IN DOOM PC SPEAKER MODE
        uint1   SAMPLEMODE = uninitialised;                                                                                     // IS CHANNEL IN DOOM PC SPEAKER SAMPLE MODE?
        uint1   REPEAT = uninitialised;                                                                                         // IS REPEAT FOR DOOM PC SPEAKER MODE RQQUIRED?
        uint1   newS = uninitialised;                                                                                           // IS A NEW NOTE REQUIRED WHEN AUDIO STOPS?

        while(1) {
            if( SAMPLEMODE ) {                                                                                                  // DOOM PC SPEAKER MODE?
                if( ~apu_processor.audio_active ) {                                                                             //  PREVIOUS SAMPLE FINISHED?
                    if( newS ) {                                                                                                //  NEW SAMPLE NEEDED?
                        apu_processor.frequency = Sfrequency; apu_processor.apu_write = 1; newS = 0;                            //  SEND NEW NOTE
                        if( SAMP0P1 == samples_MAX ) {                                                                          // AT END OF NOTES?
                            samples.addr0 = 0; SAMPLEMODE = REPEAT;                                                             //  RESTART IF REPEAT
                        } else {
                            samples.addr0 = SAMP0P1;                                                                            // MOVE TO NEXT NOTE
                        }
                    }
                } else {
                    newS = 1;                                                                                                   // DEFAULT TO NEW NOTE REQUIRED
                }
            } else {
                samples.addr0 = 0; newS = 1;                                                                                    // DEFAULT TO START AND NEW NOTE REQUIRED
            }

            if( apu_write ) {                                                                                                   // CPU AUDIO REQUEST
                apu_processor.duration = duration; apu_processor.waveform = waveform[0,3];                                      // SET BASE DURATION AND WAVEFORM
                SAMPLEMODE = waveform[3,1]; REPEAT = waveform[4,1];                                                             // SET DOOM PC SPEAKER SAMPLE MODE AND REPEAT FLAGS
                if( waveform[3,1] ) {
                    samples.addr0 = 0; newS = 1;                                                                                // IF DOOM PC SPEAKER SAMPLE MODE, MOVE TO START
                } else {
                    apu_processor.frequency = CPUfrequency; apu_processor.apu_write = 1;                                        // NORMAL WAVEFORM MODE, SET FREQUENCY

                }
            }
        }
    }
}

unit apu(                                                                                                                       // Single channel audio output, outputs 8 bits for PWM. 25MHz
    simple_dualport_bram_port0  bit_samples,
    simple_dualport_bram_port0  wave_samples,
    simple_dualport_bram_port0  pcm_samples,
    input   uint3   waveform,
    input   uint13  frequency,
    input   uint16  duration,
    input   uint1   apu_write,
    input   uint8   staticGenerator,
    input   uint3   volume,
    output  uint1   audio_active,
    output  uint8   audio_output
) <reginputs> {
    waveform WAVEFORM(
        active <: COUNTER.active,
        bit_samples <:> bit_samples, wave_samples <:> wave_samples, pcm_samples <:> pcm_samples,
        start <: apu_write, update <: COUNTER.updatepoint,
        selected_waveform <: waveform,
        staticGenerator <: staticGenerator
    );
    audiocounter COUNTER( selected_frequency <: frequency, selected_duration <: duration, start <: apu_write, active :> audio_active );

    algorithm <autorun> { while(1) {
        if( COUNTER.updatepoint ) { audio_output = WAVEFORM.audio_output >> ~volume; }
    } }
}

unit waveform(
    simple_dualport_bram_port0  bit_samples,
    simple_dualport_bram_port0  wave_samples,
    simple_dualport_bram_port0  pcm_samples,
    input   uint1   start,
    input   uint1   update,
    input   uint3   selected_waveform,
    input   uint8   staticGenerator,
    output  uint8   audio_output,
    input   uint1   active
) <reginputs> {
    uint15  point = uninitialised;
    uint15  pointP1 <:: point + update;

    brom uint8 sines[256] = {
        128,131,134,137,140,144,147,150,153,156,159,162,165,168,171,174,
        177,179,182,185,188,191,193,196,199,201,204,206,209,211,213,216,
        218,220,222,224,226,228,230,232,234,235,237,239,240,241,243,244,
        245,246,248,249,250,250,251,252,253,253,254,254,254,255,255,255,
        255,255,255,255,254,254,254,253,253,252,251,250,250,249,248,246,
        245,244,243,241,240,239,237,235,234,232,230,228,226,224,222,220,
        218,216,213,211,209,206,204,201,199,196,193,191,188,185,182,179,
        177,174,171,168,165,162,159,156,153,150,147,144,140,137,134,131,
        128,125,122,119,116,112,109,106,103,100,97,94,91,88,85,82,
        79,77,74,71,68,65,63,60,57,55,52,50,47,45,43,40,
        38,36,34,32,30,28,26,24,22,21,19,17,16,15,13,12,
        11,10,8,7,6,6,5,4,3,3,2,2,2,1,1,1,
        1,1,1,1,2,2,2,3,3,4,5,6,6,7,8,10,11,
        12,13,15,16,17,19,21,22,24,26,28,30,32,34,36,38,
        40,43,45,47,50,52,55,57,60,63,65,68,71,74,77,79,
        82,85,88,91,94,97,100,103,106,109,112,116,119,122,125
    };
    sines.addr := point[0,8];                                                                                                   // POINTER INTO SINE TABLE
    bit_samples.addr0 := point[3,4]; wave_samples.addr0 := point[0,8]; pcm_samples.addr0 := point;                              // POINTERS INTO BITSAMPLES, USER WAVEFORM, PCM SAMPLES TABLES

    point := ~active ? 0 : pointP1;                                                                                             // WAVEFORM POINT ONLY RESETS WHEN AUDIO GOES INACTIVE, ALLOWS BIT SAMPLES TO REPEAT

    algorithm <autorun> { while(1) {
        switch( selected_waveform ) {
            case 0: { audio_output = { point[7,1], 7b1111111 }; }                                                               // SQUARE
            case 1: { audio_output = point[0,8]; }                                                                              // SAWTOOTH
            case 2: { audio_output = ( point[7,1] ? ~{ point[0,7], 1b1 } : { point[0,7], 1b0 } ); }                             // TRIANGLE
            case 3: { audio_output = sines.rdata; }                                                                             // SINE
            case 4: { audio_output = staticGenerator; }                                                                         // NOISE
            case 5: { audio_output = wave_samples.rdata0; }                                                                     // USER DEFINED UD1 = 5
            case 6: { audio_output = {4{pcm_samples.rdata0}}; }                                                                 // PCM SAMPLES 2 bit -> 8 bit
            case 7: { audio_output = {8{bit_samples.rdata0[ point[0,3], 1]}}; }                                                 // 1 BIT SAMPLES, TRANSLATE TO SQUARE WAVE
        }
    } }
}

unit audiocounter(
    input   uint1   start,
    input   uint13  selected_frequency,
    input   uint16  selected_duration,
    output  uint1   updatepoint,
    output  uint1   active(0)
) <reginputs> {
    uint13  counter50mhz = uninitialised;
    uint16  duration = uninitialised;

    active := ( |duration ); updatepoint := active & ( ~|counter50mhz );

    algorithm <autorun> {
        uint13  counter50mhz_NEXT <:: counter50mhz - 1;
        uint16  duration_NEXT <:: duration - 1;
        uint16  counter1khz = uninitialised;            uint16  counter1khz_NEXT <:: counter1khz - 1;

        while(1) {
            if( start ) {
                counter50mhz = 0; counter1khz = 50000; duration = selected_duration;
            } else {
                if( updatepoint ) { counter50mhz = selected_frequency; } else { counter50mhz = counter50mhz_NEXT; }
                if( active & ( ~|counter1khz ) ) { counter1khz = 50000; duration = duration_NEXT; } else { counter1khz = counter1khz_NEXT; }
            }
        }
    }
}

// GIVEN THE FREQUENCY INDEX, CONVERT TO 1 to 24, PLUS SHIFT AMOUNT
// ALLOWS FREQUENCY TABLE TO BE 25 ENTRIES LONG
unit octave(
    input   uint7   frequency,
    output  uint5   basefrequency,
    output  uint3   shift
) <reginputs> {
    shift := ( frequency > 120 ) ? 5 : ( frequency > 96 ) ? 4 : ( frequency > 72 ) ? 3 : ( frequency > 48 ) ? 2 : ( frequency > 24 ) ? 1 : 0;
    basefrequency := frequency - ( shift * 24 );
}

// HANDLE WRITING TO THE DOOM PC SPEAKER SAMPLES MEMORY
unit doom_samples_writer(
    simple_dualport_bram_port1  doom_samples,
    input   uint7   samples,
    input   uint1   load,
    input   uint1   newsample,
    output  uint8   max
) <reginputs> {
    uint8   NEXT <:: doom_samples.addr1 + 1;

    doom_samples.wenable1 := 1; max := NEXT;

    algorithm <autorun> {
        while(1) {
            if( newsample ) {
                doom_samples.addr1 = -1;
            } else {
                if( load ) {
                    doom_samples.addr1 = NEXT; doom_samples.wdata1 = samples;
                }
            }
        }
    }
}

// HANDLE WRITING TO THE CHIP8 1 BIT SAMPLES MEMORY
unit bitsample_writer(
    simple_dualport_bram_port1  bit_samples,
    input   uint8   samples,
    input   uint1   load,
    input   uint1   newsample
) <reginputs> {
    bit_samples.wenable1 := 1;

    algorithm <autorun> {
        uint4   NEXT <:: bit_samples.addr1 + 1;

        while(1) {
            if( newsample ) {
                bit_samples.addr1 = -1;
            } else {
                if( load ) {
                    bit_samples.addr1 = NEXT; bit_samples.wdata1 = samples;
                }
            }
        }
    }
}

// HANDLE WRITING TO THE USER DEFINED WAVEFORM MEMORY
unit wave_samples_writer(
    simple_dualport_bram_port1  wave_samples,
    input   uint8   samples,
    input   uint1   load,
    input   uint1   newsample
) <reginputs> {
    wave_samples.wenable1 := 1;

    algorithm <autorun> {
        uint8   NEXT <:: wave_samples.addr1 + 1;

        while(1) {
            if( newsample ) {
                wave_samples.addr1 = -1;
            } else {
                if( load ) {
                    wave_samples.addr1 = NEXT; wave_samples.wdata1 = samples;
                }
            }
        }
    }
}

// HANDLE WRITING TO THE PCM SAMPLES MEMORY
unit pcm_samples_writer(
    simple_dualport_bram_port1  pcm_samples,
    input   uint4   samples,
    input   uint1   load,
    input   uint1   newsample
) <reginputs> {
    pcm_samples.wenable1 := 1;

    algorithm <autorun> {
        uint15  NEXT <:: pcm_samples.addr1 + 1;

        while(1) {
            if( newsample ) {
                pcm_samples.addr1 = -1;
            } else {
                if( load ) {
                    pcm_samples.addr1 = NEXT; pcm_samples.wdata1 = samples;
                }
            }
        }
    }
}
