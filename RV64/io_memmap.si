unit io_memmap(
    // LEDS (8 of) + SDCARD JOYSTICK CAPSLOCK NUMLOCK STATUS LIGHTS
    output  uint8   leds,
    output  uint2   sdcardlightcolour,
    output  uint1   CAPSLOCK(0),
    output  uint1   NUMLOCK(0),
    output  uint1   JOYSTICK(1),
    output  uint1   RESETSTATUS(0),

$$if not SIMULATION then
    input   uint$NUM_BTNS$ btns,
    output  uint10   mouse_x(320),
    output  uint9   mouse_y(240),

    // GPIO
    input   uint28  gn,
    output  uint28  gp,

    // UART
    output  uint1   uart_tx,
    input   uint1   uart_rx,

    // USB for PS/2
    input   uint1   us2_bd_dp,
    input   uint1   us2_bd_dn,

    // SDCARD
    output  uint1   sd_clk,
    output  uint1   sd_mosi,
    output  uint1   sd_csn,
    input   uint1   sd_miso,
$$end
    // I2C
    inout   uint1   gpdi_sda,
    inout   uint1   gpdi_scl,

    // CLOCKS
    input   uint1   clock_25mhz,

    // Memory access
    input   uint12  memoryAddress,
    input   uint1   memoryWrite,
    input   uint1   memoryRead,
    input   uint32  writeData,
    output  uint32  readData,

    // SMT STATUS
    output  uint1   SMTRUNNING(0),
    output  uint$addr_width$  SMTSTARTPC(0),

    // MINI DMA CONTROLLER
    output  uint$addr_width$  DMASOURCE,
    output  uint$addr_width$  DMASOURCEADD,
    output  uint$addr_width$  DMADEST,
    output  uint$addr_width$  DMADESTADD,
    output  uint$addr_width$  DMACOUNT(0),
    output  uint8   DMACYCLES(0),
    output  uint4   DMAMODE(0),
    output  uint32  DMASET,
    input   uint1   DMAACTIVE,

    // System Capabilities Flag
    input   uint32  SOC
) <reginputs> {
$$if not SIMULATION then
    // UART CONTROLLER, CONTAINS BUFFERS FOR INPUT/OUTPUT
    uart_IN UART_IN( uart_rx <: uart_rx );
    uart_OUT UART_OUT( uart_tx :> uart_tx, outchar <: writeData[0,8] );

    // PS2 CONTROLLER, CONTAINS BUFFERS FOR INPUT/OUTPUT
    ps2buffer PS2( us2_bd_dp <: us2_bd_dp, us2_bd_dn <: us2_bd_dn );

    // SDCARD AND BUFFER
    simple_dualport_bram uint8 buffer_in[512] = uninitialized;                                                                  // READ FROM SDCARD
    simple_dualport_bram uint8 buffer_out[512] = uninitialized;                                                                 // WRITE TO SDCARD
    sdcardcontroller SDCARD(
        sd_clk :> sd_clk,
        sd_mosi :> sd_mosi,
        sd_csn :> sd_csn,
        sd_miso <: sd_miso,
        buffer_in <:> buffer_in,
        buffer_out <:> buffer_out
    );
$$end

    // I2C FOR RTC
    rtc RTC( clk <: clock, reset <: reset, sda <:> gpdi_sda, scl <:> gpdi_scl );                                                // EMARD verilog version
    //mcp7940n RTC <@clock_25mhz> ( sda <:> gpdi_sda, scl <:> gpdi_scl );                                                       // Silice translation (not yet working)


$$if not SIMULATION then
    // I/O FLAGS
    UART_IN.inread := 0; UART_OUT.outwrite := 0; PS2.inread := 0;
    SDCARD.readsector := 0; SDCARD.writesector := 0; buffer_out.wenable1 := 0;
$$end
    RTC.wr := 0; RESETSTATUS := 0;

    always_after {
        uint1   MAGICVALUE = uninitialised;                                                                                     // WRITE 32h50415357 { 'P', 'A', 'W', 'S' } TO ALLOW WRITING TO SDCARD SECTOR 0
        uint20  mouse_latch = uninitialised;                                                                                    // MOUSE LATCH AFTER MOVE
        uint64  LATCHrtc = uninitialised;                                                                                       // LATCH RTC ON READ SO SAME VALUE IS RETURNED FOR FULL 64 BIT READ

        if( reset ) {
            $$if not SIMULATION then
                PS2.outputkeycodes = 0;
            $$end
            RTC.addr = 7; MAGICVALUE = 0;
        }

        // READ IO Memory
        if( memoryRead ) {
            switch( memoryAddress[8,4] ) {
                $$if not SIMULATION then
                case 4h0: {
                    if( memoryAddress[1,1] ) {
                        readData = { 14b0, UART_OUT.outfull, UART_IN.inavailable };
                    } else {
                        readData = { 8b0, UART_IN.inchar }; UART_IN.inread = 1;
                    }
                }
                case 4h1: {
                    if( memoryAddress[1,1] ) {
                        if( PS2.inavailable ) {
                            readData = PS2.inkey; PS2.inread = 1;
                        } else {
                            readData = 0;
                        }
                    } else {
                        readData = PS2.inavailable;
                    }
                }
                case 4h2: {
                    switch( memoryAddress[1,2] ) {
                        case 2b00: { readData = PS2.outputkeycodes ? { $16-NUM_BTNS$b0, btns[0,$NUM_BTNS$] } : { $16-NUM_BTNS$b0, btns[0,$NUM_BTNS$] } | PS2.joystick; }
                        case 2b01: { readData = mouse_x; }
                        case 2b10: { readData = mouse_y; }
                        case 2b11: { readData = btns[1,2]; }
                    }
                }
                case 4h4: { readData = SDCARD.ready; if( SDCARD.ready ) { sdcardlightcolour = 0; RESETSTATUS = 1; } }
                case 4h5: { readData = buffer_in.rdata0; buffer_in.addr0 = buffer_in.addr0 + 1; }
                $$end
                case 4h3: { readData = leds; }
                case 4h6: {
                    switch( memoryAddress[2,1] ) {
                        case 0: { LATCHrtc = RTC.datetime_o; readData = RTC.datetime_o[0,32]; }
                        case 1: { readData = LATCHrtc[32,32]; }
                    }
                }
                case 4h7: {
                    switch( memoryAddress[2,2] ) {
                        case 2b00: { readData = 32b00000010000; }                                                               // PAWS SOC
                        case 2b01: { readData = 32h4000000; }                                                                   // RAMBASE
                        case 2b10: { readData = 32h5f00000; }                                                                   // RAMTOP
                        case 2b11: { readData = 32h6000000; }                                                                   // MAIN STACK TOP
                    }
                }
                case 4he: { readData = DMASET; }
                case 4hf: { readData = SMTRUNNING; }
                default: { readData = 0; }
            }
        }

        // WRITE IO Memory
        if( memoryWrite ) {
            switch( memoryAddress[8,4] ) {
                $$if not SIMULATION then
                case 4h0: { UART_OUT.outwrite = 1; }
                case 4h1: {
                    switch( memoryAddress[1,2] ) {
                        default: { PS2.outputkeycodes = writeData; JOYSTICK = ~writeData; RESETSTATUS = 1; }
                        case 2h1: { CAPSLOCK = writeData; RESETSTATUS = 1; }
                        case 2h2: { NUMLOCK = writeData; RESETSTATUS = 1; }
                    }
                }
                case 4h4: {
                    switch( memoryAddress[1,2] ) {
                        case 2h0: { SDCARD.readsector = 1; RESETSTATUS = 1; sdcardlightcolour = 1; }
                        case 2h1: { SDCARD.writesector = |SDCARD.sectoraddress | MAGICVALUE; RESETSTATUS = 1; sdcardlightcolour = 2; }
                        default: { SDCARD.sectoraddress = writeData; }
                    }
                }
                case 4h5: {
                    switch( memoryAddress[1,1] ) {
                        case 0: { buffer_in.addr0 = 0; buffer_out.addr1 = 511; }
                        case 1: { buffer_out.addr1 = buffer_out.addr1 + 1; buffer_out.wdata1 = writeData; buffer_out.wenable1 = 1; }
                    }
                }
                $$end
                case 4h3: { leds = writeData; }
                case 4h7: { MAGICVALUE = ( writeData == 32h50415357 ); }                                                        // SPECIAL VALUE TO ALLOW WRITING TO SDCARD SECTOR 0 { 'P', 'A', 'W', 'S' }
                case 4hd: {
                    switch( memoryAddress[2,2] ) {
                        case 2b00: { DMASOURCEADD = writeData; }
                        case 2b01: { DMADESTADD = writeData; }
                        case 2b10: { DMACYCLES = writeData; }
                        case 2b11: { DMASET = writeData; }
                    }
                }
                case 4he: {
                    switch( memoryAddress[2,2] ) {
                        case 2b00: { DMASOURCE = writeData; }
                        case 2b01: { DMADEST = writeData; }
                        case 2b10: { DMACOUNT = writeData; }
                        case 2b11: { if( memoryAddress[1,1] ) { DMASET = {4{writeData[0,8]}}; } else { DMAMODE = writeData; } }
                    }
                }
                case 4hf: {
                    switch( memoryAddress[2,1] ) {
                        case 1b0: { SMTSTARTPC = writeData; }
                        case 1b1: { SMTRUNNING = writeData; }
                    }
                }
                default: {}
            }
        }

        $$if not SIMULATION then
            if( |mouse_latch ) {                                                                                                // HANDLE SIMULATED MOUSE USING ULX3S BUTTONS
                mouse_latch = mouse_latch - 1;
            } else {
                switch( btns[3,2] ) {
                    case 2b01: { mouse_y = mouse_y - ( |mouse_y ); }
                    case 2b10: {  mouse_y = mouse_y + ( mouse_y != 479 ); }
                    default: {}
                }
                switch( btns[5,2] ) {
                    case 2b01: { mouse_x = mouse_x - ( |mouse_x ); }
                    case 2b10: { mouse_x = mouse_x + ( mouse_x != 639 ); }
                    default: {}
                }
                mouse_latch = |btns[3,4] ? 20h80000 : 0;
            }
        $$end

        if( DMAACTIVE ) { DMAMODE = 0; }                                                                                        // CANCEL DMA REQUEST ONCE DMA STARTS
    }
}

unit timers_memmap(
    // CLOCKS
    input   uint1   clock_25mhz,

    // Memory access
    input   uint6   memoryAddress,
    input   uint1   memoryWrite,
    input   uint1   memoryRead,
    input   uint32  writeData,
    output  uint32  readData,

    // RNG + CURSOR BLINK
    output  uint16  static16bit,
    output  uint1   cursor
) <reginputs> {
    // TIMERS and RNG
    timers_rng timers <@clock_25mhz> ( seconds :> cursor, g_noise_out :> static16bit );

    always_after {
        uint1   LATCHmemoryWrite = uninitialized;                                                                               // LATCH MEMORYWRITE SO AS NOT TO SEND DOUBLE REQUESTS
        uint64  LATCHseconds = uninitialised; uint25  LATCHmilliseconds = uninitialised;                                        // LATCH TIME OF DAY SO READ RETURNS THE SAME TIME

        // READ IO Memory
        if( memoryRead ) {
            if( memoryAddress[5,1] ) {
                switch( memoryAddress[2,2] ) {
                    case 2h0: { LATCHseconds = timers.seconds; LATCHmilliseconds = timers.milliseconds; readData = timers.seconds[0,32]; }
                    case 2h1: { readData = LATCHseconds[32,32]; }
                    case 2h2: { readData = LATCHmilliseconds; }
                    default: { readData = 0; }
                }
            } else {
                switch( memoryAddress[1,4] ) {
                    // RNG ( 2 interger, 1 float 0 <= fng < 1 ) and TIMERS
                    case 4h0: { readData = timers.g_noise_out; }
                    case 4h1: { readData = timers.u_noise_out; }
                    case 4h2: { readData = { 1b0, 1b0, timers.u_noise_out[0,7], timers.g_noise_out[0,16], timers.u_noise_out[7,7] }; }
                    case 4h8: { readData = timers.timer1hz0; }
                    case 4h9: { readData = timers.timer1hz1; }
                    case 4ha: { readData = timers.timer1khz0; }
                    case 4hb: { readData = timers.timer1khz1; }
                    case 4hc: { readData = timers.sleepTimer0; }
                    case 4hd: { readData = timers.sleepTimer1; }
                    default: { readData = 0; }
                }
            }
        }

        // WRITE IO Memory
        switch( { memoryWrite, LATCHmemoryWrite } ) {
            case 2b10: {
                if( memoryAddress[5,1] ) {
                    switch( memoryAddress[2,2] ) {
                        case 2h0: { timers.newtime[0,32] = writeData; }
                        case 2h1: { timers.newtime[32,32] = writeData; }
                        default: { timers.resetcounter = 7; }
                    }
                } else {
                    timers.counter = writeData; timers.resetcounter = memoryAddress[1,3] + 1;
                }
            }
            case 2b00: { timers.resetcounter = 0; }
            default: {}
        }
        LATCHmemoryWrite = memoryWrite;
    }
}

// TIMERS and RNG Controllers
unit timers_rng(
    output  uint64  seconds,
    input   uint64  newtime,
    output  uint20  milliseconds,
    output  uint16  timer1hz0,
    output  uint16  timer1hz1,
    output  uint16  timer1khz0,
    output  uint16  timer1khz1,
    output  uint16  sleepTimer0,
    output  uint16  sleepTimer1,
    output  uint16  u_noise_out,
    output  uint16  g_noise_out,
    input   uint16  counter,
    input   uint3   resetcounter
) <reginputs> {
    // RNG random number generator
    random rng( u_noise_out :> u_noise_out,  g_noise_out :> g_noise_out );

    // 1hz timers (P1 used for systemClock, T1hz0 and T1hz1 for user purposes)
    timesinceboot P1( newtime <: newtime, counter1hz :> seconds, counter1mhz :> milliseconds );
    pulse1hz T1hz0( counter1hz :> timer1hz0 );
    pulse1hz T1hz1( counter1hz :> timer1hz1 );

    // 1khz timers (sleepTimers used for sleep command, timer1khzs for user purposes)
    pulse1khz T0khz0( counter1khz :> timer1khz0 );
    pulse1khz T1khz1( counter1khz :> timer1khz1 );
    pulse1khz STimer0( counter1khz :> sleepTimer0 );
    pulse1khz STimer1( counter1khz :> sleepTimer1 );

    P1.resettime := 0;
    T1hz0.resetCounter := 0; T1hz1.resetCounter := 0;
    T0khz0.resetCounter := 0; T1khz1.resetCounter := 0;
    STimer0.resetCounter := 0; STimer1.resetCounter := 0;

    always_after {
        switch( resetcounter ) {
            case 0: {}
            case 1: { T1hz0.resetCounter = 1; }
            case 2: { T1hz1.resetCounter = 1; }
            case 3: { T0khz0.resetCounter = counter; }
            case 4: { T1khz1.resetCounter = counter; }
            case 5: { STimer0.resetCounter = counter; }
            case 6: { STimer1.resetCounter = counter; }
            case 7: { P1.resettime = 1; }
        }
    }
}

// AUDIO MEMORY MAP CONTROLLER
unit audio_memmap(
    // CLOCKS
    input   uint1   clock_25mhz,

    // Memory access
    input   uint5   memoryAddress,                                                                                              // BITS 1-5
    input   uint1   memoryWrite,
    input   uint16  writeData,
    output  uint1   readData,

    // AUDIO
    output  uint4   audio_l,
    output  uint4   audio_r,

    // RNG
    input  uint8   static8bit
) <reginputs> {
    // BLOCK STORAGE FOR "DOOM SAMPLES" - A SERIES OF NOTES TO BE PLAYED FOR A GIVEN NUMBER OF MILLISECONDS
    simple_dualport_bram uint7 samples_left <@clock_25mhz,@clock> [256] = uninitialized;
    simple_dualport_bram uint7 samples_right <@clock_25mhz,@clock> [256] = uninitialized;
    doom_samples_writer DSL( doom_samples <:> samples_left, samples <: writeData[0,7] );
    doom_samples_writer DSR( doom_samples <:> samples_right, samples <: writeData[0,7] );

    // BLOCK STORAGE FOR "BIT SAMPLES" - 128 x 1 bit SAMPLES ( very crude digital sounds ), STORED AS 16 x 8 bits PER CHANNEL
    simple_dualport_bram uint8 bit_samples_left <@clock_25mhz,@clock> [16] = uninitialized;
    simple_dualport_bram uint8 bit_samples_right <@clock_25mhz,@clock> [16] = uninitialized;
    bitsample_writer BSL( bit_samples <:> bit_samples_left, samples <: writeData[0,8] );
    bitsample_writer BSR( bit_samples <:> bit_samples_right, samples <: writeData[0,8] );

    // BLOCK STORAGE FOR USER DEFINED WAVEFORMS - 256 x 8 BIT SAMPLESSTORED AS 256 x 8 BITS PER CHANNEL
    simple_dualport_bram uint8 wave_samples_left <@clock_25mhz,@clock> [512] = uninitialized;
    simple_dualport_bram uint8 wave_samples_right <@clock_25mhz,@clock> [512] = uninitialized;
    wave_samples_writer WSL( wave_samples <:> wave_samples_left, samples <: writeData[0,8] );
    wave_samples_writer WSR( wave_samples <:> wave_samples_right, samples <: writeData[0,8] );

    // BLOCK STORAGE FOR PCM SAMPLES - 20480 x 4 bit SAMPLES
    simple_dualport_bram uint2 pcm_samples_left <@clock_25mhz,@clock> [20480] = uninitialized;
    simple_dualport_bram uint2 pcm_samples_right <@clock_25mhz,@clock> [20480] = uninitialized;
    pcm_samples_writer PSL( pcm_samples <:> pcm_samples_left, samples <: writeData[6,2] );
    pcm_samples_writer PSR( pcm_samples <:> pcm_samples_right, samples <: writeData[6,2] );

    // Left and Right audio channels
    audio apu_processor_L <@clock_25mhz> (
        samples <:> samples_left,
        bit_samples <:> bit_samples_left,
        wave_samples <:> wave_samples_left,
        pcm_samples <:> pcm_samples_left,
        staticGenerator <: static8bit,
        audio :> audio_l,
        samples_MAX <: DSL.max,
    );
    audio apu_processor_R <@clock_25mhz> (
        samples <:> samples_right,
        bit_samples <:> bit_samples_right,
        wave_samples <:> wave_samples_right,
        pcm_samples <:> pcm_samples_right,
        staticGenerator <: static8bit,
        audio :> audio_r,
        samples_MAX <: DSR.max
    );

    // SAMPLE MEMORY CONTROLS
    DSL.newsample := 0; DSR.newsample := 0; DSL.load := 0; DSR.load := 0;                                                       // DOOM STYLE PC SPEAKER SAMPLES
    BSL.newsample := 0; BSR.newsample := 0; BSL.load := 0; BSR.load := 0;                                                       // CHIP8 1 BIT SAMPLES
    WSL.newsample := 0; WSR.newsample := 0; WSL.load := 0; WSR.load := 0;                                                       // USER DEFINED WAVEFORM SAMPLES
    PSL.newsample := 0; PSR.newsample := 0; PSL.load := 0; PSR.load := 0;                                                       // PCM SAMPLES

    always_after {
        uint1   LATCHmemoryWrite = uninitialized;                                                                               // LATCH MEMORYWRITE 50MHz -> 25 MHz

        if( reset ) { apu_processor_L.volume = 7; apu_processor_R.volume = 7; }
        readData = memoryAddress[0,1] ? apu_processor_R.audio_active : apu_processor_L.audio_active;

        // WRITE IO Memory
        switch( { memoryWrite, LATCHmemoryWrite } ) {
            case 2b10: {
                switch( memoryAddress ) {
                    case 5h0: { apu_processor_L.waveform = writeData; apu_processor_R.waveform = writeData; }                   // SET APU FROM CPU
                    case 5h1: { apu_processor_L.frequency = writeData; apu_processor_R.frequency = writeData; }
                    case 5h2: { apu_processor_L.duration = writeData; apu_processor_R.duration = writeData; }
                    case 5h3: { apu_processor_L.apu_write = writeData[0,1]; apu_processor_R.apu_write = writeData[1,1]; }
                    case 5h4: { DSL.newsample = writeData[0,1]; DSR.newsample = writeData[1,1]; }                               // RESET SAMPLES
                    case 5h5: { DSL.load = 1; }                                                                                 // WRITE TO LEFT DOOM SAMPLE MEMORY
                    case 5h6: { DSR.load = 1; }                                                                                 // WRITE TO RIGHT DOOM SAMPLE MEMORY
                    case 5h8: { apu_processor_L.volume = writeData; }                                                           // SET VOLUME LEFT
                    case 5h9: { apu_processor_R.volume = writeData; }                                                           // SET VOLUME RIGHT
                    case 5ha: { BSL.newsample = writeData[0,1]; BSR.newsample = writeData[1,1]; }                               // RESET BIT SAMPLES
                    case 5hb: { BSL.load = 1; }                                                                                 // WRITE TO LEFT BIT SAMPLE MEMORY
                    case 5hc: { BSR.load = 1;  }                                                                                // WRITE TO RIGHT BIT SAMPLE MEMORY
                    case 5hd: { WSL.newsample = writeData[0,1]; WSR.newsample = writeData[1,1]; }                               // RESET WAVE SAMPLES
                    case 5he: { WSL.load = 1; }                                                                                 // WRITE TO LEFT WAVEFORM MEMORY
                    case 5hf: { WSR.load = 1;  }                                                                                // WRITE TO RIGHT WAVEFORM MEMORY
                    case 5h10: { PSL.newsample = writeData[0,1]; PSR.newsample = writeData[1,1]; }                              // RESET PCM SAMPLES TO 0
                    case 5h11: { PSL.load = 1; }                                                                                // WRITE TO LEFT PCM SAMPLE MEMORY
                    case 5h12: { PSR.load = 1;  }                                                                               // WRITE TO RIGHT PCM SAMPLE MEMORY
                    default: {}
                }
            }
            case 2b00: { apu_processor_L.apu_write = 0; apu_processor_R.apu_write = 0; }
            default: {}
        }
        LATCHmemoryWrite = memoryWrite;
    }
}

// AUDIO Channel Controller
unit audio(
    simple_dualport_bram_port0  samples,
    simple_dualport_bram_port0  bit_samples,
    simple_dualport_bram_port0  wave_samples,
    simple_dualport_bram_port0  pcm_samples,

    input   uint8   staticGenerator,
    input   uint5   waveform,
    input   uint7   frequency,
    input   uint16  duration,
    input   uint1   apu_write,
    input   uint3   volume,
    output  uint4   audio,
    output  uint1   audio_active,

    input   uint8   samples_MAX,
) <reginputs> {
    // FREQUENCY TABLE - FIRST 24 NOTES, USE OCTAVE ALGORITHM TO GET ADDITIONAL NOTES, 3 = c 2 , 5 = c#2, 7 = d 2... ( rest generated by shifts ) + 24 per octave
    uint12 frequency_table[] = {
        0,
        3164, 3072, 2986, 2900, 2819, 2737, 2660, 2584, 2511, 2439, 2370, 2302, 2237, 2172, 2112, 2051, 1993, 1935, 1881, 1827, 1776, 1724, 1676, 1528
    };
    octave CPUINPUT( frequency <: frequency );                  uint12  CPUfrequency <:: frequency_table[ CPUINPUT.basefrequency ] >> CPUINPUT.shift;
    octave SINPUT( frequency <: samples.rdata0 );               uint12  Sfrequency <:: frequency_table[ SINPUT.basefrequency ] >> SINPUT.shift;

    // Audio channel, 8 bit output from audio channel goes through PWM modulator
    apu apu_processor( bit_samples <:> bit_samples, wave_samples <:> wave_samples, pcm_samples <:> pcm_samples, volume <: volume, staticGenerator <: staticGenerator, audio_active :> audio_active );
    audio_pwm PWM( active <: apu_processor.audio_active, wave <: apu_processor.audio_output, audio :> audio );

    apu_processor.apu_write := 0;

    always_after {
        uint1   SAMPLEMODE = uninitialised;                                                                                     // IS CHANNEL IN DOOM PC SPEAKER SAMPLE MODE?
        uint1   REPEAT = uninitialised;                                                                                         // IS REPEAT FOR DOOM PC SPEAKER MODE RQQUIRED?
        uint1   newS = uninitialised;                                                                                           // IS A NEW NOTE REQUIRED WHEN AUDIO STOPS?
        uint8   SAMP0P1 = samples.addr0 + 1;                                                                                    // NEXT ADDRESS IN DOOM PC SPEAKER MODE

        if( SAMPLEMODE ) {                                                                                                      // DOOM PC SPEAKER MODE?
            if( ~apu_processor.audio_active ) {                                                                                 //  PREVIOUS SAMPLE FINISHED?
                if( newS ) {                                                                                                    //  NEW SAMPLE NEEDED?
                    apu_processor.frequency = Sfrequency; apu_processor.apu_write = 1; newS = 0;                                //  SEND NEW NOTE
                    if( SAMP0P1 == samples_MAX ) { samples.addr0 = 0; SAMPLEMODE = REPEAT; } else { samples.addr0 = SAMP0P1; }  //  MOVE TO NEXT NOTE, STOP IF AT END OR REPEAT
                }
            } else {
                newS = 1;                                                                                                       // DEFAULT TO NEW NOTE REQUIRED
            }
        } else {
            samples.addr0 = 0; newS = 1;                                                                                        // DEFAULT TO START AND NEW NOTE REQUIRED
        }

        if( apu_write ) {                                                                                                       // CPU AUDIO REQUEST
            apu_processor.duration = duration; apu_processor.waveform = waveform[0,3];                                          // SET BASE DURATION AND WAVEFORM
            SAMPLEMODE = waveform[3,1]; REPEAT = waveform[4,1];                                                                 // SET DOOM PC SPEAKER SAMPLE MODE AND REPEAT FLAGS
            if( waveform[3,1] ) {
                samples.addr0 = 0; newS = 1;                                                                                    // IF DOOM PC SPEAKER SAMPLE MODE, MOVE TO START
            } else {
                apu_processor.frequency = CPUfrequency; apu_processor.apu_write = 1;                                            // NORMAL WAVEFORM MODE, SET FREQUENCY

            }
        }
    }
}

// UART BUFFER CONTROLLER
// 128 entry FIFO queue
unit fifo8(
    output  uint1   available,
    output  uint1   full,
    input   uint1   read,
    input   uint1   write,
    output  uint8   first,
    input   uint8   last
) <reginputs> {
    simple_dualport_bram uint8 queue[128] = uninitialized;
    uint7   top = 0;
    uint7   next = 0;

    queue.addr0 := next; queue.wenable1 := 1; first := queue.rdata0;

    always_after {
        uint1   update = uninitialized;

        available = ( top != next ); full = ( ( top + 2 ) == next );

        if( write ) { queue.addr1 = top; queue.wdata1 = last; update = 1; } else { if( update ) { top = top + 1; update = 0; } }
        if( read ) { next = next + 1; }
    }
}
unit uart_IN(
    // UART
    input   uint1   uart_rx,
    output  uint1   inavailable,
    output  uint8   inchar,
    input   uint1   inread
) <reginputs> {
    uart_in ui; uart_receiver urecv( io <:> ui, uart_rx <: uart_rx );
    fifo8 IN(
        available :> inavailable,
        first :> inchar,
        read <: inread,
        last <: ui.data_out,
        write <: ui.data_out_ready
    );
}
unit uart_OUT(
    // UART
    output  uint1   uart_tx,
    output  uint1   outfull,
    input   uint8   outchar,
    input   uint1   outwrite
) <reginputs> {
    uart_out uo; uart_sender usend( io <:> uo, uart_tx :> uart_tx );
    fifo8 OUT(
        full :> outfull,
        last <: outchar,
        write <: outwrite,
        first :> uo.data_in
    );

    OUT.read := OUT.available & ~uo.busy; uo.data_in_ready := OUT.available & ~uo.busy;
}

// PS2 BUFFER CONTROLLER
// 10 bit 128 entry FIFO buffer
unit fifo10(
    output  uint1   available,
    input   uint1   read,
    input   uint1   write,
    output  uint10  first,
    input   uint10  last
) <reginputs> {
    uint7   top = 0;
    uint7   next = 0;
    simple_dualport_bram uint10 queue[128] = uninitialized;

    queue.addr0 := next; queue.wenable1 := 1; first := queue.rdata0;

    always_after {
        available = ( top != next );
        if( write ) { queue.addr1 = top; queue.wdata1 = last; top = top + 1; }
        if( read ) { next = next + 1; }
    }
}
unit ps2buffer(
    // USB for PS/2
    input   uint1   us2_bd_dp,
    input   uint1   us2_bd_dn,
    output  uint10  inkey,
    output  uint1   inavailable,
    input   uint1   inread,
    input   uint1   outputkeycodes,
    output  uint16  joystick
) <reginputs> {
    // PS/2 input FIFO (128 character) - 10 bit to deal with special characters
    fifo10 FIFO( available :> inavailable, read <: inread, write <: PS2.keycodevalid, first :> inkey, last <: PS2.keycode );

    // PS/2 KEYCODE AND JOYSTICK EMULATION MAPPER
    ps2ascii PS2( us2_bd_dp <: us2_bd_dp, us2_bd_dn <: us2_bd_dn, outputkeycodes <: outputkeycodes, joystick :> joystick );
}

// SDCARD CONTROLLER
unit sdcardcontroller(
    // SDCARD
    output  uint1   sd_clk,
    output  uint1   sd_mosi,
    output  uint1   sd_csn,
    input   uint1   sd_miso,

    input   uint1   readsector,
    input   uint1   writesector,
    input   uint32  sectoraddress,
    output  uint1   ready,

  simple_dualport_bram_port0 buffer_out,
  simple_dualport_bram_port1 buffer_in
) <reginputs> {
    // SDCARD - Code for the SDCARD from @sylefeb with write support added by self
    sdcardio sdcio; sdcard sd( sd_clk :> sd_clk, sd_mosi :> sd_mosi, sd_csn :> sd_csn, sd_miso <: sd_miso, io <:> sdcio, buffer_read <:> buffer_in, buffer_write <:> buffer_out );

    // SDCARD Commands
    always_after {
        sdcio.read_sector = readsector;
        sdcio.write_sector = writesector;
        sdcio.addr_sector = sectoraddress;
        ready = sdcio.ready;
    }
}
