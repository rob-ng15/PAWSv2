unit io_memmap(
    // LEDS (8 of) + SDCARD JOYSTICK CAPSLOCK NUMLOCK STATUS LIGHTS
    output  uint8   leds,
    output  uint2   sdcardlightcolour,
    output  uint1   CAPSLOCK(0),
    output  uint1   NUMLOCK(0),
    output  uint1   JOYSTICK(1),
    output  uint1   RESETSTATUS,

$$if not SIMULATION then
    input   uint$NUM_BTNS$ btns,
    output  uint10  mouse_x(320),
    output  uint9   mouse_y(240),

    // GPIO
    input   uint28  gn,
    output  uint28  gp,

    // UART
    output  uint1   uart_tx,
    input   uint1   uart_rx,

    // USB for PS/2
    input   uint1   us2_bd_dp,
    input   uint1   us2_bd_dn,

    // SDCARD
    output  uint1   sd_clk,
    output  uint1   sd_mosi,
    output  uint1   sd_csn,
    input   uint1   sd_miso,
    output  uint1   sd_error,
$$end
    // I2C
    inout   uint1   gpdi_sda,
    inout   uint1   gpdi_scl,

    // Memory access
    input   uint12  memoryAddress,
    input   uint1   memoryWrite,
    input   uint1   memoryRead,
    input   uint32  writeData,
    output  uint32  readData,

    // SMT STATUS
    output  uint1   SMTRUNNING(0),
    output  uint$addr_width$  SMTSTARTPC(0),

    // MINI DMA CONTROLLER
    output  uint$addr_width$  DMASOURCE,
    output  uint$addr_width$  DMASOURCEADD,
    output  uint$addr_width$  DMADEST,
    output  uint$addr_width$  DMADESTADD,
    output  uint$addr_width$  DMACOUNT(0),
    output  uint8   DMACYCLES(0),
    output  uint4   DMAMODE(0),
    output  uint32  DMASET,
    input   uint1   DMAACTIVE,

    // System Capabilities Flag
    input   uint32  SOC
) <reginputs> {
$$if not SIMULATION then
    // UART CONTROLLER, CONTAINS BUFFERS FOR INPUT/OUTPUT
    uart_IN UART_IN( uart_rx <: uart_rx );
    uart_OUT UART_OUT( uart_tx :> uart_tx, outchar <: writeData[0,8] );

    // PS2 CONTROLLER, CONTAINS BUFFERS FOR INPUT/OUTPUT
    ps2buffer PS2( us2_bd_dp <: us2_bd_dp, us2_bd_dn <: us2_bd_dn );

    // SDCARD AND BUFFER
    simple_dualport_bram uint8 buffer_in[512] = uninitialized;                                                                  // READ FROM SDCARD
    simple_dualport_bram uint8 buffer_out[512] = uninitialized;                                                                 // WRITE TO SDCARD
    sdcardcontroller SDCARD(
        sd_clk :> sd_clk,
        sd_mosi :> sd_mosi,
        sd_csn :> sd_csn,
        sd_miso <: sd_miso,
        error :> sd_error,
        buffer_in <:> buffer_in,
        buffer_out <:> buffer_out
    );
$$end

    // I2C FOR RTC
    rtc RTC( clk <: clock, reset <: reset, sda <:> gpdi_sda, scl <:> gpdi_scl );                                                // EMARD verilog version

$$if not SIMULATION then
    // I/O FLAGS
    UART_IN.inread := 0; UART_OUT.outwrite := 0; PS2.inread := 0;
    SDCARD.readsector := 0; SDCARD.writesector := 0; buffer_out.wenable1 := 0;
$$end
    RTC.wr := 0; RESETSTATUS := 0;

    algorithm <autorun> {
        uint1   MAGICVALUE = 0;                                                                                                 // WRITE 32h50415357 { 'P', 'A', 'W', 'S' } TO ALLOW WRITING TO SDCARD SECTOR 0

        $$if not SIMULATION then
            PS2.outputkeycodes = 0;
        $$end
        RTC.addr = 7;

        while(1) {
            // READ IO Memory
            uint64  LATCHrtc = uninitialised;                                                                                   // LATCH RTC ON READ SO SAME VALUE IS RETURNED FOR FULL 64 BIT READ

            if( memoryRead ) {
                switch( memoryAddress[8,4] ) {
                    $$if not SIMULATION then
                    case 4h0: {
                        if( memoryAddress[1,1] ) {
                            readData = { 14b0, UART_OUT.outfull, UART_IN.inavailable };
                        } else {
                            readData = { 8b0, UART_IN.inchar }; UART_IN.inread = 1;
                        }
                    }
                    case 4h1: {
                        if( memoryAddress[1,1] ) {
                            if( PS2.inavailable ) {
                                readData = PS2.inkey; PS2.inread = 1;
                            } else {
                                readData = 0;
                            }
                        } else {
                            readData = PS2.inavailable;
                        }
                    }
                    case 4h2: {
                        switch( memoryAddress[1,2] ) {
                            case 2b00: { readData = PS2.outputkeycodes ? { $16-NUM_BTNS$b0, btns[0,$NUM_BTNS$] } : { $16-NUM_BTNS$b0, btns[0,$NUM_BTNS$] } | PS2.joystick; }
                            case 2b01: { readData = mouse_x; }
                            case 2b10: { readData = mouse_y; }
                            case 2b11: { readData = btns[1,2]; }
                        }
                    }
                    case 4h4: {
                        switch( memoryAddress[0,1] ) {
                            case 0: {
                                readData = SDCARD.ready; if( SDCARD.ready ) { sdcardlightcolour = 0; RESETSTATUS = 1; }
                            }
                            case 1: {
                                readData = SDCARD.error; if( SDCARD.error ) { sdcardlightcolour = 3; RESETSTATUS = 1; }
                            }
                        }
                    }
                    case 4h5: { readData = buffer_in.rdata0; buffer_in.addr0 = buffer_in.addr0 + 1; }
                    $$end
                    case 4h3: { readData = leds; }
                    case 4h6: {
                        switch( memoryAddress[2,1] ) {
                            case 0: { LATCHrtc = RTC.datetime_o; readData = RTC.datetime_o[0,32]; }
                            case 1: { readData = LATCHrtc[32,32]; }
                        }
                    }
                    case 4h7: {
                        switch( memoryAddress[2,2] ) {
                            case 2b00: { readData = 32b00000010000; }                                                           // PAWS SOC
                            case 2b01: { readData = 32h4000000; }                                                               // RAMBASE
                            case 2b10: { readData = 32h5f00000; }                                                               // RAMTOP
                            case 2b11: { readData = 32h6000000; }                                                               // MAIN STACK TOP
                        }
                    }
                    case 4he: { readData = DMASET; }
                    case 4hf: { readData = SMTRUNNING; }
                    default: { readData = 0; }
                }
            }

            // WRITE IO Memory
            if( memoryWrite ) {
                switch( memoryAddress[8,4] ) {
                    $$if not SIMULATION then
                    case 4h0: { UART_OUT.outwrite = 1; }
                    case 4h1: {
                        switch( memoryAddress[1,2] ) {
                            default: { PS2.outputkeycodes = writeData; JOYSTICK = ~writeData; RESETSTATUS = 1; }
                            case 2h1: { CAPSLOCK = writeData; RESETSTATUS = 1; }
                            case 2h2: { NUMLOCK = writeData; RESETSTATUS = 1; }
                        }
                    }
                    case 4h4: {
                        switch( memoryAddress[1,2] ) {
                            case 2h0: { SDCARD.readsector = 1; RESETSTATUS = 1; sdcardlightcolour = 1; }
                            case 2h1: { SDCARD.writesector = |SDCARD.sectoraddress | MAGICVALUE; RESETSTATUS = 1; sdcardlightcolour = 2; }
                            default: { SDCARD.sectoraddress = writeData; }
                        }
                    }
                    case 4h5: {
                        switch( memoryAddress[1,1] ) {
                            case 0: { buffer_in.addr0 = 0; buffer_out.addr1 = 511; }
                            case 1: { buffer_out.addr1 = buffer_out.addr1 + 1; buffer_out.wdata1 = writeData; buffer_out.wenable1 = 1; }
                        }
                    }
                    $$end
                    case 4h3: { leds = writeData; }
                    case 4h7: { MAGICVALUE = ( writeData == 32h50415357 ); }                                                    // SPECIAL VALUE TO ALLOW WRITING TO SDCARD SECTOR 0 { 'P', 'A', 'W', 'S' }
                    case 4hd: {
                        switch( memoryAddress[2,2] ) {
                            case 2b00: { DMASOURCEADD = writeData; }
                            case 2b01: { DMADESTADD = writeData; }
                            case 2b10: { DMACYCLES = writeData; }
                            case 2b11: { DMASET = writeData; }
                        }
                    }
                    case 4he: {
                        switch( memoryAddress[2,2] ) {
                            case 2b00: { DMASOURCE = writeData; }
                            case 2b01: { DMADEST = writeData; }
                            case 2b10: { DMACOUNT = writeData; }
                            case 2b11: { if( memoryAddress[1,1] ) { DMASET = {4{writeData[0,8]}}; } else { DMAMODE = writeData; } }
                        }
                    }
                    case 4hf: {
                        switch( memoryAddress[2,1] ) {
                            case 1b0: { SMTSTARTPC = writeData; }
                            case 1b1: { SMTRUNNING = writeData; }
                        }
                    }
                    default: {}
                }
            }

            $$if not SIMULATION then
            uint20  mouse_latch = uninitialised;                                                                                // MOUSE LATCH AFTER MOVE

            if( |mouse_latch ) {                                                                                                // HANDLE SIMULATED MOUSE USING ULX3S BUTTONS
                mouse_latch = mouse_latch - 1;
            } else {
                switch( btns[3,2] ) {
                    case 2b01: { mouse_y = mouse_y - ( |mouse_y ); }
                    case 2b10: {  mouse_y = mouse_y + ( mouse_y != 479 ); }
                    default: {}
                }
                switch( btns[5,2] ) {
                    case 2b01: { mouse_x = mouse_x - ( |mouse_x ); }
                    case 2b10: { mouse_x = mouse_x + ( mouse_x != 639 ); }
                    default: {}
                }
                mouse_latch = |btns[3,4] ? 20h80000 : 0;
            }
            $$end

            if( DMAACTIVE ) { DMAMODE = 0; }                                                                                    // CANCEL DMA REQUEST ONCE DMA STARTS
        }
    }
}

// UART BUFFER CONTROLLER, 128 entry FIFO queue
unit fifo8(
    output  uint1   available,
    output  uint1   full,
    input   uint1   read,
    input   uint1   write,
    output  uint8   first,
    input   uint8   last
) <reginputs> {
    simple_dualport_bram uint8 queue[128] = uninitialized;
    uint7   next = 0;
    uint7   top = 0;

    queue.wenable1 := 1; queue.addr0 := next; first := queue.rdata0;                                                            // BUFFER CONTROLS
    available := ( top != next ); full := ( ( top + 2 ) == next );                                                              // UART CHARACTER AVAILABLE? QUEUE FULL?

    algorithm <autorun> {
        uint7   next_p1 <:: next + 1;
        uint7   top_p1 <:: top + 1;

        while(1) {
            uint1   update = uninitialized;

            if( write ) {
                queue.addr1 = top; queue.wdata1 = last; update = 1;
            } else {
                if( update ) { top = top_p1; update = 0; }
            }
            if( read ) { next = next_p1; }
        }
    }
}
unit uart_IN(
    // UART
    input   uint1   uart_rx,
    output  uint1   inavailable,
    output  uint8   inchar,
    input   uint1   inread
) <reginputs> {
    uart_in ui; uart_receiver urecv( io <:> ui, uart_rx <: uart_rx );                                                           // CONNECT TO UART RECEIVE PINS
    fifo8 IN( available :> inavailable, first :> inchar, read <: inread, last <: ui.data_out, write <: ui.data_out_ready );     // UART IN FIFO BUFFER
}
unit uart_OUT(
    // UART
    output  uint1   uart_tx,
    output  uint1   outfull,
    input   uint8   outchar,
    input   uint1   outwrite
) <reginputs> {
    uart_out uo; uart_sender usend( io <:> uo, uart_tx :> uart_tx );                                                            // CONNECT TO UART TRANSMIT PINS
    fifo8 OUT( full :> outfull, last <: outchar, write <: outwrite, first :> uo.data_in );                                      // UART OUT FIFO BUFFER
    OUT.read := OUT.available & ~uo.busy; uo.data_in_ready := OUT.available & ~uo.busy;                                         // SEND TO UART IF CHARACTER AVAILABLE AND UART NOT BUSY
}

// PS2 BUFFER CONTROLLER, 10 bit 128 entry FIFO buffer
unit fifo10(
    output  uint1   available,
    input   uint1   read,
    input   uint1   write,
    output  uint10  first,
    input   uint10  last
) <reginputs> {
    simple_dualport_bram uint10 queue[128] = uninitialized;
    uint7   next = 0;
    uint7   top = 0;

    queue.wenable1 := 1; queue.addr0 := next; first := queue.rdata0;                                                            // BUFFER CONTROLS
    available := ( top != next );                                                                                               // IS PS/2 INPUT AVAILABLE?

    algorithm <autorun> {
        uint7   next_p1 <:: next + 1;
        uint7   top_p1 <:: top + 1;

        while(1) {
            if( write ) { queue.addr1 = top; queue.wdata1 = last; top = top_p1; }                                               // ADD ENTRY TO BUFFER
            if( read ) { next = next_p1; }                                                                                      // READ FROM BUFFER
        }
    }
}
unit ps2buffer(
    // USB for PS/2
    input   uint1   us2_bd_dp,
    input   uint1   us2_bd_dn,
    output  uint10  inkey,
    output  uint1   inavailable,
    input   uint1   inread,
    input   uint1   outputkeycodes,
    output  uint16  joystick
) <reginputs> {
    fifo10 FIFO( available :> inavailable, read <: inread, write <: PS2.keycodevalid, first :> inkey, last <: PS2.keycode );    // PS/2 input FIFO (128 character) - 10 bit to deal with special characters
    ps2ascii PS2( us2_bd_dp <: us2_bd_dp, us2_bd_dn <: us2_bd_dn, outputkeycodes <: outputkeycodes, joystick :> joystick );     // PS/2 KEYCODE AND JOYSTICK EMULATION MAPPER
}

// SDCARD CONTROLLER - Code for the SDCARD from @sylefeb with write support added by self
unit sdcardcontroller(
    // SDCARD
    output  uint1   sd_clk,
    output  uint1   sd_mosi,
    output  uint1   sd_csn,
    input   uint1   sd_miso,

    input   uint1   readsector,
    input   uint1   writesector,
    input   uint32  sectoraddress,
    output  uint1   ready,
    output  uint1   error,

  simple_dualport_bram_port0 buffer_out,
  simple_dualport_bram_port1 buffer_in
) <reginputs> {
    sdcardio sdcio;
    sdcard sd(
        sd_clk :> sd_clk,                                                                                                       // SD CONTROLLER PINS
        sd_mosi :> sd_mosi,
        sd_csn :> sd_csn,
        sd_miso <: sd_miso,
        io <:> sdcio,                                                                                                           // READ, WRITE, ADDRESS AND READY SIGNALS
        buffer_read <:> buffer_in,                                                                                              // FROM SDCARD
        buffer_write <:> buffer_out                                                                                             // TO SDCARD
    );

    sdcio.addr_sector := sectoraddress;                                                                                         // SECTOR TO READ/WRITE
    sdcio.read_sector := readsector; sdcio.write_sector := writesector;                                                         // READ?WRITE START
    ready := sdcio.ready;                                                                                                       // SDCARD IS READY FOR NEXT COMMAND
    error := sdcio.error;
}
