// ALU - ALU for immediate-register operations and register-register operations

// CALCULATES ADD ADDI SUB SH1ADD SH2ADD SH3ADD
unit aluaddsub(
    input   uint1   size32,                                                                                                     // 32/64 bit flag
    input   uint2   function3,                                                                                                  // SHIFT AMOUNT FOR SHxADD ( will be 0 for regular add )
    input   uint1   doadduw,                                                                                                    // ADD unsigned 32 bit word flag
    input   uint1   dosub,                                                                                                      // SUB flag
    input   int64   sourceReg1,
    input   int64   operand2,
    output  int64   addsub
) <reginputs> {
    always_after {
        addsub = dosub ? ( ( size32 ? sourceReg1[0,32] : sourceReg1 ) - ( size32 ? operand2[0,32] : operand2 ) ) :
                         ( ( ( size32 ? sourceReg1[0,32] : sourceReg1 ) << function3 ) + ( size32 & ~doadduw ? operand2[0,32] : operand2 ) );
    }
}
// CALCULATES BCLR BCLRI BEXT BEXTI BIN BINI BSET BSETI
unit alubits(
    input   uint64  sourceReg1,
    input   uint6   shiftcount,
    output  uint64  CLR,
    output  uint64  INV,
    output  uint64  SET,
    output  uint1   EXT
) <reginputs> {
    always_after {
        uint64  mask = ( 1 << shiftcount );

        CLR = sourceReg1 & ~mask;                   INV = sourceReg1 ^ mask;
        SET = sourceReg1 | mask;                    EXT = sourceReg1[ shiftcount, 1 ];
    }
}
// CALCULATES BREV8
unit alubrev(
    input   uint64  sourceReg1,
    output  uint64  BREV8
) <reginputs> {
    always_after {
        BREV8 = {
                $$for i=0,7 do
                    sourceReg1[$56+i$,1],
                $$end
                $$for i=0,7 do
                    sourceReg1[$48+i$,1],
                $$end
                $$for i=0,7 do
                    sourceReg1[$40+i$,1],
                $$end
                $$for i=0,7 do
                    sourceReg1[$32+i$,1],
                $$end
                $$for i=0,7 do
                    sourceReg1[$24+i$,1],
                $$end
                $$for i=0,7 do
                    sourceReg1[$16+i$,1],
                $$end
                $$for i=0,7 do
                    sourceReg1[$8+i$,1],
                $$end
                $$for i=0,6 do
                    sourceReg1[$i$,1],
                $$end
                sourceReg1[7,1]
        };
    }
}
// CALCULATES CLZ CTZ CPOP
unit alucount(
    input   uint1   size32,
    input   uint2   counttype,
    input   uint64  sourceReg1,
    output  uint7   result
) <reginputs> {
    always_after {
        if( ~|sourceReg1 ) {
            result = { ~size32 & ~counttype[1,1], size32 & ~counttype[1,1], 5b00000 };
        } else {
            switch( counttype ) {
                case 2b00: { if( size32 ) { ( result ) = clz_silice_32( sourceReg1[0,32] ); } else { ( result ) = clz_silice_64( sourceReg1 ); } }
                case 2b01: { if( size32 ) { ( result ) = ctz_silice_32( sourceReg1[0,32] ); } else { ( result ) = ctz_silice_64( sourceReg1 ); } }
                default: { ( result ) = cpop_silice_64( size32 ? sourceReg1[0,32] : sourceReg1 ); }
            }
        }
    }
}
// CALCULATES SEXT.B SEXT.H
unit aluextendsign(
    input   uint1   halfbyte,
    input   uint16  sourceReg1,
    output  uint64  result
)  <reginputs> {
    always_after {
        result = halfbyte ? { {48{sourceReg1[15,1]}}, sourceReg1[0,16] } : { {56{sourceReg1[7,1]}}, sourceReg1[0,8] };
    }
}
// CALCULATES AND/ANDN OR/ORN XOR/XNOR
unit alulogic(
    input   uint1   doinv,
    input   uint64  sourceReg1,
    input   uint64  operand2,
    output  uint64  AND,
    output  uint64  OR,
    output  uint64  XOR
) <reginputs> {
    always_after {
        uint64  operand = doinv ? ~operand2 : operand2;

        AND = sourceReg1 & operand;
        OR = sourceReg1 | operand;
        XOR = sourceReg1 ^ operand;
    }
}
// CALCULATES MAX MAXU MIN MINU
unit aluminmax(
    input   uint2   function3,
    input   uint1   signedcompare,
    input   uint1   unsignedcompare,
    input   uint64  sourceReg1,
    input   uint64  sourceReg2,
    output  uint64  result
) <reginputs> {
    always_after {
        result = function3[1,1] ^ ( function3[0,1] ? unsignedcompare : signedcompare ) ? sourceReg1 : sourceReg2;
    }
}
// UNSIGNED / SIGNED 65 by 65 bit multiplication giving 130 bit product using DSP blocks
unit alumultiply(
    input   uint1   size32,
    input   uint2   function3,
    input   int64   sourceReg1,
    input   int64   sourceReg2,
    output  int64   mult
) <reginputs> {
    always_after {
        uint2   dosigned = function3[1,1] ? { 1b0, ~function3[0,1] } : 2b11;
        int65   factor_1 = size32 ? sourceReg1[0,32] : { dosigned[0,1] & sourceReg1[ 63, 1 ], sourceReg1 };                     // SIGN EXTEND IF SIGNED MULTIPLY
        int65   factor_2 = size32 ? sourceReg2[0,32] : { dosigned[1,1] & sourceReg2[ 63, 1 ], sourceReg2 };                     // SIGN EXTEND IF SIGNED MULTIPLY
        int130  product = factor_1 * factor_2;

        mult = size32 ? product[ 0, 32 ] : product[ { |function3, 6b0 }, 64 ];
    }
}
// CALCULATES ORC.B
unit aluorc(
    input   uint64  sourceReg1,
    output  uint64  ORC
) <reginputs> {
    always_after {
        ORC = {
            {8{ |sourceReg1[56,8] }}, {8{ |sourceReg1[48,8] }}, {8{ |sourceReg1[40,8] }}, {8{ |sourceReg1[32,8] }},
            {8{ |sourceReg1[24,8] }}, {8{ |sourceReg1[16,8] }}, {8{ |sourceReg1[8,8] }}, {8{ |sourceReg1[0,8] }}
        };
    }
}
// CALCULATES PACK PACKH PACKW ( ZEXT.H when rs2 == 0 )
unit alupack(
    input   uint1   size32,
    input   uint64  sourceReg1,
    input   uint64  sourceReg2,
    output  uint64  pack,
    output  uint64  packh,
) <reginputs> {
    always_after {
        pack = size32 ? { 32h0, sourceReg2[0,16], sourceReg1[0,16] } : { sourceReg2[0,32], sourceReg1[0,32] };
        packh = { 48b0, sourceReg2[0,8], sourceReg1[0,8] };
    }
}
// CALCULATES REV8
unit alurev(
    input   uint64  sourceReg1,
    output  uint64  REV8
) <reginputs> {
    always_after {
        REV8 = { sourceReg1[0,8], sourceReg1[8,8], sourceReg1[16,8], sourceReg1[24,8], sourceReg1[32,8], sourceReg1[40,8], sourceReg1[48,8], sourceReg1[56,8] };
    }
}
// CALCULATES SLL SLLI SRL SRLI SRA SRAI + ROL ROR RORI
unit alushift(
    input   uint1   size32,
    input   uint1   reverse,
    input   uint64  sourceReg1,
    input   uint6   shiftcount,
    output  uint64  SLL,
    output  uint64  SRL,
    output  uint64  SRA,
    output  uint64  ROTATE
) <reginputs> {
    always_after {
        uint7 shiftother = { ~size32, size32, 5b00000 } - shiftcount;

        SLL = ( size32 ? sourceReg1[0,32] : sourceReg1 ) << shiftcount;
        SRL = ( size32 ? sourceReg1[0,32] : sourceReg1 ) >> shiftcount;
        SRA = __signed( { size32 ? {32{sourceReg1[31,1]}} : sourceReg1[32,32], sourceReg1[0,32] } ) >>> shiftcount;
        ROTATE = ( ( size32 ? sourceReg1[0,32] : sourceReg1 ) << ( reverse ? shiftother : shiftcount ) ) | ( ( size32 ? sourceReg1[0,32] : sourceReg1 ) >> ( reverse ? shiftcount : shiftother ) );
    }
}

// DECODE ALU INSTRUCTIONS
unit aludecode(
    input   uint1   size32,
    input   uint1   regreg,
    input   uint7   function7,
    input   uint3   function3,
    input   uint5   rs2,

    output  uint1   doadduw,
    output  uint1   doalt,
    output  uint1   dobclrext,
    output  uint1   dobrev,
    output  uint1   docount,
    output  uint1   dobinv,
    output  uint1   dominmax,
    output  uint1   dobset,
    output  uint1   domul,
    output  uint1   doorc,
    output  uint1   dopack,
    output  uint1   dorev,
    output  uint1   dorotate,
    output  uint1   doshxadd,
    output  uint1   dosignx,
    output  uint1   dosra
) <reginputs> {
    always_after {
        uint1   f70000100 = ( function7 == 7b0000100 );                                                                         // DETECT ADD.UW ZEXT.H
        uint1   f70010000 = ( function7 == 7b0010000 );                                                                         // DETECT SHxADD
        uint1   f70110000 = ( function7 == 7b0110000 );                                                                         // DETECT SEXT.B SEXT.H

        doadduw = size32 & regreg & ( f70000100 | f70010000 );                                                                  // ADD.UW SHxADD.UW
        doalt = regreg & ( function7 == 7b0100000 );                                                                            // ADD/SUB AND/ANDN OR/ORN XOR/XNOR ( register - register only )
        dobclrext = ( function7[1,6] == 6b010010 );                                                                             // BCLR BCLRI BEXT BEXTI
        dobrev = ~regreg & ( function7 == 7b0110100 );                                                                          // BREV8
        docount = ~regreg & f70110000 & ~rs2[2,1];                                                                              // CLZ CPOP CTZ ( immediate only )
        dobinv = ( function7[1,6] == 6b011010 );                                                                                // BINV BINVI
        dominmax = regreg & ( function7 == 7b0000101 );                                                                         // MAX MAXU MIN MINU ( register - register only )
        dobset = ( function7[1,6] == 6b001010 );                                                                                // ( F3 == 001 ) BSET BSETI
        domul = regreg & ( function7 == 7b0000001 );                                                                            // MULTIPLICATION
        doorc = ~regreg & ( function7 == 7b0010100 );                                                                           // ( F3 = 101 ) ORC.B
        dopack = regreg & f70000100;                                                                                            // ZEXT.H PACK PACKH PACKW ( ZEXT.H when rs2 == 0 )
        dorev = ~regreg & ( function7 == 7b0110101 );                                                                           // REV8
        dorotate = ( function7[1,6] == 6b011000 );                                                                              // ROL ROR RORI
        doshxadd = regreg & f70010000;                                                                                          // SH1ADD SH2ADD SH3ADD ( register - register only )
        dosignx = ~regreg & f70110000 & rs2[2,1];                                                                               // SEXT.B SEXT.H
        dosra = ( function7[1,6] == 6b010000 );                                                                                 // SRA SRAI
    }
}

unit alu(
    input   uint1   size32,
    input   uint5   opCode,
    input   uint3   function3,
    input   uint7   function7,
    input   uint5   rs1,
    input   uint5   rs2,
    input   int64   sourceReg1,
    input   int64   sourceReg2,
    input   int64   immediateValue,
    input   uint1   LT,                                                                                                         // SIGNED COMPARE sourceReg1 < operand2
    input   uint1   LTU,                                                                                                        // UNSIGNED COMPARE sourceReg1 < operand2
    output  int64   result
) <reginputs> {
    uint6   shiftcount <:: opCode[3,1] ? ( size32 ? sourceReg2[0,5] : sourceReg2[0,6] ) : { function7[0,1], rs2 };
    uint64  operand2 <:: opCode[3,1] ? sourceReg2 : immediateValue;

    // DECODE THE ALU OPERATION
    aludecode AD( size32 <: size32, regreg <: opCode[3,1], function7 <: function7, function3 <: function3, rs2 <: rs2 );

    aluaddsub ADDSUB( size32 <: size32, function3 <: function3[1,2], dosub <: AD.doalt, doadduw <: AD.doadduw, sourceReg1 <: sourceReg1, operand2 <: operand2 );
    alubits BITS( sourceReg1 <: sourceReg1, shiftcount <: shiftcount );
    alubrev BREV( sourceReg1 <: sourceReg1 );
    alucount COUNT( size32 <: size32, counttype <: rs2[0,2], sourceReg1 <: sourceReg1 );
    aluextendsign EXTENDS( halfbyte <: rs2[0,1], sourceReg1 <: sourceReg1 );
    alulogic LOGIC( doinv <: AD.doalt, sourceReg1 <: sourceReg1, operand2 <: operand2 );
    aluminmax MINMAX( function3 <: function3[0,2], sourceReg1 <: sourceReg1, sourceReg2 <: sourceReg2, signedcompare <: LT, unsignedcompare <: LTU );
    alumultiply MULT( size32 <: size32, function3 <: function3[0,2], sourceReg1 <: sourceReg1, sourceReg2 <: sourceReg2 );
    aluorc ORC( sourceReg1 <: sourceReg1 );
    alupack PACK( size32 <: size32, sourceReg1 <: sourceReg1, sourceReg2 <: sourceReg2 );
    alurev REV( sourceReg1 <: sourceReg1 );
    alushift SHIFTS( size32 <: size32, reverse <: function3[2,1], sourceReg1 <: sourceReg1, shiftcount <: shiftcount );

    always_after {
        switch( function3 ) {
            case 3b000: { result = AD.domul ? MULT.mult : ADDSUB.addsub; }
            case 3b001: { result = AD.domul ? MULT.mult : AD.dosignx ? EXTENDS.result : AD.docount ? COUNT.result : AD.dobclrext ? BITS.CLR : AD.dobinv ? BITS.INV : AD.dobset ? BITS.SET : AD.dorotate ? SHIFTS.ROTATE : SHIFTS.SLL; }
            case 3b010: { result = AD.domul ? MULT.mult : AD.doshxadd ? ADDSUB.addsub : LT; }
            case 3b011: { result = AD.domul ? MULT.mult : opCode[3,1] ? ( ~|rs1 ) ? ( |operand2 ) : LTU : ( operand2 == 1 ) ? ( ~|sourceReg1 ) : LTU; }
            case 3b100: { result = AD.dominmax ? MINMAX.result : AD.doshxadd ? ADDSUB.addsub : AD.dopack ? PACK.pack : LOGIC.XOR; }
            case 3b101: { result = AD.doorc ? ORC.ORC : AD.dorev ? REV.REV8 : AD.dobrev ? BREV.BREV8 : AD.dominmax ? MINMAX.result : AD.dobclrext ? BITS.EXT : AD.dorotate ? SHIFTS.ROTATE : AD.dosra ? SHIFTS.SRA : SHIFTS.SRL; }
            case 3b110: { result = AD.dominmax ? MINMAX.result : AD.doshxadd ? ADDSUB.addsub : LOGIC.OR; }
            case 3b111: { result = AD.dominmax ? MINMAX.result : AD.dopack ? PACK.packh : LOGIC.AND; }
        }
    }
}

unit alu_multicycle(
    input   uint1   size32,
    input   uint1   start,
    output  uint1   busy(0),
    input   uint2   function3,
    input   int64   sourceReg1,
    input   uint32  S1_abs32,
    input   uint64  S1_abs64,
    input   int64   sourceReg2,
    input   uint32  S2_abs32,
    input   uint64  S2_abs64,
    output  int64   result,
    input   uint1   isALUMD,
    input   uint1   isALUCLM
) <reginputs> {
    // M EXTENSION - DIVISION
    aludivision ALUMD(
        size32 <: size32, function3 <: function3,
        sourceReg1 <: sourceReg1, S1_abs32 <: S1_abs32, S1_abs64 <: S1_abs64,
        sourceReg2 <: sourceReg2, S2_abs32 <: S2_abs32, S2_abs64 <: S2_abs64
    );

    // B EXTENSION - CARRYLESS MULTIPLY
    alucarrylessmultiply ALUCLMUL( function3 <: function3, sourceReg1 <: sourceReg1, sourceReg2 <: sourceReg2 );

    ALUMD.start := start & isALUMD; ALUCLMUL.start := start & isALUCLM;
    busy := start | ALUMD.busy | ALUCLMUL.busy;

    algorithm <autorun> {
        while(1) {
            if( start ) { while( ALUMD.busy | ALUCLMUL.busy ) {} }
        }
    }

    always_after {
        if( busy ) { result = isALUMD ? ALUMD.result : ALUCLMUL.result; }
    }
}

// INTEGER DIVISION
unit dointegerdivide(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint6   startingbit,
    input   uint64  dividend,
    input   uint64  divisor,
    output  uint64  quotient,
    output  uint64  remainder
) <reginputs> {
    uint7   bit(127);
    uint7   bitNEXT <:: bit - 1;
    uint64  temporary <:: { remainder[0,63], dividend[bit,1] };
    uint1   bitresult <:: __unsigned(temporary) >= __unsigned(divisor);
    uint64  remainderNEXT <:: __unsigned(temporary) - ( bitresult ? __unsigned(divisor) : 0 );
    uint1   update = uninitialised;

    update := 0; busy := start | ~&bit;

    algorithm <autorun> {
        while(1) {
            if( start ) { bit = startingbit; quotient = 0; remainder = 0; while( ~&bit ) { update = 1; } }
        }
    }
    always_after {
        if( update ) {
            remainder = remainderNEXT;
            quotient[ bit, 1 ] = bitresult;
            bit = bitNEXT;
        }
    }
}
unit aludivision(
    input   uint1   size32,
    input   uint1   start,
    output  uint1   busy(0),
    input   uint2   function3,
    input   uint64  sourceReg1,
    input   uint32  S1_abs32,
    input   uint64  S1_abs64,
    input   uint32  S2_abs32,
    input   uint64  S2_abs64,
    input   uint64  sourceReg2,
    output  uint64  result
) <reginputs> {
    uint64  dividend <:: size32 ? ( function3[0,1] ? sourceReg1[0,32] : S1_abs32 ) :                                            // ABSOLUTE VALUE OF DIVIDEND
                                  ( function3[0,1] ? sourceReg1 : S1_abs64 ) ;
    uint64  divisor <:: size32 ? ( function3[0,1] ? sourceReg2[0,32] : S2_abs32 ) :                                             // ABSOLUTE VALUE OF DIVISOR
                                 ( function3[0,1] ? sourceReg2 : S2_abs64 );
    uint1   notdivzero <:: |( size32 ? sourceReg2[0,32] : sourceReg2 );                                                         // CHECK DIVISOR IS NOT ZERO

    uint1   sign1 <:: sourceReg1[ signbit, 1 ];                                                                                 // SELECT SIGN BIT, 63 or 31
    uint1   sign2 <:: sourceReg2[ signbit, 1 ];                                                                                 // SELECT SIGN BIT, 63 or 31
    uint6   signbit <:: { ~size32, 5b11111 };                                                                                   // POSITION OF SIGN OR THE STARTING BIT FOR DIVISION

    dointegerdivide DODIVIDE( startingbit <: signbit, dividend <: dividend, divisor <: divisor );                               // START DIVISION AT BIT 63 LONG OR 31 INT

    busy := start | DODIVIDE.busy; DODIVIDE.start := start & notdivzero;

    always_after {
        result = notdivzero ? function3[1,1] ? DODIVIDE.remainder :                                                             // RETURN REMAINDER
                              ( ( ~function3[0,1] & ( sign1 ^ sign2 ) ) ? -DODIVIDE.quotient :                                  // RETURN QUOTIENT ( correcting sgn )
                                                                           DODIVIDE.quotient ) :                                // RETURN QUOTIENT ( unsigned or positive )
                              function3[1,1] ? sourceReg1 : 64hffffffffffffffff;                                                // DIVIDE BY ZERO, dividend if remainder, -1 if quotient
    }
}

// ALU FOR CARRYLESS MULTIPLY FROM B-EXTENSION
unit alucarrylessmultiply(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint2   function3,
    input   uint64  sourceReg1,
    input   uint64  sourceReg2,
    output  uint64  result
) <reginputs> {
    uint64  resultNEXT <:: result ^ ( ( function3[1,1] ) ? ( sourceReg1 >> ( stopat - count ) ) : ( sourceReg1 << count ) );
    uint7   startat <:: &function3;
    uint7   stopat <:: ( function3 == 2b10 ) ? 64 : 63;
    uint7   count = uninitialised;
    uint7   countNEXT <:: count + 1;
    uint1   update = uninitialised;

    update := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) { busy = 1; result = 0; count = start; while( count != stopat ) { update = 1; } busy = 0; }
        }
    }

    always_after {
        if( update ) {
            if( sourceReg2[ count, 1 ] ) { result = resultNEXT; }
            count = countNEXT;
        }
    }
}

// INTEGER COMPARISONS
unit integercomparisons(
    input   uint64  sourceReg1,
    input   uint64  operand2,
    output  uint1   LT,
    output  uint1   LTU,
    output  uint1   EQ
) <reginputs> {
    always_after {
        LT = ( __signed( sourceReg1 ) < __signed( operand2 ) );
        LTU = ( __unsigned( sourceReg1 ) < __unsigned( operand2 ) );
        EQ = ( sourceReg1 == operand2 );
    }
}

// ATOMIC A EXTENSION ALU
unit aluA(
    input   uint3   function3,
    input   uint7   function7,
    input   uint64  memoryinput,
    input   uint64  sourceReg2,
    output  uint64  result
) <reginputs> {
    alulogic LOGIC( sourceReg1 <: memoryinput, operand2 <: sourceReg2 );

    always_after {
        uint64  AMOADD = ( function3[1,1] ? memoryinput : memoryinput[0,32] ) + ( function3[1,1] ? sourceReg2 : sourceReg2[0,32] );
        uint64  MINMAX = ( function7[2,1] ^ ( function7[3,1] ? ( __unsigned(memoryinput) < __unsigned(sourceReg2) ) :  ( __signed(memoryinput) < __signed(sourceReg2) ) ) ) ? memoryinput : sourceReg2;

        if( function7[4,1] ) {                                                                                                  // AMOMAX[U] AMOMIN[U]
            result = MINMAX;
        } else {
            switch( function7[0,4] ) {
                default: { result = AMOADD; }                                                                                   // AMOADD
                case 4b0001: { result = sourceReg2; }                                                                           // AMOSWAP
                case 4b0100: { result = LOGIC.XOR; }                                                                            // AMOXOR
                case 4b1000: { result = LOGIC.OR; }                                                                             // AMOOR
                case 4b1100: { result = LOGIC.AND; }                                                                            // AMOAND
            }
        }
    }
}
