// RISC-ICE-V
// inspired by https://github.com/sylefeb/Silice/blob/master/projects/ice-v/ice-v.ice
//
// A simple Risc-V RV64GC processor

// RISC-V - MAIN CPU LOOP
//          ALU FUNCTIONALITY LISTED IN ALU-

unit PAWSCPU(
    input   uint1   clock_CPUdecoder,
    input   uint1   clock_cache,
    output  uint2   accesssize,
    output  uint$addr_width$  address(0),
    output  uint1   cacheselect(0),
    output  uint32  writedata,
    output  uint1   writememory,
    input   uint32  readdata,
    output  uint1   readmemory,
    input   uint1   memorybusy,

    // SMT
    input   uint1   SMTRUNNING,
    input   uint$addr_width$  SMTSTARTPC,

    // MINI DMA CONTROLLER
    input   uint$addr_width$  DMASOURCE,
    input   uint$addr_width$  DMASOURCEADD,
    input   uint$addr_width$  DMADEST,
    input   uint$addr_width$  DMADESTADD,
    input   uint$addr_width$  DMACOUNT,
    input   uint8   DMACYCLES,
    input   uint4   DMAMODE,
    input   uint32  DMASET,
    output! uint1   DMAACTIVE
) <reginputs> {
    // RESET COUNTER
    uint8  resetCounter = 8hff;                     uint8   resetNEXT <:: resetCounter - ~( memorybusy | DMAACTIVE | EXECUTESLOW.busy | ICACHE_0W.CLS | ICACHE_1W.CLS );

    // THREAD SELECTION, INSTRUCTION AND COMPRESSED FLAG, PROGRAM COUNTERS
    uint1   COMMIT = uninitialized;                 uint1   SMT = 0;
    uint32  instruction = uninitialized;            uint1   compressed = uninitialized;
    uint$addr_width$  pc = 0;                       uint$addr_width$  pcSMT = uninitialized;
    uint$addr_width$  PC <:: SMT ? pcSMT : pc;                                                                                      // SELECT PC FOR THIS CYCLE

    // RISC-V 64 BIT CONTROLLER FOR INTEGER OPERATIONS
    uint3   OPERATION <:: { RV64CONTROL.IS_LOAD, RV64CONTROL.IS_FAST, RV64CONTROL.IS_STORE };
    uint64  result <:: RV64CONTROL.IS_FPU ? EXECUTEFPU.result : RV64CONTROL.IS_FAST ? EXECUTEFAST.result : EXECUTESLOW.result;
    uint1   frd <:: RV64CONTROL.IS_FPU ? EXECUTEFPU.frd : RV64CONTROL.writeRegisterF;
    uint1   write <:: COMMIT & RV64CONTROL.writeRegister;
    uint1   COMMIT_SMT = uninitialised;
    control RV64CONTROL <@clock_CPUdecoder> (
        cacheselect <: cacheselect,
        DMAACTIVE <: DMA.DMAACTIVE,
        DMAACCESSSIZE <: DMA.DMAACCESSSIZE,
        SMT <:: SMT,
        COMMIT_SMT <: COMMIT_SMT,
        frd <: frd,
        write <: write,
        result <: result,
        PC <: PC,
        instruction <: instruction,
        compressed <: compressed,
        accesssize :> accesssize
    );

    // RISC-V 64 BIT CONTROLLER FOR SINGLE AND DOUBLE PRECISION FLOATING POINT OPERATIONS
    float_control RV64CONTROLF <@clock_CPUdecoder> (
        SMT <:: SMT,
        COMMIT_SMT <: COMMIT_SMT,
        frd <: frd,
        write <: write,
        result <: result,
        instruction <: instruction
    );

    // EXECUTE SINGLE CYLE INSTRUCTIONS, MOST OF BASE PLUS INTEGER MULTIPLICATION
    cpuexecuteFASTPATH EXECUTEFAST(
        size32 <: RV64CONTROL.IS_ALU32,
        size32extend <: RV64CONTROL.IS_ALU32SIGNX,
        opCode <: RV64CONTROL.opCode,
        function3 <: RV64CONTROL.function3,
        function7 <: RV64CONTROL.function7,
        rs1 <: RV64CONTROL.rs1,
        rs2 <: RV64CONTROL.rs2,
        sourceReg1 <: RV64CONTROL.sourceReg1,
        sourceReg2 <: RV64CONTROL.sourceReg2,
        sourceReg2F <: RV64CONTROLF.sourceReg2F,
        immediateValue <: RV64CONTROL.immediateValue,
        memoryinput <: memoryinput,
        AUIPCLUI <: RV64CONTROL.AUIPCLUI,
        nextPC <: RV64CONTROL.nextPC,
        isLOAD <: RV64CONTROL.IS_LOAD,
        isAUIPCLUI <: RV64CONTROL.IS_AUIPCLUI,
        isJAL <: RV64CONTROL.IS_JAL,
        isFENCE <: RV64CONTROL.IS_FENCE,
        LT <: RV64CONTROL.LT,
        LTU <: RV64CONTROL.LTU
    );

    // EXECUTE MULTICYCLE INSTRUCTIONS, INTEGER DIVIDE, CSR AND ALU-A
    cpuexecuteSLOWPATH EXECUTESLOW(
        size32 <: RV64CONTROL.IS_ALU32,
        SMT <: SMT,
        opCode <: RV64CONTROL.opCode,
        function3 <: RV64CONTROL.function3,
        function7 <: RV64CONTROL.function7,
        rs1 <: RV64CONTROL.rs1, rs2 <: RV64CONTROL.rs2,
        sourceReg1 <: RV64CONTROL.sourceReg1, S1_abs32 <: RV64CONTROL.S1_abs32, S1_abs64 <: RV64CONTROL.S1_abs64,
        sourceReg2 <: RV64CONTROL.sourceReg2, S2_abs32 <: RV64CONTROL.S2_abs32, S2_abs64 <: RV64CONTROL.S2_abs64,
        memoryinput <: memoryinput,
        incCSRinstret <: COMMIT,
        isALUM <: RV64CONTROL.IS_ALUM,
        isALUCLM <: RV64CONTROL.IS_ALUCLM,
        isCSR <: RV64CONTROL.IS_CSR,
        isATOMIC <: RV64CONTROL.IS_ATOMIC,
        FPUnewflags <: EXECUTEFPU.FPUnewflags,
        CSRupdateFPUflags <: EXECUTEFPU.CSRupdateFPUflags
    );

    // EXECUTE FPU
    cpuexecuteFPU EXECUTEFPU(
        opCode <: RV64CONTROL.opCode,
        function3 <: RV64CONTROL.function3,
        function7 <: RV64CONTROL.function7,
        rs2 <: RV64CONTROL.rs2,
        sourceReg1 <: RV64CONTROL.sourceReg1, S1_abs32 <: RV64CONTROL.S1_abs32, S1_abs64 <: RV64CONTROL.S1_abs64,
        sourceReg1F <: RV64CONTROLF.sourceReg1F, sourceReg1Fx <: RV64CONTROLF.sourceReg1Fx, sourceReg1Fxopp <: RV64CONTROLF.sourceReg1Fxopp, typeAF <: RV64CONTROLF.typeAF, typeAopp <: RV64CONTROLF.typeAopp,
        sourceReg2F <: RV64CONTROLF.sourceReg2F, sourceReg2Fx <: RV64CONTROLF.sourceReg2Fx, typeBF <: RV64CONTROLF.typeBF,
        sourceReg3Fx <: RV64CONTROLF.sourceReg3Fx, typeCF <: RV64CONTROLF.typeCF,
        FLT <: RV64CONTROLF.FLT,
        FEQ <: RV64CONTROLF.FEQ,
        isFASTFPU <: RV64CONTROL.IS_FASTFPU,
        FPUflags <: EXECUTESLOW.FPUflags
    );

    // MINI DMA CONTROLLER
    dma DMA(
        DMASOURCE <: DMASOURCE,
        DMASOURCEADD <: DMASOURCEADD,
        DMADEST <: DMADEST,
        DMADESTADD <: DMADESTADD,
        DMACOUNT <: DMACOUNT,
        DMACYCLES <: DMACYCLES,
        DMAMODE <: DMAMODE,
        DMASET <: DMASET,
        DMAACTIVE :> DMAACTIVE,
        readdata <: readdata,
        memorybusy <: memorybusy
    );

    // FETCH UNIT
    fetch FETCH(
        clock_CPUdecoder <: clock_CPUdecoder,
        readdata <: readdata,
        memorybusy <: memorybusy
    );

    // 8, 16, 32, 64 BIT LOAD UNITS
    uint1   MEM64 <:: &RV64CONTROL.function3[0,2];
    uint64  memoryinput <:: MEM64 ? LOAD64.memoryinput : LOAD.memoryinput;
    load LOAD(
        accesssize <: accesssize,
        byteaccess <: RV64CONTROL.loadAddress[0,1],
        dounsigned <: RV64CONTROL.function3[2,1],
        readdata <: readdata,
        memorybusy <: memorybusy
    );
    load64 LOAD64(
        loadAddress <: RV64CONTROL.loadAddress,
        readdata <: readdata,
        memorybusy <: memorybusy
    );

    // 8, 16, 32, 64 BIT STORE UNITS
    store STORE( memorybusy <: memorybusy );
    store64 STORE64( memorybusy <: memorybusy, storeAddress <: RV64CONTROL.storeAddress, storedata <: EXECUTEFAST.memoryoutput );

    // SMALL ON CPU L0 CACHE - 1 per HART - RESET when pc == 0 @ START OF BIOS
    // L0 INSTRUCTION CACHE { tag, instruction, compressed, valid } split into units
    $$for i=0,(L00Iblocks-1) do
        simple_dualport_bram uint$32+L00Ipartaddresswidth$ L00cache_$i$ <@clock_cache,@clock> [$L0Isize$] = uninitialized;
    $$end
    $$for i=0,(L01Iblocks-1) do
        simple_dualport_bram uint$32+L01Ipartaddresswidth$ L01cache_$i$ <@clock_cache,@clock> [$L0Isize$] = uninitialized;
    $$end

    il00cache_read ICACHE_0 <@clock_cache> (
        $$for i=0,(L00Iblocks-1) do
            L0cache_$i$ <:> L00cache_$i$,
        $$end
        CLS <: ICACHE_0W.CLS,
        invalidate <: EXECUTEFAST.fenceACTIVE[0,1],
        address <: pc
    );
    il01cache_read ICACHE_1 <@clock_cache> (
        $$for i=0,(L01Iblocks-1) do
            L0cache_$i$ <:> L01cache_$i$,
        $$end
        CLS <: ICACHE_1W.CLS,
        invalidate <: EXECUTEFAST.fenceACTIVE[0,1],
        address <: pcSMT
    );
    il00cache_write ICACHE_0W(
        $$for i=0,(L00Iblocks-1) do
            L0cache_$i$ <:> L00cache_$i$,
        $$end
        address <: pc, newinstruction <: instruction[2,30], newcompressed <: compressed,
        invalidate <: EXECUTEFAST.fenceACTIVE[0,1]
    );
    il01cache_write ICACHE_1W(
        $$for i=0,(L01Iblocks-1) do
            L0cache_$i$ <:> L01cache_$i$,
        $$end
        address <: pcSMT, newinstruction <: instruction[2,30], newcompressed <: compressed,
        invalidate <: EXECUTEFAST.fenceACTIVE[0,1]
    );

    uint6   memorycontrols <: { LOAD64.busy, STORE64.busy, FETCH.busy, LOAD.busy, STORE.busy, DMAACTIVE };
    uint1   SMT_next <:: ~SMT & SMTRUNNING;
    uint$addr_width$  pc_next <:: SMT ? pc :  RV64CONTROL.newPC;
    uint$addr_width$  pcSMT_next <:: SMT ? RV64CONTROL.newPC : SMTRUNNING ? pcSMT : SMTSTARTPC;
    uint1   START_LOAD = uninitialised;
    uint1   START_STORE = uninitialised;

    // SELECT L0 CACHE, MATCH AND COMPRESSED FLAGS, INSTRUCTION, UPDATE L0 cache flags
    uint1   L0match <:: ( ~SMT & ICACHE_0.tagmatch ) | ( SMT & ICACHE_1.tagmatch );
    uint32  L0instruction <:: { SMT ? ICACHE_1.instruction : ICACHE_0.instruction, 2b11 };
    uint1   L0compressed <:: SMT ? ICACHE_1.compressed : ICACHE_0.compressed;
    uint1   ICACHEUPDATE = uninitialised;
    ICACHE_0W.update := ~SMT & ICACHEUPDATE; ICACHE_1W.update := SMT & ICACHEUPDATE;

    // CONTROLS FOR MEMORY ACCESSES AND UNIT START FLAGS
    FETCH.start := 0; LOAD.start := 0; STORE.start := 0; LOAD64.start := 0; STORE64.start := 0; START_LOAD :=0; START_STORE := 0;
    DMA.start := 0; COMMIT := 0; ICACHEUPDATE := 0;
    EXECUTESLOW.start := 0; EXECUTEFPU.start := 0;

    algorithm <autorun> {
        while( |resetCounter ) { resetCounter = resetNEXT; }                                                                    // WAIT FDR MEMORY AND CPU TO FINISH + DELAY FOR RESET
        ++: cacheselect = 0; FETCH.start = ~L0match;                                                                                // START FETCH FIRST INSTRUCTION

        while(1) {
            // CPU LOOP, CONTINUE UNTIL DMA REQUEST, THEN RESTART AT FETCH
            if( DMAMODE ) {
                DMA.start = 1; while( DMAACTIVE | |DMAMODE ) {} ++:                                                                 // PROCESS MINI-DMA ENGINE REQUESTS
                cacheselect = 0; FETCH.start = ~L0match;                                                                        // START FETCH OF NEXT INSTRUCTION IF NOT IN ICACHE
            } else {
                COMMIT_SMT = SMT;
                if( L0match ) {                                                                                                 // COMPLETE FETCH INSTRUCTION
                    instruction =  L0instruction; compressed = L0compressed;                                                    // FROM CACHE
                } else {
                    if( FETCH.busy ) { while( FETCH.busy ) {} ++: }                                                             // FROM MEMORY
                    instruction = FETCH.instruction; compressed = FETCH.compressed;
                }
                ICACHEUPDATE = 1; cacheselect = 1; ++:                                                                          // SWITCH TO DATA CACHE, UPDATE ICACHE, ALLOW ADDRESS GENERATION, REGISTER FETCH

                START_STORE = ( RV64CONTROL.IS_FAST & RV64CONTROL.IS_STORE );                                                   // START STORE IF FAST
                START_LOAD = RV64CONTROL.IS_LOAD;                                                                               // START LOAD
                EXECUTEFPU.start = RV64CONTROL.IS_FPU;                                                                          // START FPU
                EXECUTESLOW.start = ~RV64CONTROL.IS_FPU & ~|OPERATION;                                                          // START DIVISION / CSR

                switch( OPERATION ) {
                    case 3b000: { while( EXECUTESLOW.busy | EXECUTEFPU.busy ) {} }                                              // DIVISION, CSR, FLOATIUNG POINT
                    case 3b010: {}                                                                                              // FAST PATH - ALL BASE + MULTIPLICATION + B EXTENSION (except CLMUL)
                    case 3b011: { while( STORE64.busy | STORE.busy ) {} }                                                       // INTEGER + FLOAT/DOUBLE STORE
                    case 3b110: { while( LOAD64.busy | LOAD.busy ) {} }                                                         // INTEGER + FLOAT/DOUBLE LOAD
                    default: {                                                                                                  // ATOMIC LOAD - MODIFY - STORE + EMULATION OF LR.W AND SC.W
                        while( LOAD64.busy | LOAD.busy ) {} ++:
                        EXECUTESLOW.start = 1; while( EXECUTESLOW.busy ) {} ++:
                        START_STORE = RV64CONTROL.IS_STORE; while( STORE64.busy | STORE.busy ) {}
                    }
                }
                COMMIT = 1; ++:                                                                                                 // COMMIT REGISTERS< AND UPDATE PC AND SWITCH THREADS IF SMT ENABLED

                if( ~|DMAMODE ) { cacheselect = 0; FETCH.start = ~L0match; }                                                    // START FETCH OF NEXT INSTRUCTION IF NO DMA REQUEST
            }
        }
    }

    always_after {
        { if( START_LOAD ) { LOAD.start = ~MEM64; LOAD64.start = MEM64;} }
        { if( START_STORE ) { STORE.start = ~MEM64; STORE64.start = MEM64; } }

        { writedata = memorycontrols[0,1] ? DMA.writedata : MEM64 ? STORE64.writedata : EXECUTEFAST.memoryoutput; }             // COPY MEMORY WRITE VALUE FROM DMA ENGINE OR STORE UNIT

        {
            if( |memorycontrols ) {                                                                                             // COPY MEMORY ADDRESS FROM MEMORY CONTROL UNITS
                onehot( memorycontrols ) {
                    case 0: { address = DMA.address; }
                    case 1: { address = RV64CONTROL.storeAddress; }
                    case 2: { address = RV64CONTROL.loadAddress; }
                    case 3: { address = PC; }
                    case 4: { address = STORE64.address; }
                    case 5: { address = LOAD64.address; }
                }
            }
        }

        { readmemory = DMA.readmemory | LOAD.readmemory | LOAD64.readmemory | FETCH.readmemory; }                               // COPY MEMORY READ OR WRITE FLAGS
        { writememory = DMA.writememory | STORE.writememory | STORE64.writememory; }

        // UPDATE CPU STATE
        { if( COMMIT ) { pc = pc_next; } }
        { if( COMMIT ) { pcSMT = pcSMT_next; } }
        { if( COMMIT & ~EXECUTEFAST.fenceACTIVE[1,1] ) { SMT = SMT_next; }  }
    }
}

unit cpuexecuteFASTPATH(
    input   uint1   size32,
    input   uint1   size32extend,
    input   uint5   opCode,
    input   uint3   function3,
    input   uint7   function7,
    input   uint5   rs1,
    input   uint5   rs2,
    input   int64   sourceReg1,
    input   int64   sourceReg2,
    input   uint64  sourceReg2F,
    input   int64   immediateValue,
    input   int64   memoryinput,
    input   uint64  AUIPCLUI,
    input   uint$addr_width$  nextPC,
    input   uint1   isLOAD,
    input   uint1   isAUIPCLUI,
    input   uint1   isJAL,
    input   uint1   isFENCE,
    output  int64   memoryoutput,
    output  int64   result,
    input   uint1   LT,
    input   uint1   LTU,
    output  uint2   fenceACTIVE(0)
) <reginputs> {
    // ALU
    alu ALU(
        size32 <: size32, opCode <: opCode, function3 <: function3, function7 <: function7,
        rs1 <: rs1, rs2 <: rs2,
        sourceReg1 <: sourceReg1, sourceReg2 <: sourceReg2,
        immediateValue <: immediateValue,
        LT <: LT, LTU <: LTU
    );

    always_after {
        { memoryoutput = opCode[0,1] ? sourceReg2F : sourceReg2; }                                                              // FLOAT STORE OR STORE
        { result = isAUIPCLUI ? AUIPCLUI :                                                                                      // LUI AUIPC
                   isJAL ? nextPC :                                                                                             // JAL[R]
                   isLOAD ? ( ( opCode == 5b00001 ) & ~&function3[0,2] ) ? { 32hffffffff, memoryinput[0,32] } : memoryinput :   // [FLOAT]LOAD ( NAN BOX 32 BIT FLOAD LOADS )
                   ( size32 & size32extend ) ? { {32{ALU.result[31,1]}}, ALU.result[0,32] } : ALU.result; }                     // INTEGER ALU AND MULTIPLICATION, SIGN EXTEND 32 bit
        { if( isFENCE ) { fenceACTIVE = { |function7[1,2], ~function3[0,1] }; } }                                               // SET FENCE ACTIVE { IO, MEM }
                                                                                                                                // IO STOPS THREAD SWITCHING, MEM RESETS L0CACHE (after load)
    }
}

unit cpuexecuteSLOWPATH(
    input   uint1   size32,
    input   uint1   start,
    output  uint1   busy(0),
    input   uint1   SMT,
    input   uint5   opCode,
    input   uint3   function3,
    input   uint7   function7,
    input   uint5   rs1,
    input   uint5   rs2,
    input   int64   sourceReg1,
    input   uint32  S1_abs32,
    input   uint64  S1_abs64,
    input   int64   sourceReg2,
    input   uint32  S2_abs32,
    input   uint64  S2_abs64,
    input   int64   memoryinput,
    output  int64   memoryoutput,
    output  int64   result,
    input   uint1   incCSRinstret,
    input   uint1   isCSR,
    input   uint1   isATOMIC,
    input   uint1   isALUM,
    input   uint1   isALUCLM,
    output  uint8   FPUflags,
    input   uint5   FPUnewflags,
    input   uint1   CSRupdateFPUflags
) <reginputs> {
    uint4   operation <:: { isALUCLM, isALUM, isATOMIC, isCSR };

    // M EXTENSION - DIVISION
    aludivision ALUMD(
        size32 <: size32, function3 <: function3[0,2],
        sourceReg1 <: sourceReg1, S1_abs32 <: S1_abs32, S1_abs64 <: S1_abs64,
        sourceReg2 <: sourceReg2, S2_abs32 <: S2_abs32, S2_abs64 <: S2_abs64
    );

    // B EXTENSION - CARRYLESS MULTIPLY
    alucarrylessmultiply ALUCLMUL( function3 <: function3[0,2], sourceReg1 <: sourceReg1, sourceReg2 <: sourceReg2 );

    // ATOMIC MEMORY OPERATIONS
    aluA ALUA( function7 <: function7, memoryinput <: memoryinput, sourceReg2 <: sourceReg2 );

    // MANDATORY RISC-V CSR REGISTERS + HARTID == 0 MAIN THREAD == 1 SMT THREAD
    uint12  csrRegister <:: { function7, rs2 };
    CSRblock CSR(
        SMT <: SMT,
        csrRegister <: csrRegister,
        function3 <: function3,
        rs1 <: rs1,
        sourceReg1 <: sourceReg1,
        FPUflags :> FPUflags,
        FPUnewflags <: FPUnewflags,
        updateFPUflags <: CSRupdateFPUflags,
        incCSRinstret <: incCSRinstret
    );

    // START FLAGS
    ALUMD.start := 0; ALUCLMUL.start := 0; CSR.start := 0;

    algorithm <autorun> {
        // PROVIDE WAIT STATE FOR APPROPRIATE OPERATION
        while(1) {
            if( start ) {
                onehot( operation ) {
                    default: { CSR.start = isCSR & |function3; ++: }                                                            // CSR ATOMIC OPERATIONS
                    case 2: { ALUMD.start = 1; while( ALUMD.busy ) {} }                                                         // INTEGER DIVISION
                    case 3: { ALUCLMUL.start = 1; while( ALUCLMUL.busy ) {} }                                                   // CARRYLESS MULTIPLY
                }
                busy = 0;
            }
        }
    }

    // COLLECT THE APPROPRIATE RESULT
    always_after {
        { if( start ) { busy = 1; } }
        {
            if( busy ) {
                onehot( operation ) {
                    case 0: { result = |function3 ? CSR.result : 0; }                                                           // CSR
                    case 1: {
                        if( function7[3,1] ) {
                            result = memoryinput;                                                                               // ATOMIC LOAD - MODIFY - STORE
                        } else {
                            result = function7[2,1] ? 0 : memoryinput;                                                          // LR.W SC.W
                        }
                    }
                    case 2: { result = size32 ? { {32{ALUMD.result[31,1]}}, ALUMD.result[0,32] } : ALUMD.result; }              // INTEGER DIVISION
                    case 3: { result = ALUCLMUL.result; }                                                                       // CARRYLESS MULTIPLY
                }
            }
        }
        {
            if( busy ) {
                if( operation[1,1] ) {
                    if( function7[3,1] ) { memoryoutput = function7[3,1] ? ALUA.result : sourceReg2; }                          // ATOMIC LOAD - MODIFY - STORE OR LR.W SC.W
                }
            }
        }
    }
}

unit cpuexecuteFPU(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint5   opCode,
    input   uint3   function3,
    input   uint7   function7,
    input   uint5   rs2,
    input   int64   sourceReg1,
    input   uint32  S1_abs32,
    input   uint64  S1_abs64,
    input   uint64  sourceReg1F,
    input   uint64  sourceReg1Fx,
    input   uint64  sourceReg1Fxopp,
    input   uint4   typeAF,
    input   uint4   typeAopp,
    input   uint64  sourceReg2F,
    input   uint64  sourceReg2Fx,
    input   uint4   typeBF,
    input   uint64  sourceReg3Fx,
    input   uint4   typeCF,
    input   uint1   FLT,
    input   uint1   FEQ,
    output  uint1   frd,
    output  int64   result,
    input   uint1   isFASTFPU,
    input   uint8   FPUflags,
    output  uint5   FPUnewflags,
    output  uint1   CSRupdateFPUflags
) <reginputs> {
    // Classify the instruction
    uint1   fpuconvert <:: ( opCode == 5b10100 ) & ( ( function7[2,5] == 5b11010 ) | ( function7[2,5] == 5b11000 ) | ( function7[2,5] == 5b01000 ) );
    uint3   converttype <:: {
                                ( function7[2,5] == 5b11000 ),                                                                  // FD2IL
                                ( function7[2,5] == 5b11010 ),                                                                  // IL2FD
                                ( function7[2,5] == 5b01000 )                                                                   // F2D or D2F
                            };
    uint1   fpufast <:: isFASTFPU | fpuconvert;
    uint1   fpucalc <:: ~fpufast;
    uint3   operation <:: { fpucalc, fpuconvert, fpufast & ~fpuconvert };

    uint64  qNAN <:: function7[0,1] ? 64h7FF8000000000000 : function7[1,1] ? 64hffffffffffff7e00 : 64hffffffff7fc00000;         // RETURN qNAN FOR DOUBLE/SINGLE/HALF

    // FLOATING POINT CALCULATIONS
    floatcalc FPUCALC(
        dsh <: function7[0,2],
        FPUflags <: FPUflags,
        opCode <: opCode, function3 <: function3, function7 <: function7[2,5],
        sourceReg1Fx <: sourceReg1Fx, sourceReg2Fx <: sourceReg2Fx, sourceReg3Fx <: sourceReg3Fx,
        typeAF <: typeAF, typeBF <: typeBF, typeCF <: typeCF,
        qNAN <: qNAN
    );

    // FLOATING POINT CONVERSIONS
    intlong2float FPUIL2F( rm <: function3, dounsigned <: rs2[0,1], il <: rs2[1,1], dsh <: function7[0,2], sourceReg1 <: sourceReg1, S1_abs32 <: S1_abs32, S1_abs64 <: S1_abs64 );
    float2intlong FPUF2IL( rm <: function3, dounsigned <: rs2[0,1], il <: rs2[1,1], dsh <: function7[0,2], sourceReg1Fx <: sourceReg1Fx, typeAF <: typeAF );
    changeprecision FPUF_CP( dest <: function7[0,2], source <: rs2[0,2], sourceReg1Fx <: sourceReg1Fxopp, typeAF <: typeAopp );

    uint64  convertresult <:: converttype[2,1] ? FPUF2IL.result : converttype[1,1] ? FPUIL2F.result : FPUF_CP.result;
    uint5   convertflags  <:: FPUflags | ( converttype[2,1] ? FPUF2IL.FPUflags : converttype[1,1] ? FPUIL2F.FPUflags : FPUF_CP.FPUflags );

    // FLOATING POINT FAST OPERATIONS
    fpuSINGLECYCLE FPUFAST(
        dsh <: function7[0,2],
        FPUflags <: FPUflags,
        function3 <: function3[0,2], function7 <: function7[2,5],
        sourceReg1 <: sourceReg1, sourceReg1F <: sourceReg1F, sourceReg2F <: sourceReg2F,
        typeAF <: typeAF, typeBF <: typeBF,
        qNAN <: qNAN,
        FLT <: FLT, FEQ <: FEQ
    );

    // START FLAGS AND UPDATE CSR
    FPUCALC.start := fpucalc & start; CSRupdateFPUflags := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1;
                if( operation[2,1] ) { while( FPUCALC.busy ) {} }                                                               // WAIT STATE FOR CALCULATIONS
                busy = 0;
                CSRupdateFPUflags = 1;
            }
        }
    }

    always_after {
        result = operation[0,1] ? FPUFAST.result : operation[1,1] ? convertresult : FPUCALC.result;                                // COLLECT THE APPROPRIATE RESULT
        frd = fpuconvert ? ( |converttype[0,2] ) : fpucalc ? 1 : FPUFAST.frd;                                                      // WRITE TO F REGISTERS FOR TO FLOAT CONVERSIONS, CALCULATIONS AND SOME SINGLE CYCLE
        FPUnewflags = fpuconvert ? convertflags : fpucalc ? FPUCALC.FPUnewflags : FPUFAST.FPUnewflags;                             // OUTPUT NEW FPU FLAGS
    }
}

// FETCH UNIT, INCLUDING COMPRESSED INSTRUCTION EXPANSION
unit fetch(
    input   uint1   clock_CPUdecoder,
    input   uint1   start,
    output! uint1   busy(0),
    output  uint32  instruction,
    output  uint1   compressed,

    input   uint32  readdata,
    output! uint1   readmemory,
    input!  uint1   memorybusy
) <reginputs> {
    // COMPRESSED INSTRUCTION EXPANDER
    compressed00 COMPRESSED00 <@clock_CPUdecoder> ( i16 <: readdata[0,16] );
    compressed01 COMPRESSED01 <@clock_CPUdecoder> ( i16 <: readdata[0,16] );
    compressed10 COMPRESSED10 <@clock_CPUdecoder> ( i16 <: readdata[0,16] );

    readmemory := start;

    algorithm <autorun> {
        while(1) {
            if( start ) { busy = 1; while( memorybusy ) {} busy = 0; }
        }
    }

    always_after {
        switch( readdata[0,2] ) {                                                                                               // EXPAND COMPRESSED INSTRUCTION
            case 2b00: { instruction = { COMPRESSED00.i32, 2b11 }; }                                                            // OR KEEP 32 BIT INSTRUCTION
            case 2b01: { instruction = { COMPRESSED01.i32, 2b11 }; }
            case 2b10: { instruction = { COMPRESSED10.i32, 2b11 }; }
            default: { instruction = readdata; }
        }
        compressed = ( ~&readdata[0,2] );                                                                                       // SET COMPRESSED FLAGS
    }
}

// LOAD UNITS - INCLUDING SIGN EXTENSION FOR 8/16 BIT SIGNED LOADS
unit load(
    input   uint1   start,
    output! uint1   busy(0),
    input   uint1   byteaccess,
    input   uint2   accesssize,
    input   uint1   dounsigned,
    output  int64   memoryinput,

    input   uint32  readdata,
    output! uint1   readmemory,
    input!  uint1   memorybusy
) <reginputs> {
    // SIGN FOR 8, 16, 32 BIT LOADS
    uint1   sign <:: ~dounsigned & ( accesssize[1,1] ? readdata[31,1] : accesssize[0,1] ? readdata[15,1] : readdata[ { byteaccess, 3b111 }, 1 ] );
    readmemory := start;

    algorithm <autorun> {
        while(1) {
            if( start ) { busy = 1; while( memorybusy ) {} ++: busy = 0; }
        }
    }

    always_after {
        memoryinput = accesssize[1,1] ? { {32{sign}}, readdata } :                                                              // 32 BIT
                      accesssize[0,1] ? { {48{sign}}, readdata[0,16] } :                                                        // 16 BIT
                                        { {56{sign}}, readdata[ { byteaccess, 3b000 }, 8 ] };                                   // 8 BIT
    }
}
unit load64(
    input   uint1   start,
    output! uint1   busy(0),
    output  int64   memoryinput,
    input   uint$addr_width$ loadAddress,
    output! uint$addr_width$ address,
    input   uint32  readdata,
    output! uint1   readmemory,
    input!  uint1   memorybusy
) <reginputs> {
    uint$addr_width$ plus4 <:: loadAddress + 4;
    readmemory := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1;
                address = loadAddress; readmemory = 1; while( memorybusy ) {} ++: memoryinput[0,32] = readdata;
                address = plus4; readmemory = 1; while( memorybusy ) {} ++: memoryinput[32,32]= readdata;
                busy = 0;
            }
        }
    }
}

// STORE UNITS
unit store(
    input   uint1   start,
    output! uint1   busy(0),
    output! uint1   writememory,
    input!  uint1   memorybusy
) <reginputs> {
    writememory := start;

    algorithm <autorun> {
        while(1) {
            if( start ) { busy = 1; while( memorybusy ) {} busy = 0; }
        }
    }
}
unit store64(
    input   uint1   start,
    input   uint64  storedata,
    output! uint32  writedata,
    input   uint$addr_width$ storeAddress,
    output! uint$addr_width$ address,
    output! uint1   busy(0),
    output! uint1   writememory,
    input!  uint1   memorybusy
) <reginputs> {
    uint$addr_width$ plus4 <:: storeAddress + 4;
    writememory := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1;
                address = storeAddress; writedata = storedata[0,32]; writememory = 1; while( memorybusy ) {}
                address = plus4; writedata = storedata[32,32]; writememory = 1; while( memorybusy ) {}
                busy = 0;
            }
        }
    }
}

// MINI DMA CONTROLLER
// MODE 0   INACTIVE
//      1   multi-src to single-dest PIXEL BLOCK 8 bit + SDCARD WRITE
//      2   SPECIAL PIXEL BLOCK RGB
//      3   multi-src to multi-dest MEMCPY
//      4   single-src to multi-dest MEMSET + SDCARD READ
//      5   single-src to single-dest SET TILE/CBLITTER to single value
//      6   increase src and dest by additions
//      7   32/16bit to 4/2 pixels for PIXEL BLOCK special mode
//      8   MEMCPY RECTANGLE IS 32/16 BIT CAPABLE
//      9   MEMSET RECTANGLE IS 32/16 BIT CAPABLE
unit dma_flags(
    input   uint$addr_width$  DMASOURCE,
    input   uint$addr_width$  DMASOURCEADD,
    input   uint$addr_width$  DMADEST,
    input   uint$addr_width$  DMADESTADD,
    input   uint$addr_width$  DMACOUNT,
    output  uint1   srcSET,
    output  uint1   src16bit,
    output  uint1   SD16,
    output  uint1   SSD16,
    output  uint1   SD32,
    output  uint1   SSD32,
    output  uint1   ADD16,
    output  uint1   ADD32,
    output  uint1   multi16,
    output  uint1   multi32
) <reginputs> {
    uint1   srcBRAM <:: ~DMASOURCE[26,1] & ~DMASOURCE[25,1] & ~DMASOURCE[15,1];                                                 // SOURCE IS BRAM
    uint1   destBRAM <:: ~DMADEST[26,1] & ~DMADEST[25,1] & ~DMADEST[15,1];                                                      // DEST IS BRAM
    uint1   dest16bit <:: ( DMADEST[26,1] | DMADEST[25,1] | destBRAM ) & ~DMADEST[0,1];                                         // DESTINATION IS 16 BIT CAPABLE

    srcSET := ( DMASOURCE == $addr_width$hfe0e );                                                                               // SOURCE IS THE SET VALUE REGISTER, NO LOADING REQUIRED
    src16bit := ( srcSET | DMASOURCE[26,1] | DMASOURCE[25,1] | srcBRAM ) & ~DMASOURCE[0,1];                                     // SOURCE IS 16 BIT CAPABLE

    SD16 := src16bit & dest16bit & ~DMACOUNT[0,1];                                                                              // 16/32 BIT FLAGS FOR SOURCE&DEST + SET&DEST
    SSD16 := srcSET & dest16bit & ~DMACOUNT[0,1];
    SD32 := src16bit & dest16bit & ~|DMACOUNT[0,2];
    SSD32 := srcSET & dest16bit & ~|DMACOUNT[0,2];

    ADD16 := ~DMASOURCEADD[0,1] & ~DMADESTADD[0,1];                                                                             // 16/32 BIT FLAGS FOR SOURCE&DEST ADD
    ADD32 := ~|DMASOURCEADD[0,2] & ~|DMADESTADD[0,2];

    multi16 := ( DMADEST == 27hd642 );                                                                                          // MULTI-SRC TO SINGLE-DEST 16BIT FOR BLITTER TILE WRITER
    multi32 := ( DMADEST == 27hd680 ) | ( DMADEST == 27hd684 ) |                                                                // MULTI-SRC TO SINGLE-DEST 32BIT FOR PIXELBLOCK ARGB RGBA
                    ( DMADEST == 27hd688 ) | ( DMADEST == 27hd68c );
}
unit dma_src_add(
    input   uint$addr_width$ dmasrc,
    input   uint$addr_width$ DMASOURCEADD,
    input   uint1   DMA16BIT,
    input   uint1   DMA32BIT,
    input   uint3   PBmax,
    output  uint$addr_width$  NEXT,
    output  uint$addr_width$  ADD,
    output  uint$addr_width$  PB
) <reginputs> {
    NEXT := dmasrc + ( DMA32BIT ? 4 : DMA16BIT ? 2 : 1 );                                                                       // NEXT SOURCE ADDRESS FOR 32/16/8 BITS
    ADD := dmasrc + DMASOURCEADD;                                                                                               // NEXT DESTINATION ADDRESS IF STEPPING
    PB := dmasrc + PBmax;                                                                                                       // NEXT SOURCE ADDRESS FOR PIXELBLOCK TRANSFERS
}
unit dma_dest_add(
    input   uint$addr_width$ dmadest,
    input   uint$addr_width$ DMADESTADD,
    input   uint1   DMA16BIT,
    input   uint1   DMA32BIT,
    input   uint3   PBmax,
    output  uint$addr_width$  NEXT,
    output  uint$addr_width$  ADD,
    output  uint$addr_width$  PB
) <reginputs> {
    NEXT := dmadest + ( DMA32BIT ? 4 : DMA16BIT ? 2 : 1 );                                                                      // NEXT DESTINATION ADDRESS FOR 32/16/8 BITS
    ADD := dmadest + DMADESTADD;                                                                                                // NEXT DESTINATION ADDRESS IF STEPPING
    PB := &dmadest[1,2] ? 27hd672: dmadest + 2;                                                                                 // DETECTS BLUE PIXEL WRITTEN, MOVES BACK TO RED
}
unit dma_pb_add(
    input   uint3   PBcount,
    input   uint3   PBmax,
    output  uint3   NEXT
) <reginputs> {
    NEXT := PBcount + 1;
}
unit dma(
    input   uint$addr_width$  DMASOURCE,
    input   uint$addr_width$  DMASOURCEADD,
    input   uint$addr_width$  DMADEST,
    input   uint$addr_width$  DMADESTADD,
    input   uint$addr_width$  DMACOUNT,
    input   uint8   DMACYCLES,
    input   uint4   DMAMODE,
    input   uint32  DMASET,
    output  uint2   DMAACCESSSIZE,
    output! uint1   DMAACTIVE(0),

    input   uint1   start,
    output! uint$addr_width$  address,
    output! uint32  writedata,
    output! uint1   writememory,
    output! uint1   readmemory,
    input!  uint32  readdata,
    input!  uint1   memorybusy
) <reginputs> {
    uint1   DMA16BIT = uninitialised;               uint1   DMA32BIT = uninitialised;                                               // IS DMA TRANSFER 16/32 BIT CAPABLE, DEFAULTS TO 8 BIT

    // COUNTERS FOR PIXEL BLOCK TRANSFERS
    uint1   PB4pixel = uninitialised;               uint3   PBmax <:: PB4pixel ? 4 : 2;                 uint3   PBcount = uninitialised;

    uint4   dmamode = uninitialized;                uint$addr_width$  dmacount = uninitialised;         uint8   dmacycles = uninitialised;
    uint$addr_width$  dmasrc = uninitialised;       uint$addr_width$  dmadest = uninitialised;          uint32  memoryinput = uninitialised;

    uint1   update = uninitialised;

    uint32  writecopy <:: DMA16BIT | DMA32BIT ? readdata :  readdata[ { dmasrc[0,1], 3b000 }, 8 ];

    uint$addr_width$  dmacountNEXT <:: dmacount - ( DMA32BIT ? 4 : DMA16BIT | ( &dmamode[0,3] & PB4pixel ) ? 2 : 1 );

    dma_flags FLAGS(                                                                                                             // GENERATE DMA SIZE FLAGS FOR 8/16/32 BIT ACCESS
        DMASOURCE <: DMASOURCE,
        DMASOURCEADD <: DMASOURCEADD,
        DMADEST <: DMADEST,
        DMADESTADD <: DMADESTADD,
        DMACOUNT <: DMACOUNT,
    );
    dma_src_add SRC(                                                                                                            // GENERATE NEXT SOURCE ADDRESSES
        dmasrc <: dmasrc,
        DMASOURCEADD <: DMASOURCEADD,
        DMA16BIT <: DMA16BIT,
        DMA32BIT <: DMA32BIT,
        PBmax <: PBmax
    );
    dma_dest_add DEST(                                                                                                          // GENERATE NEXT DESTINATION ADDRESSES
        dmadest <: dmadest,
        DMADESTADD <: DMADESTADD,
        DMA16BIT <: DMA16BIT,
        DMA32BIT <: DMA32BIT
    );
    dma_pb_add PB(                                                                                                              // GENERATE NEXT PIXELBLOCK COUNTERS
        PBcount <: PBcount,
        PBmax <: PBmax
    );

    writememory := 0; readmemory := 0; update := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) {
                switch( dmamode[3,1] ) {
                    case 0: {
                        while( |dmacount ) {                                                                                        // SINGLE CYCLE MODE
                            address = dmasrc; readmemory = ~FLAGS.srcSET;
                            switch( { FLAGS.srcSET, &dmamode[0,3] } ) {
                                case 2b00: { while( memorybusy ) {} ++: address = dmadest; writedata = writecopy; writememory = 1; while( memorybusy ) {} }
                                case 2b01: {
                                    while( memorybusy ) {} memoryinput = readdata;
                                    address = dmadest; PBcount = 0;
                                    while( PBcount != PBmax ) {
                                        writedata = memoryinput[ { PBcount, 3b000 }, 8]; writememory = 1; while( memorybusy ) {} PBcount = PB.NEXT;
                                    }
                                }
                                case 2b10: { address = dmadest; writememory = 1; while( memorybusy ) {} }
                                case 2b11: {
                                    address = dmadest; PBcount = 0;
                                    while( PBcount != PBmax ) { writememory = 1; while( memorybusy ) {} PBcount = PB.NEXT; }
                                }
                            }
                            update = 1;
                        }
                    }
                    case 1: {
                        while( |dmacycles ) {
                            while( |dmacount ) {                                                                                    // MULTI-CYCLE MODE
                                address = dmasrc; readmemory = ~FLAGS.srcSET;
                                switch( FLAGS.srcSET ) {
                                    case 0: { while( memorybusy ) {} ++: address = dmadest; writedata = writecopy; writememory = 1; while( memorybusy ) {} }
                                    case 1: { address = dmadest;  writememory = 1; while( memorybusy ) {} }
                                }
                                update = 1;
                            }
                            update = 1;
                        }
                    }
                }
                DMAACTIVE = 0;
            }
        }
    }

    always_after {
        if( start ) {
            DMA16BIT = 0; DMA32BIT = 0; PB4pixel = 0;                                                                           // DETERMINE MAXIMUM DMA TRANSFER SIZE PER CYCLE
            switch( dmamode ) {
                default: {}                                                                                                     // DEFAULT TO 8 BIT MODE
                case 1: {
                    DMA16BIT = FLAGS.multi16;                                                                                   // MULTI-SRC TO SINGLE-DEST 16BIT FOR BLITTER TILE WRITER
                    DMA32BIT = FLAGS.multi32;                                                                                   // MULTI-SRC TO SINGLE-DEST 32BIT FOR PIXELBLOCK ARGB RGBA
                }
                case 3: { DMA32BIT = FLAGS.SD32; DMA16BIT = FLAGS.SD16; }                                                       // MEMCPY IS 32/16 BIT CAPABLE
                case 4: { DMA32BIT = FLAGS.SSD32; DMA16BIT = FLAGS.SSD16; }                                                     // MEMSET IS 32/16 BIT CAPABLE
                case 7: { PB4pixel = ~|DMACOUNT[0,2] & FLAGS.src16bit; }                                                        // PIXELBLOCK MODE CAN OPERATE AT 4 PIXELS, NOT 2
                case 8: { DMA32BIT = FLAGS.SD32 & FLAGS.ADD32; DMA16BIT = FLAGS.SD16 & FLAGS.ADD16; }                           // MEMCPY RECTANGLE IS 32/16 BIT CAPABLE
                case 9: { DMA32BIT = FLAGS.SSD32 & FLAGS.ADD32; DMA16BIT = FLAGS.SSD16 & FLAGS.ADD16; }                         // MEMSET RECTANGLE IS 32/16 BIT CAPABLE
            }
            DMAACCESSSIZE = DMA32BIT | ( &DMAMODE[0,3] & PB4pixel ) ? 2b10 : DMA16BIT | &DMAMODE[0,3] ? 2b01: 2b00;             // SET THE ACCESS SIZE ( SPECIAL PIXEL BLOCK IS 32/16 for 4/2 pixels )
            DMAACTIVE = 1;
        }

        if( update ) {
            if( dmamode[3,1] ) {                                                                                                // UPDATE ADDRESSES IF RECTANGLE MODE
                if( |dmacount ) {
                    dmadest = DEST.NEXT; if( ~dmamode[0,1] ) { dmasrc = SRC.NEXT; }
                } else {
                    dmadest = DEST.ADD - DMACOUNT; if( ~dmamode[0,1] ) { dmasrc = SRC.ADD - DMACOUNT; }
                }
            } else {
                switch( dmamode[0,3] ) {                                                                                        // UPDATE ADDRESS IF NOT RECTANGLE MODE
                    default: {}
                    case 1: { dmasrc = SRC.NEXT; }
                    case 2: { dmasrc = SRC.NEXT; dmadest = DEST.PB; }
                    case 3: { dmasrc = SRC.NEXT; dmadest = DEST.NEXT; }
                    case 4: { dmadest = DEST.NEXT; }
                    case 6: { dmasrc = SRC.ADD; dmadest = DEST.ADD; }
                    case 7: { dmasrc = SRC.PB; }
                }
            }
            dmacycles = dmacycles - ~|dmacount;                                                                                 // UPDATE CYCLES WHEN COUNT == 0
            dmacount = |dmacount ? dmacountNEXT : dmamode[3,1] ? DMACOUNT : 0;                                                  // UPDATE COUNT I` != 0, reset if multi-cycle mode
        }

        if( ~DMAACTIVE ) {
            dmasrc = DMASOURCE; dmadest = DMADEST; dmacount = DMACOUNT; dmacycles = DMACYCLES;                                  // IF DMA NOT ACTIVE SET VALUES TO I/O REGISTERS
            dmamode = DMAMODE; writedata = DMASET;
        }
    }
}
