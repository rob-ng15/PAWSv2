// RISC-ICE-V
// inspired by https://github.com/sylefeb/Silice/blob/master/projects/ice-v/ice-v.ice
//
// A simple Risc-V RV64GC processor

// RISC-V - MAIN CPU LOOP
//          ALU FUNCTIONALITY LISTED IN ALU-

unit PAWSCPU(
    input   uint1   clock_CPUdecoder,
    input   uint1   clock_cache,
    output  uint2   accesssize,
    output  uint$addr_width$  address(0),
    output  uint1   cacheselect(0),
    output  uint32  writedata,
    output  uint1   writememory,
    input   uint32  readdata,
    output  uint1   readmemory,
    input   uint1   memorybusy,

    // SMT
    input   uint1   SMTRUNNING,
    input   uint$addr_width$  SMTSTARTPC,

    // MINI DMA CONTROLLER
    input   uint$addr_width$  DMASOURCE,
    input   uint$addr_width$  DMASOURCEADD,
    input   uint$addr_width$  DMADEST,
    input   uint$addr_width$  DMADESTADD,
    input   uint$addr_width$  DMACOUNT,
    input   uint8   DMACYCLES,
    input   uint4   DMAMODE,
    input   uint32  DMASET,
    output! uint1   DMAACTIVE
) <reginputs> {
    uint1   COMMIT = uninitialized;                 uint1   COMMIT_SMT = uninitialised;                                         // COMMIT RESULT TO REGISTERS FLAG AND TO WHICH THREAD
    uint1   SMT = 0;                                                                                                            // SMT FLAG
    uint32  instruction = uninitialized;            uint1   compressed = uninitialized;                                         // CURRENT INSTRUCTION AND COMPRESSED FLAG
    uint$addr_width$  pc = 0;                       uint$addr_width$  pcSMT = uninitialized;                                    // PROGRAMS COUNTERS FOR MAIN AND SMT THREADS
    uint$addr_width$  PC <:: SMT ? pcSMT : pc;                                                                                  // SELECT PROGRAM COUNTER FOR THIS CYCLE

    uint8   memorycontrols <:: { LOADMA.busy, STOREMA.busy, LOAD64.busy, STORE64.busy,                                          // MEMORY UCONTROL UNITS BUSY FLAGS
                                 FETCH.busy, LOAD.busy, STORE.busy, DMAACTIVE };
    uint64  memoryinput <:: RV64CONTROL.IS_MA ? LOADMA.memoryinput :                                                            // DETERMINE MEMORY INPUT - FROM MISALIGNED LOAD
                            RV64CONTROL.IS_MEM64 ? LOAD64.memoryinput :                                                         //                          FROM 64 BIT LOAD
                            LOAD.memoryinput;                                                                                   //                          FROM STANDARD LOAD
    uint64  memoryoutput <:: RV64CONTROL.IS_FAST ? EXECUTEFAST.memoryoutput : EXECUTESLOW.memoryoutput;                         // DETERMINE MEMORY OUTPUT FROM NORMAL [F]STORE OR ATOMIC OPERATIONS
    uint1   START_LOAD = uninitialised;                                                                                         // START LOAD FROM MEMORY FLAG
    uint1   START_STORE = uninitialised;                                                                                        // START STORE TO MEMORY FLAG

    uint64  result <:: RV64CONTROL.IS_FPU ? EXECUTEFPU.result : RV64CONTROL.IS_FAST ? EXECUTEFAST.result : EXECUTESLOW.result;  // DETERMINE PRESENT INSTRUCTION RESULT
    uint1   frd <:: RV64CONTROL.IS_FPU ? EXECUTEFPU.frd : RV64CONTROL.writeRegisterF;                                           // DETERMINE PRESENT INSTRUCTION RESULT TYPE (FLOAT/INTEGER)
    uint1   write <:: COMMIT & RV64CONTROL.writeRegister;                                                                       // WRITE TO REGISTERS FLAG
    control RV64CONTROL <@clock_CPUdecoder> (
        cacheselect <: cacheselect,
        DMAACTIVE <: DMA.DMAACTIVE,
        DMAACCESSSIZE <: DMA.DMAACCESSSIZE,
        SMT <:: SMT,
        COMMIT_SMT <: COMMIT_SMT,
        frd <: frd,
        write <: write,
        result <: result,
        PC <: PC,
        instruction <: instruction,
        compressed <: compressed,
        accesssize :> accesssize
    );

    // RISC-V 64 BIT CONTROLLER FOR SINGLE AND DOUBLE PRECISION FLOATING POINT OPERATIONS
    float_control RV64CONTROLF <@clock_CPUdecoder> (
        SMT <:: SMT,
        COMMIT_SMT <: COMMIT_SMT,
        frd <: frd,
        write <: write,
        result <: result,
        instruction <: instruction
    );

    // EXECUTE SINGLE CYLE INSTRUCTIONS, MOST OF BASE PLUS INTEGER MULTIPLICATION
    cpuexecuteFASTPATH EXECUTEFAST(
        size32 <: RV64CONTROL.IS_ALU32,
        size32extend <: RV64CONTROL.IS_ALU32SIGNX,
        opCode <: RV64CONTROL.opCode,
        function3 <: RV64CONTROL.function3,
        function7 <: RV64CONTROL.function7,
        rs1 <: RV64CONTROL.rs1,
        rs2 <: RV64CONTROL.rs2,
        sourceReg1 <: RV64CONTROL.sourceReg1,
        sourceReg2 <: RV64CONTROL.sourceReg2,
        sourceReg2F <: RV64CONTROLF.sourceReg2F,
        immediateValue <: RV64CONTROL.immediateValue,
        memoryinput <: memoryinput,
        AUIPCLUI <: RV64CONTROL.AUIPCLUI,
        nextPC <: RV64CONTROL.nextPC,
        isLOAD <: RV64CONTROL.IS_LOAD,
        isAUIPCLUI <: RV64CONTROL.IS_AUIPCLUI,
        isJAL <: RV64CONTROL.IS_JAL,
        isFENCE <: RV64CONTROL.IS_FENCE,
        LT <: RV64CONTROL.LT,
        LTU <: RV64CONTROL.LTU
    );

    // EXECUTE MULTICYCLE INSTRUCTIONS, INTEGER DIVIDE, CSR AND ALU-A
    cpuexecuteSLOWPATH EXECUTESLOW(
        size32 <: RV64CONTROL.IS_ALU32,
        size32extend <: RV64CONTROL.IS_ALU32SIGNX,
        SMT <: SMT,
        function3 <: RV64CONTROL.function3,
        function7 <: RV64CONTROL.function7,
        rs1 <: RV64CONTROL.rs1, rs2 <: RV64CONTROL.rs2,
        sourceReg1 <: RV64CONTROL.sourceReg1, S1_abs32 <: RV64CONTROL.S1_abs32, S1_abs64 <: RV64CONTROL.S1_abs64,
        sourceReg2 <: RV64CONTROL.sourceReg2, S2_abs32 <: RV64CONTROL.S2_abs32, S2_abs64 <: RV64CONTROL.S2_abs64,
        memoryinput <: memoryinput,
        incCSRinstret <: COMMIT,
        isALU <: RV64CONTROL.IS_ALU,
        isCSR <: RV64CONTROL.IS_CSR,
        isATOMIC <: RV64CONTROL.IS_ATOMIC,
        FPUnewflags <: EXECUTEFPU.FPUnewflags,
        CSRupdateFPUflags <: EXECUTEFPU.CSRupdateFPUflags
    );

    // EXECUTE FPU
    cpuexecuteFPU EXECUTEFPU(
        opCode <: RV64CONTROL.opCode,
        function3 <: RV64CONTROL.function3,
        function7 <: RV64CONTROL.function7,
        rs2 <: RV64CONTROL.rs2,
        sourceReg1 <: RV64CONTROL.sourceReg1, S1_abs32 <: RV64CONTROL.S1_abs32, S1_abs64 <: RV64CONTROL.S1_abs64,
        sourceReg1F <: RV64CONTROLF.sourceReg1F, sourceReg1Fx <: RV64CONTROLF.sourceReg1Fx, sourceReg1Fxopp <: RV64CONTROLF.sourceReg1Fxopp, typeAF <: RV64CONTROLF.typeAF, typeAopp <: RV64CONTROLF.typeAopp,
        sourceReg2F <: RV64CONTROLF.sourceReg2F, sourceReg2Fx <: RV64CONTROLF.sourceReg2Fx, typeBF <: RV64CONTROLF.typeBF,
        sourceReg3Fx <: RV64CONTROLF.sourceReg3Fx, typeCF <: RV64CONTROLF.typeCF,
        FLT <: RV64CONTROLF.FLT,
        FEQ <: RV64CONTROLF.FEQ,
        isFASTFPU <: RV64CONTROL.IS_FASTFPU,
        FPUflags <: EXECUTESLOW.FPUflags
    );

    // MINI DMA CONTROLLER
    dma DMA(
        DMASOURCE <: DMASOURCE,
        DMASOURCEADD <: DMASOURCEADD,
        DMADEST <: DMADEST,
        DMADESTADD <: DMADESTADD,
        DMACOUNT <: DMACOUNT,
        DMACYCLES <: DMACYCLES,
        DMAMODE <: DMAMODE,
        DMASET <: DMASET,
        DMAACTIVE :> DMAACTIVE,
        readdata <: readdata,
        memorybusy <: memorybusy
    );

    // FETCH INSTRUCTION UNIT
    fetch FETCH( clock_CPUdecoder <: clock_CPUdecoder, readdata <: readdata, memorybusy <: memorybusy );

    // 8, 16, 32, 64 BIT LOAD UNITS INCLUDING 16, 32, 64 BIT MISALIGNED LOAD
    load LOAD(
        accesssize <: RV64CONTROL.accesssize,
        byteaccess <: RV64CONTROL.loadAddress[0,1],
        dounsigned <: RV64CONTROL.function3[2,1],
        readdata <: readdata,
        memorybusy <: memorybusy
    );
    load64 LOAD64(
        loadAddress <: RV64CONTROL.loadAddress,
        readdata <: readdata,
        memorybusy <: memorybusy
    );
    load_misaligned LOADMA(
        accesssize <: RV64CONTROL.accesssize,
        dounsigned <: RV64CONTROL.function3[2,1],
        loadAddress <: RV64CONTROL.loadAddress,
        readdata <: readdata,
        memorybusy <: memorybusy
    );

    // 8, 16, 32, 64 BIT STORE UNITS INCLUDING 16, 32, 64 BIT MISALIGNED STORE
    store STORE( memorybusy <: memorybusy );
    store64 STORE64( memorybusy <: memorybusy, storeAddress <: RV64CONTROL.storeAddress, storedata <: memoryoutput );
    store_misaligned STOREMA( accesssize <: RV64CONTROL.accesssize, memorybusy <: memorybusy, storeAddress <: RV64CONTROL.storeAddress, storedata <: memoryoutput );

    // SMALL ON CPU L0 CACHE - 1 per HART - RESET WHEN FENCE MEM IS ACTIVATED
    simple_dualport_bram uint32 L00cache <@clock_cache,@clock> [$L00Iblocks$] = uninitialized;
    simple_dualport_bram uint$L00Ipartaddresswidth$ L00tags <@clock_cache,@clock> [$L00Iblocks$] = uninitialized;
    simple_dualport_bram uint32 L01cache <@clock_cache,@clock> [$L01Iblocks$] = uninitialized;
    simple_dualport_bram uint$L01Ipartaddresswidth$ L01tags <@clock_cache,@clock> [$L01Iblocks$] = uninitialized;

    il00cache_read ICACHE_0 <@clock_cache> (
        L0cache <:> L00cache,
        L0tags <:> L00tags,
        CLS <: ICACHE_0W.CLS,
        invalidate <: EXECUTEFAST.fenceACTIVE[0,1],
        address <: pc
    );
    il01cache_read ICACHE_1 <@clock_cache> (
        L0cache <:> L01cache,
        L0tags <:> L01tags,
        CLS <: ICACHE_1W.CLS,
        invalidate <: EXECUTEFAST.fenceACTIVE[0,1],
        address <: pcSMT
    );
    il00cache_write ICACHE_0W(
        L0cache <:> L00cache,
        address <: pc, newinstruction <: instruction[2,30], newcompressed <: compressed,
        invalidate <: EXECUTEFAST.fenceACTIVE[0,1]
    );
    il01cache_write ICACHE_1W(
        L0cache <:> L01cache,
        address <: pcSMT, newinstruction <: instruction[2,30], newcompressed <: compressed,
        invalidate <: EXECUTEFAST.fenceACTIVE[0,1]
    );
    il00tags_write ITAGS_0W(
        L0tags <:> L00tags,
        address <: pc
    );
    il01tags_write ITAGS_1W(
        L0tags <:> L01tags,
        address <: pcSMT
    );

    uint1   ICACHEUPDATE = uninitialised;                                                                                       // CPU L0 CACHE UPDATE FLAG
    ICACHE_0W.update := ~SMT & ICACHEUPDATE; ICACHE_1W.update := SMT & ICACHEUPDATE;                                            // UPDATE CPU l0 CACHE FOR MAIN/SMT THREAD FLAG
    ITAGS_0W.update := ~SMT & ICACHEUPDATE; ITAGS_1W.update := SMT & ICACHEUPDATE;                                              // UPDATE CPU l0 TAGS FOR MAIN/SMT THREAD FLAG

    FETCH.start := 0;                                                                                                           // FETCH INSTRUCTION FLAG
    START_LOAD := 0; LOAD.start := 0; LOAD64.start := 0; LOADMA.start := 0;                                                     // LOAD FROM MEMORY FLAGS
    START_STORE := 0; STORE.start := 0; STORE64.start := 0; STOREMA.start := 0;                                                 // STORE TO MEMORY FLAGS
    DMA.start := 0;                                                                                                             // DMA CONTROLLER START FLAG
    EXECUTESLOW.start := 0;                                                                                                     // CPU CSR, ATOMIC, INTEGER DIVIDE START FLAG
    EXECUTEFPU.start := 0;                                                                                                      // CPU FPU START FLAG
    ICACHEUPDATE := 0;                                                                                                          // UPDATE CPU L0 CACHE FLAG
    COMMIT := 0;                                                                                                                // COMMIT TO REGISTERS FLAG

    writedata := memorycontrols[0,1] ? DMA.writedata :                                                                          // COPY MEMORY WRITE VALUE FROM     DMA ENGINE
                                       RV64CONTROL.IS_MA ? STOREMA.writedata :                                                  //                                  MISALIGNED STORE
                                       RV64CONTROL.IS_MEM64 ? STORE64.writedata : memoryoutput;                                 //                                  64 OR 8/16/32 BIT STORE UNITS
    readmemory := DMA.readmemory | LOAD.readmemory | LOAD64.readmemory | LOADMA.readmemory | FETCH.readmemory;                  // COPY MEMORY READ FLAGS
    writememory := DMA.writememory | STORE.writememory | STORE64.writememory | STOREMA.writememory;                             // COPY MEMORY WRITE FLAGS

    algorithm <autorun> {
        uint8   resetCounter = 8hff;                                                                                            // RESET COUNTER
        uint8   resetNEXT <:: resetCounter - ~( memorybusy | DMAACTIVE | EXECUTESLOW.busy | ICACHE_0W.CLS | ICACHE_1W.CLS |     // -1 WHEN ALL UNITS ARE NO LONGER BUSY
                                                LOADMA.busy | STOREMA.busy | LOAD64.busy | STORE64.busy |
                                                FETCH.busy | LOAD.busy | STORE.busy );

        uint3   OPERATION <:: { RV64CONTROL.IS_LOAD, RV64CONTROL.IS_FAST, RV64CONTROL.IS_STORE };                               // PRESENT INSTRUCTION ROUTE FLAG

        uint1   L0match <:: ( ~SMT & ICACHE_0.tagmatch ) | ( SMT & ICACHE_1.tagmatch );                                         // CPU L0 CACHE MATCH FOR PC
        uint32  L0instruction <:: { SMT ? ICACHE_1.instruction : ICACHE_0.instruction, 2b11 };                                  // CPU L0 CACHED INSTRUCTION
        uint1   L0compressed <:: SMT ? ICACHE_1.compressed : ICACHE_0.compressed;                                               // CPU l0 CACHED INSTRUCTION IS COMPRESSED FLAG

        while( |resetCounter ) { resetCounter = resetNEXT; }                                                                    // WAIT FDR MEMORY AND CPU TO FINISH + DELAY FOR RESET

        ++: cacheselect = 0; FETCH.start = ~L0match;                                                                            // START FETCH FIRST INSTRUCTION
        while(1) {                                                                                                              // CPU LOOP
            if( DMAMODE ) {
                DMA.start = 1; while( DMAACTIVE | |DMAMODE ) {} ++:                                                             // PROCESS MINI-DMA ENGINE REQUESTS
                cacheselect = 0; FETCH.start = ~L0match;                                                                        // START FETCH OF NEXT INSTRUCTION IF NOT IN ICACHE
            } else {
                COMMIT_SMT = SMT;                                                                                               // LATCH THREAD MAIN/SMT
                if( L0match ) {                                                                                                 // COMPLETE FETCH INSTRUCTION
                    instruction =  L0instruction; compressed = L0compressed;                                                    // FROM CACHE
                } else {
                    if( FETCH.busy ) { while( FETCH.busy ) {} ++: }                                                             // FROM MEMORY
                    instruction = FETCH.instruction; compressed = FETCH.compressed;
                }
                cacheselect = 1; ICACHEUPDATE = 1; ++:                                                                          // SWITCH TO DATA CACHE, UPDATE ICACHE, ALLOW ADDRESS GENERATION, REGISTER FETCH

                START_STORE = RV64CONTROL.IS_FAST & RV64CONTROL.IS_STORE;                                                       // START STORE ( ONLY IN FAST MODE TO AVOID ATOMIC )
                START_LOAD = RV64CONTROL.IS_LOAD;                                                                               // START LOAD
                EXECUTEFPU.start = RV64CONTROL.IS_FPU;                                                                          // START FPU
                EXECUTESLOW.start = ( RV64CONTROL.IS_ALU & ~RV64CONTROL.IS_FAST ) |                                             // START DIVISION
                                    ( RV64CONTROL.IS_CSR );                                                                     // START CSR

                switch( OPERATION ) {
                    case 3b000: { while( EXECUTESLOW.busy | EXECUTEFPU.busy ) {} }                                              // DIVISION, CSR, FLOATIUNG POINT
                    case 3b010: {}                                                                                              // FAST PATH - ALL BASE + MULTIPLICATION + B EXTENSION (except CLMUL)
                    case 3b011: { while( STORE64.busy | STORE.busy ) {} }                                                       // INTEGER + FLOAT/DOUBLE STORE
                    case 3b110: { while( LOAD64.busy | LOAD.busy ) {} }                                                         // INTEGER + FLOAT/DOUBLE LOAD
                    default: {                                                                                                  // ATOMIC LOAD - MODIFY - STORE + EMULATION OF LR.W AND SC.W
                        while( LOAD64.busy | LOAD.busy ) {} ++:
                        EXECUTESLOW.start = 1; while( EXECUTESLOW.busy ) {} ++:
                        START_STORE = RV64CONTROL.IS_STORE; while( STORE64.busy | STORE.busy ) {}
                    }
                }
                COMMIT = 1; ++:                                                                                                 // COMMIT REGISTERS AND UPDATE PC AND SWITCH THREADS IF SMT ENABLED

                if( ~|DMAMODE ) { cacheselect = 0; FETCH.start = ~L0match; }                                                    // START FETCH OF NEXT INSTRUCTION IF NO DMA REQUEST
            }
        }
    }

    always_after {
        uint1   SMT_next = ~SMT & SMTRUNNING;                                                                                   // NEXT SMT STATE
        uint$addr_width$  pc_next = SMT ? pc :  RV64CONTROL.newPC;                                                              // NEXT PROGRAM COUNTER FOR MAIN THREAD
        uint$addr_width$  pcSMT_next = SMT ? RV64CONTROL.newPC : SMTRUNNING ? pcSMT : SMTSTARTPC;                               // NEXT PROGRAM COUNTER FOR SMT THREAD

        if( START_LOAD ) { LOADMA.start = RV64CONTROL.IS_MA; LOAD.start = ~RV64CONTROL.IS_MA & ~RV64CONTROL.IS_MEM64; LOAD64.start = ~RV64CONTROL.IS_MA & RV64CONTROL.IS_MEM64; }
        if( START_STORE ) { STOREMA.start = RV64CONTROL.IS_MA; STORE.start = ~RV64CONTROL.IS_MA & ~RV64CONTROL.IS_MEM64; STORE64.start = ~RV64CONTROL.IS_MA & RV64CONTROL.IS_MEM64; }

        if( |memorycontrols ) {                                                                                                 // COPY MEMORY ADDRESS FROM MEMORY CONTROL UNITS
            onehot( memorycontrols ) {
                case 0: { address = DMA.address; }
                case 1: { address = RV64CONTROL.storeAddress; }
                case 2: { address = RV64CONTROL.loadAddress; }
                case 3: { address = PC; }
                case 4: { address = STORE64.address; }
                case 5: { address = LOAD64.address; }
                case 6: { address = STOREMA.address; }
                case 7: { address = LOADMA.address; }
            }
        }

        if( COMMIT ) {                                                                                                          // COMMIT RESULTS OF INSTRUCTION
            pc = pc_next; pcSMT = pcSMT_next;                                                                                   // MOVE TO NEXT INSTRUCTION
            if( ~EXECUTEFAST.fenceACTIVE[1,1] ) { SMT = SMT_next; }                                                             // SWITCH THREADS IF ACTIVE AND NOT FENCED
        }
    }
}

unit cpuexecuteFASTPATH(
    input   uint1   size32,
    input   uint1   size32extend,
    input   uint5   opCode,
    input   uint3   function3,
    input   uint7   function7,
    input   uint5   rs1,
    input   uint5   rs2,
    input   int64   sourceReg1,
    input   int64   sourceReg2,
    input   uint64  sourceReg2F,
    input   int64   immediateValue,
    input   int64   memoryinput,
    input   uint64  AUIPCLUI,
    input   uint$addr_width$  nextPC,
    input   uint1   isLOAD,
    input   uint1   isAUIPCLUI,
    input   uint1   isJAL,
    input   uint1   isFENCE,
    output  int64   memoryoutput,
    output  int64   result,
    input   uint1   LT,
    input   uint1   LTU,
    output  uint2   fenceACTIVE(0)
) <reginputs> {
    alu ALU(                                                                                                                    // SINGLE CYCLE INTEGER OPERATIONS
        size32 <: size32, opCode <: opCode, function3 <: function3, function7 <: function7,
        rs1 <: rs1, rs2 <: rs2,
        sourceReg1 <: sourceReg1, sourceReg2 <: sourceReg2,
        immediateValue <: immediateValue,
        LT <: LT, LTU <: LTU
    );

    always_after {
        memoryoutput = opCode[0,1] ? sourceReg2F : sourceReg2;                                                                  // FLOAT STORE OR STORE
        result = isAUIPCLUI ? AUIPCLUI :                                                                                        // LUI AUIPC
                 isJAL ? nextPC :                                                                                               // JAL[R]
                 isLOAD ? ( ( opCode == 5b00001 ) & ~&function3[0,2] ) ? { 32hffffffff, memoryinput[0,32] } : memoryinput :     // [FLOAT]LOAD ( NAN BOX 32 BIT FLOAD LOADS )
                          ( size32 & size32extend ) ? { {32{ALU.result[31,1]}}, ALU.result[0,32] } : ALU.result;                // INTEGER ALU AND MULTIPLICATION, SIGN EXTEND 32 bit
        if( isFENCE ) { fenceACTIVE = { |function7[1,2], ~function3[0,1] }; }                                                   // SET FENCE ACTIVE { IO, MEM }
                                                                                                                                // IO STOPS THREAD SWITCHING, MEM RESETS L0CACHE (after load)
    }
}

unit cpuexecuteSLOWPATH(
    input   uint1   size32,
    input   uint1   size32extend,
    input   uint1   start,
    output  uint1   busy(0),
    input   uint1   SMT,
    input   uint3   function3,
    input   uint7   function7,
    input   uint5   rs1,
    input   uint5   rs2,
    input   int64   sourceReg1,
    input   uint32  S1_abs32,
    input   uint64  S1_abs64,
    input   int64   sourceReg2,
    input   uint32  S2_abs32,
    input   uint64  S2_abs64,
    input   int64   memoryinput,
    output  int64   memoryoutput,
    output  int64   result,
    input   uint1   incCSRinstret,
    input   uint1   isCSR,
    input   uint1   isATOMIC,
    input   uint1   isALU,
    output  uint8   FPUflags,
    input   uint5   FPUnewflags,
    input   uint1   CSRupdateFPUflags
) <reginputs> {
    uint3   operation <:: { isALU, isATOMIC, isCSR };

    aluA ALUA( function7 <: function7, memoryinput <: memoryinput, sourceReg2 <: sourceReg2 );                                   // ATOMIC MEMORY OPERATIONS

    uint12  csrRegister <:: { function7, rs2 };                                                                                 // EXTRACT CSR REGISTER NUMBER FROM INSTRUCTION
    CSRblock CSR(                                                                                                               // MANDATORY RISC-V CSR REGISTERS + HARTID == 0 MAIN THREAD == 1 SMT THREAD
        SMT <: SMT,
        csrRegister <: csrRegister,
        function3 <: function3,
        rs1 <: rs1,
        sourceReg1 <: sourceReg1,
        FPUflags :> FPUflags,
        FPUnewflags <: FPUnewflags,
        updateFPUflags <: CSRupdateFPUflags,
        incCSRinstret <: incCSRinstret
    );

    aludivision ALUMD(
        size32 <: size32, function3 <: function3,
        sourceReg1 <: sourceReg1, S1_abs32 <: S1_abs32, S1_abs64 <: S1_abs64,
        sourceReg2 <: sourceReg2, S2_abs32 <: S2_abs32, S2_abs64 <: S2_abs64
    );


    CSR.start := start & isCSR & |function3; ALUMD.start := start & isALU;                                                        // START FLAGS

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1;
                onehot( operation ) {                                                                                           // PROVIDE WAIT STATES
                    default: { ++: }                                                                                            //  CSR AND ATOMIC OPERATIONS
                    case 2: { while( ALUMD.busy ) {} }                                                                            //  INTEGER DIVISION AND CARRYLESS MULTIPLY
                }
                busy = 0;
            }
        }
    }

    always_after {
        onehot( operation ) {                                                                                                   // COLLECT RESULT
            case 0: { result = |function3 ? CSR.result : 0; }                                                                   //  CSR
            case 1: {
                if( function7[3,1] ) {
                    result = memoryinput;                                                                                       //  ATOMIC LOAD - MODIFY - STORE
                } else {
                    result = function7[2,1] ? 0 : memoryinput;                                                                  //  LR.W SC.W
                }
                memoryoutput = function7[3,1] ? ALUA.result : sourceReg2;                                                       //  ATOMIC LOAD - MODIFY - STORE OR LR.W SC.W - MEMORUOUTPUT
            }
            case 2: { result = size32  & size32extend ? { {32{ALUMD.result[31,1]}}, ALUMD.result[0,32] } : ALUMD.result; }      //  INTEGER DIVISION AND CARRYLESS MULTIPLY
        }
    }
}

unit cpuexecuteFPU(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint5   opCode,
    input   uint3   function3,
    input   uint7   function7,
    input   uint5   rs2,
    input   int64   sourceReg1,
    input   uint32  S1_abs32,
    input   uint64  S1_abs64,
    input   uint64  sourceReg1F,
    input   uint64  sourceReg1Fx,
    input   uint64  sourceReg1Fxopp,
    input   uint4   typeAF,
    input   uint4   typeAopp,
    input   uint64  sourceReg2F,
    input   uint64  sourceReg2Fx,
    input   uint4   typeBF,
    input   uint64  sourceReg3Fx,
    input   uint4   typeCF,
    input   uint1   FLT,
    input   uint1   FEQ,
    output  uint1   frd,
    output  int64   result,
    input   uint1   isFASTFPU,
    input   uint8   FPUflags,
    output  uint5   FPUnewflags,
    output  uint1   CSRupdateFPUflags
) <reginputs> {
    uint1   fpuconvert <:: ( opCode == 5b10100 ) & ( ( function7[2,5] == 5b11010 ) |                                            // FPU CONVERSION TO/FROM INT OR CHANGE OF PRECISION DETECTION
                           ( function7[2,5] == 5b11000 ) | ( function7[2,5] == 5b01000 ) );
    uint1   fpufast <:: isFASTFPU | fpuconvert;                                                                                 // SINGLE CYCLE OR CONVERSION DETECTION
    uint1   fpucalc <:: ~fpufast;                                                                                               // CALCULATION DETECTION
    uint3   operation <:: { fpucalc, fpuconvert, fpufast & ~fpuconvert };                                                       // PRESENT INSTRUCTION ROUTE

    uint64  qNAN <:: function7[0,1] ? 64h7FF8000000000000 : function7[1,1] ? 64hffffffffffff7e00 : 64hffffffff7fc00000;         // RETURN qNAN FOR DOUBLE/SINGLE/HALF

    fpuSINGLECYCLE FPUFAST(                                                                                                     // FLOATING POINT SINGLE CYCLE OPERATIONS
        dsh <: function7[0,2],
        FPUflags <: FPUflags,
        function3 <: function3[0,2], function7 <: function7[2,5],
        sourceReg1 <: sourceReg1, sourceReg1F <: sourceReg1F, sourceReg2F <: sourceReg2F,
        typeAF <: typeAF, typeBF <: typeBF,
        qNAN <: qNAN,
        FLT <: FLT, FEQ <: FEQ
    );

    floatcalc FPUCALC(                                                                                                          // FLOATING POINT CALCULATIONS CONTROLLER
        dsh <: function7[0,2],
        FPUflags <: FPUflags,
        opCode <: opCode, function3 <: function3, function7 <: function7[2,5],
        sourceReg1Fx <: sourceReg1Fx, sourceReg2Fx <: sourceReg2Fx, sourceReg3Fx <: sourceReg3Fx,
        typeAF <: typeAF, typeBF <: typeBF, typeCF <: typeCF,
        qNAN <: qNAN
    );

    // FLOATING POINT CONVERSIONS
    intlong2float FPUIL2F( rm <: function3, dounsigned <: rs2[0,1], il <: rs2[1,1], dsh <: function7[0,2], sourceReg1 <: sourceReg1, S1_abs32 <: S1_abs32, S1_abs64 <: S1_abs64 );
    float2intlong FPUF2IL( rm <: function3, dounsigned <: rs2[0,1], il <: rs2[1,1], dsh <: function7[0,2], sourceReg1Fx <: sourceReg1Fx, typeAF <: typeAF );
    changeprecision FPUF_CP( dest <: function7[0,2], source <: rs2[0,2], sourceReg1Fx <: sourceReg1Fxopp, typeAF <: typeAopp );

    FPUCALC.start := fpucalc & start; CSRupdateFPUflags := 0;                                                                   // START FLAGS AND UPDATE CSR

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1;
                if( operation[2,1] ) { while( FPUCALC.busy ) {} }                                                               // WAIT STATE FOR CALCULATIONS
                busy = 0;
                CSRupdateFPUflags = 1;
            }
        }
    }

    always_after {
        uint3   converttype = {
                                    ( function7[2,5] == 5b11000 ),                                                              // FD2IL
                                    ( function7[2,5] == 5b11010 ),                                                              // IL2FD
                                    ( function7[2,5] == 5b01000 )                                                               // F2D or D2F
                                };
        uint64  convertresult = converttype[2,1] ? FPUF2IL.result : converttype[1,1] ? FPUIL2F.result : FPUF_CP.result;
        uint5   convertflags = FPUflags | ( converttype[2,1] ? FPUF2IL.FPUflags : converttype[1,1] ? FPUIL2F.FPUflags : FPUF_CP.FPUflags );

        result = operation[0,1] ? FPUFAST.result : operation[1,1] ? convertresult : FPUCALC.result;                             // COLLECT THE APPROPRIATE RESULT
        frd = fpuconvert ? ( |converttype[0,2] ) : fpucalc ? 1 : FPUFAST.frd;                                                   // WRITE TO F REGISTERS FOR TO FLOAT CONVERSIONS, CALCULATIONS AND SOME SINGLE CYCLE
        FPUnewflags = fpuconvert ? convertflags : fpucalc ? FPUCALC.FPUnewflags : FPUFAST.FPUnewflags;                          // OUTPUT NEW FPU FLAGS
    }
}

// FETCH UNIT, INCLUDING COMPRESSED INSTRUCTION EXPANSION
unit fetch(
    input   uint1   clock_CPUdecoder,
    input   uint1   start,
    output! uint1   busy(0),
    output  uint32  instruction,
    output  uint1   compressed,

    input   uint32  readdata,
    output! uint1   readmemory,
    input!  uint1   memorybusy
) <reginputs> {
    // COMPRESSED INSTRUCTION EXPANDER
    compressed00 COMPRESSED00 <@clock_CPUdecoder> ( i16 <: readdata[0,16] );
    compressed01 COMPRESSED01 <@clock_CPUdecoder> ( i16 <: readdata[0,16] );
    compressed10 COMPRESSED10 <@clock_CPUdecoder> ( i16 <: readdata[0,16] );

    readmemory := start;

    algorithm <autorun> {
        while(1) {
            if( start ) { busy = 1; while( memorybusy ) {} busy = 0; }
        }
    }

    always_after {
        switch( readdata[0,2] ) {                                                                                               // EXPAND COMPRESSED INSTRUCTION
            case 2b00: { instruction = { COMPRESSED00.i32, 2b11 }; }                                                            // OR KEEP 32 BIT INSTRUCTION
            case 2b01: { instruction = { COMPRESSED01.i32, 2b11 }; }
            case 2b10: { instruction = { COMPRESSED10.i32, 2b11 }; }
            default: { instruction = readdata; }
        }
        compressed = ( ~&readdata[0,2] );                                                                                       // SET COMPRESSED FLAGS
    }
}

// LOAD UNITS
// ALIGNED LOADS ARE FOR BYTES OR ...x0 ADDRESSES
// MISALGNED LOADS ARE FOR HALF WORDS, WORDS, LONG WORDS OR FLOATS AT ...xxx1 ADDRESSES
unit load(                                                                                                                      // 8, 16, 32 BIT LOADS WITH SIGN EXTENSION ( ALIGNED )
    input   uint1   start,
    output! uint1   busy(0),
    input   uint1   byteaccess,
    input   uint2   accesssize,
    input   uint1   dounsigned,
    output  int64   memoryinput,

    input   uint32  readdata,
    output! uint1   readmemory,
    input!  uint1   memorybusy
) <reginputs> {
    readmemory := start;

    algorithm <autorun> {
        while(1) {
            if( start ) { busy = 1; while( memorybusy ) {} ++: busy = 0; }                                                      // READ FROM MEMORY
        }
    }

    always_after {
        uint1   sign = dounsigned ? 0 :( accesssize[1,1] ? readdata[31,1] :                                                     // EXTRACT SIGN IF REQUIRED FOR 32 BIT
                                         accesssize[0,1] ? readdata[15,1] :                                                     //                              16 BIT
                                                           readdata[ { byteaccess, 3b111 }, 1 ] );                              //                               8 BIT SIGN EXTENDED LOADS

        memoryinput = accesssize[1,1] ? { {32{sign}}, readdata } :                                                              // 32 BIT MEMORY INPUT
                      accesssize[0,1] ? { {48{sign}}, readdata[0,16] } :                                                        // 16 BIT MEMORY INPUT
                                        { {56{sign}}, readdata[ { byteaccess, 3b000 }, 8 ] };                                   //  8 BIT MEMORY INPUT
    }
}
unit load64(                                                                                                                    // 64-BIT LOADS ( ALIGNED )
    input   uint1   start,
    output! uint1   busy(0),
    output  int64   memoryinput,
    input   uint$addr_width$ loadAddress,
    output! uint$addr_width$ address,
    input   uint32  readdata,
    output! uint1   readmemory,
    input!  uint1   memorybusy
) <reginputs> {
    readmemory := 0;

    algorithm <autorun> {
        uint$addr_width$ plus4 <:: loadAddress + 4;

        while(1) {
            if( start ) {
                busy = 1;
                address = loadAddress; readmemory = 1; while( memorybusy ) {} ++: memoryinput[0,32] = readdata;                 // READ FIRST 32 BITS
                address = plus4; readmemory = 1; while( memorybusy ) {} ++: memoryinput[32,32]= readdata;                       // READ SECOND 32 BITS
                busy = 0;
            }
        }
    }
}
unit load_misaligned(                                                                                                           // 16, 32, 64 BITS LOADS FROM ADDRESS ...xxx1 ( mis-aligned byte )
    input   uint1   start,
    output! uint1   busy(0),
    input   uint2   accesssize,
    input   uint1   dounsigned,
    output  int64   memoryinput,
    input   uint$addr_width$ loadAddress,
    output! uint$addr_width$ address,
    input   uint32  readdata,
    output! uint1   readmemory,
    input!  uint1   memorybusy
) <reginputs> {
    uint64  data = uninitialised;
    readmemory := 0;

    algorithm <autorun> {
        uint$addr_width$ plus1 <:: address + 1;
        uint4   maxCOUNT <:: ( 1 << accesssize );
        uint4   count = uninitialised;                  uint4   countNEXT <:: count + 1;

        while(1) {
            if( start ) {
                busy = 1; data = 0; count = 0; address = loadAddress;                                                           // START AT FIRST BYTE, ZERO DATA
                while( count != maxCOUNT ) {                                                                                    // CONTINUE FOR 2, 4, 8 BYTES
                    readmemory = 1; while( memorybusy ) {} ++:                                                                  // READ FROM ADDRESS
                    data[ { count, 3b000 }, 8 ] = readdata[ { address[0,1], 3b000 }, 8 ];                                       // UPDATE BYE IN DATA
                    address = plus1; count = countNEXT;                                                                         // MOVE TO THE NEXT ADDRESS
                }
                busy = 0;
            }
        }
    }

    always_after {
        if( dounsigned ) {
            memoryinput = data;                                                                                                 // UNSIGNED, COPY DATA
        } else {
            switch( accesssize ) {
                default: { memoryinput = data; }                                                                                // 64-bit, COPY DATA
                case 2b01: { memoryinput = { {48{ data[15,1]}}, data[0,16] }; }                                                 // 16-bit, SIGN EXTENDED
                case 2b10: { memoryinput = { {32{ data[31,1]}}, data[0,32] }; }                                                 // 32-bit, SIGN EXTENDED
            }
        }
    }
}

// STORE UNITS
// ALIGNED STORES ARE FOR BYTES OR ...x0 ADDRESSES
// MISALGNED STORES ARE FOR HALF WORDS, WORDS, LONG WORDS OR FLOATS AT ...xxx1 ADDRESSES
unit store(                                                                                                                     // 8, 16, 32 BIT STORES ( ALIGNED )
    input   uint1   start,
    output! uint1   busy(0),
    output! uint1   writememory,
    input!  uint1   memorybusy
) <reginputs> {
    writememory := start;

    algorithm <autorun> {
        while(1) {
            if( start ) { busy = 1; while( memorybusy ) {} busy = 0; }                                                          // WRITE DATA
        }
    }
}
unit store64(                                                                                                                   // 64 BIT STORES ( ALIGNED )
    input   uint1   start,
    input   uint64  storedata,
    output! uint32  writedata,
    input   uint$addr_width$ storeAddress,
    output! uint$addr_width$ address,
    output! uint1   busy(0),
    output! uint1   writememory,
    input!  uint1   memorybusy
) <reginputs> {
    writememory := 0;

    algorithm <autorun> {
        uint$addr_width$ plus4 <:: storeAddress + 4;

        while(1) {
            if( start ) {
                busy = 1;
                address = storeAddress; writedata = storedata[0,32]; writememory = 1; while( memorybusy ) {}                    // WRITE FIRST 32 BITS
                address = plus4; writedata = storedata[32,32]; writememory = 1; while( memorybusy ) {}                          // WRITE SECOND 32 BITS
                busy = 0;
            }
        }
    }
}
unit store_misaligned(                                                                                                          // 16, 32, 64 BITS STORES TO ADDRESS ...xxx1 ( mis-aligned byte )
    input   uint1   start,
    input   uint64  storedata,
    input   uint2   accesssize,
    output! uint8   writedata,
    input   uint$addr_width$ storeAddress,
    output! uint$addr_width$ address,
    output! uint1   busy(0),
    output! uint1   writememory,
    input!  uint1   memorybusy
) <reginputs> {
    writememory := 0;

    algorithm <autorun> {
        uint$addr_width$ plus1 <:: address + 1;
        uint4   maxCOUNT <:: ( 1 << accesssize );
        uint4   count = uninitialised;                  uint4   countNEXT <:: count + 1;

        while(1) {
            if( start ) {
                busy = 1; count = 0; address = storeAddress;                                                                    // START AT FIRST BYTE
                while( count != maxCOUNT ) {                                                                                    // CONTINUE FOR 2, 4, 8 BYTES
                    writedata = storedata[ { count, 3b000 }, 8 ]; writememory = 1; while( memorybusy ) {}                       // EXTRACT BYTE AND WRITE TO MEMORY
                    address = plus1; count = countNEXT;                                                                         // MOVE TO NEXT BYTE
                }
                busy = 0;
            }
        }
    }
}

// MINI DMA CONTROLLER
// MODE 0   INACTIVE
//      1   multi-src to single-dest PIXEL BLOCK 8 bit + SDCARD WRITE
//      2   SPECIAL PIXEL BLOCK RGB
//      3   multi-src to multi-dest MEMCPY
//      4   single-src to multi-dest MEMSET + SDCARD READ
//      5   single-src to single-dest SET TILE/CBLITTER to single value
//      6   increase src and dest by additions
//      7   32/16bit to 4/2 pixels for PIXEL BLOCK special mode
//      8   MEMCPY RECTANGLE IS 32/16 BIT CAPABLE
//      9   MEMSET RECTANGLE IS 32/16 BIT CAPABLE
unit dma_flags(
    input   uint$addr_width$  DMASOURCE,
    input   uint$addr_width$  DMASOURCEADD,
    input   uint$addr_width$  DMADEST,
    input   uint$addr_width$  DMADESTADD,
    input   uint$addr_width$  DMACOUNT,
    output  uint1   srcSET,
    output  uint1   src16bit,
    output  uint1   SD16,
    output  uint1   SSD16,
    output  uint1   SD32,
    output  uint1   SSD32,
    output  uint1   ADD16,
    output  uint1   ADD32,
    output  uint1   multi16,
    output  uint1   multi32
) <reginputs> {
    always_after {
        uint1   srcBRAM = ~DMASOURCE[26,1] & ~DMASOURCE[25,1] & ~DMASOURCE[15,1];                                               // SOURCE IS BRAM
        uint1   destBRAM = ~DMADEST[26,1] & ~DMADEST[25,1] & ~DMADEST[15,1];                                                    // DEST IS BRAM
        uint1   dest16bit = ( DMADEST[26,1] | DMADEST[25,1] | destBRAM ) & ~DMADEST[0,1];                                       // DESTINATION IS 16 BIT CAPABLE

        srcSET = ( DMASOURCE == $addr_width$hfe0e );                                                                            // SOURCE IS THE SET VALUE REGISTER, NO LOADING REQUIRED
        src16bit = ( srcSET | DMASOURCE[26,1] | DMASOURCE[25,1] | srcBRAM ) & ~DMASOURCE[0,1];                                  // SOURCE IS 16 BIT CAPABLE

        SD16 = src16bit & dest16bit & ~DMACOUNT[0,1];                                                                           // 16/32 BIT FLAGS FOR SOURCE&DEST + SET&DEST
        SSD16 = srcSET & dest16bit & ~DMACOUNT[0,1];
        SD32 = src16bit & dest16bit & ~|DMACOUNT[0,2];
        SSD32 = srcSET & dest16bit & ~|DMACOUNT[0,2];

        ADD16 = ~DMASOURCEADD[0,1] & ~DMADESTADD[0,1];                                                                          // 16/32 BIT FLAGS FOR SOURCE&DEST ADD
        ADD32 = ~|DMASOURCEADD[0,2] & ~|DMADESTADD[0,2];

        multi16 = ( DMADEST == 27hd642 );                                                                                       // MULTI-SRC TO SINGLE-DEST 16BIT FOR BLITTER TILE WRITER
        multi32 = ( DMADEST == 27hd680 ) | ( DMADEST == 27hd684 ) |                                                             // MULTI-SRC TO SINGLE-DEST 32BIT FOR PIXELBLOCK ARGB RGBA
                ( DMADEST == 27hd688 ) | ( DMADEST == 27hd68c );
    }
}
unit dma_src_add(
    input   uint$addr_width$ dmasrc,
    input   uint$addr_width$ DMASOURCEADD,
    input   uint1   DMA16BIT,
    input   uint1   DMA32BIT,
    input   uint3   PBmax,
    output  uint$addr_width$  NEXT,
    output  uint$addr_width$  ADD,
    output  uint$addr_width$  PB
) <reginputs> {
    always_after {
        NEXT = dmasrc + ( DMA32BIT ? 4 : DMA16BIT ? 2 : 1 );                                                                    // NEXT SOURCE ADDRESS FOR 32/16/8 BITS
        ADD = dmasrc + DMASOURCEADD;                                                                                            // NEXT DESTINATION ADDRESS IF STEPPING
        PB = dmasrc + PBmax;                                                                                                    // NEXT SOURCE ADDRESS FOR PIXELBLOCK TRANSFERS
    }
}
unit dma_dest_add(
    input   uint$addr_width$ dmadest,
    input   uint$addr_width$ DMADESTADD,
    input   uint1   DMA16BIT,
    input   uint1   DMA32BIT,
    input   uint3   PBmax,
    output  uint$addr_width$  NEXT,
    output  uint$addr_width$  ADD,
    output  uint$addr_width$  PB
) <reginputs> {
    always_after {
        NEXT = dmadest + ( DMA32BIT ? 4 : DMA16BIT ? 2 : 1 );                                                                   // NEXT DESTINATION ADDRESS FOR 32/16/8 BITS
        ADD = dmadest + DMADESTADD;                                                                                             // NEXT DESTINATION ADDRESS IF STEPPING
        PB = &dmadest[1,2] ? 27hd672: dmadest + 2;                                                                              // DETECTS BLUE PIXEL WRITTEN, MOVES BACK TO RED
    }
}
unit dma_pb_add(
    input   uint3   PBcount,
    input   uint3   PBmax,
    output  uint3   NEXT
) <reginputs> {
    always_after {
        NEXT = PBcount + 1;
    }
}
unit dma(
    input   uint$addr_width$  DMASOURCE,
    input   uint$addr_width$  DMASOURCEADD,
    input   uint$addr_width$  DMADEST,
    input   uint$addr_width$  DMADESTADD,
    input   uint$addr_width$  DMACOUNT,
    input   uint8   DMACYCLES,
    input   uint4   DMAMODE,
    input   uint32  DMASET,
    output  uint2   DMAACCESSSIZE,
    output! uint1   DMAACTIVE(0),

    input   uint1   start,
    output! uint$addr_width$  address,
    output! uint32  writedata,
    output! uint1   writememory,
    output! uint1   readmemory,
    input!  uint32  readdata,
    input!  uint1   memorybusy
) <reginputs> {
    uint1   DMA16BIT = uninitialised;               uint1   DMA32BIT = uninitialised;                                           // IS DMA TRANSFER 16/32 BIT CAPABLE, DEFAULTS TO 8 BIT

    // COUNTERS FOR PIXEL BLOCK TRANSFERS
    uint1   PB4pixel = uninitialised;               uint3   PBmax <:: PB4pixel ? 4 : 2;                 uint3   PBcount = uninitialised;

    uint4   dmamode = uninitialized;                uint$addr_width$  dmacount = uninitialised;         uint8   dmacycles = uninitialised;
    uint$addr_width$  dmasrc = uninitialised;       uint$addr_width$  dmadest = uninitialised;          uint32  memoryinput = uninitialised;

    uint1   update = uninitialised;

    uint32  writecopy <:: DMA16BIT | DMA32BIT ? readdata :  readdata[ { dmasrc[0,1], 3b000 }, 8 ];

    uint$addr_width$  dmacountNEXT <:: dmacount - ( DMA32BIT ? 4 : DMA16BIT | ( &dmamode[0,3] & PB4pixel ) ? 2 : 1 );

    dma_flags FLAGS(                                                                                                            // GENERATE DMA SIZE FLAGS FOR 8/16/32 BIT ACCESS
        DMASOURCE <: DMASOURCE,
        DMASOURCEADD <: DMASOURCEADD,
        DMADEST <: DMADEST,
        DMADESTADD <: DMADESTADD,
        DMACOUNT <: DMACOUNT,
    );
    dma_src_add SRC(                                                                                                            // GENERATE NEXT SOURCE ADDRESSES
        dmasrc <: dmasrc,
        DMASOURCEADD <: DMASOURCEADD,
        DMA16BIT <: DMA16BIT,
        DMA32BIT <: DMA32BIT,
        PBmax <: PBmax
    );
    dma_dest_add DEST(                                                                                                          // GENERATE NEXT DESTINATION ADDRESSES
        dmadest <: dmadest,
        DMADESTADD <: DMADESTADD,
        DMA16BIT <: DMA16BIT,
        DMA32BIT <: DMA32BIT
    );
    dma_pb_add PB(                                                                                                              // GENERATE NEXT PIXELBLOCK COUNTERS
        PBcount <: PBcount,
        PBmax <: PBmax
    );

    writememory := 0; readmemory := 0; update := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) {
                switch( dmamode[3,1] ) {
                    case 0: {
                        while( |dmacount ) {                                                                                    // SINGLE CYCLE MODE
                            address = dmasrc; readmemory = ~FLAGS.srcSET;
                            switch( { FLAGS.srcSET, &dmamode[0,3] } ) {
                                case 2b00: { while( memorybusy ) {} ++: address = dmadest; writedata = writecopy; writememory = 1; while( memorybusy ) {} }
                                case 2b01: {
                                    while( memorybusy ) {} memoryinput = readdata;
                                    address = dmadest; PBcount = 0;
                                    while( PBcount != PBmax ) {
                                        writedata = memoryinput[ { PBcount, 3b000 }, 8]; writememory = 1; while( memorybusy ) {} PBcount = PB.NEXT;
                                    }
                                }
                                case 2b10: { address = dmadest; writememory = 1; while( memorybusy ) {} }
                                case 2b11: {
                                    address = dmadest; PBcount = 0;
                                    while( PBcount != PBmax ) { writememory = 1; while( memorybusy ) {} PBcount = PB.NEXT; }
                                }
                            }
                            update = 1;
                        }
                    }
                    case 1: {
                        while( |dmacycles ) {
                            while( |dmacount ) {                                                                                // MULTI-CYCLE MODE
                                address = dmasrc; readmemory = ~FLAGS.srcSET;
                                switch( FLAGS.srcSET ) {
                                    case 0: { while( memorybusy ) {} ++: address = dmadest; writedata = writecopy; writememory = 1; while( memorybusy ) {} }
                                    case 1: { address = dmadest;  writememory = 1; while( memorybusy ) {} }
                                }
                                update = 1;
                            }
                            update = 1;
                        }
                    }
                }
                DMAACTIVE = 0;
            }
        }
    }

    always_after {
        if( start ) {
            DMA16BIT = 0; DMA32BIT = 0; PB4pixel = 0;                                                                           // DETERMINE MAXIMUM DMA TRANSFER SIZE PER CYCLE
            switch( dmamode ) {
                default: {}                                                                                                     // DEFAULT TO 8 BIT MODE
                case 1: {
                    DMA16BIT = FLAGS.multi16;                                                                                   // MULTI-SRC TO SINGLE-DEST 16BIT FOR BLITTER TILE WRITER
                    DMA32BIT = FLAGS.multi32;                                                                                   // MULTI-SRC TO SINGLE-DEST 32BIT FOR PIXELBLOCK ARGB RGBA
                }
                case 3: { DMA32BIT = FLAGS.SD32; DMA16BIT = FLAGS.SD16; }                                                       // MEMCPY IS 32/16 BIT CAPABLE
                case 4: { DMA32BIT = FLAGS.SSD32; DMA16BIT = FLAGS.SSD16; }                                                     // MEMSET IS 32/16 BIT CAPABLE
                case 7: { PB4pixel = ~|DMACOUNT[0,2] & FLAGS.src16bit; }                                                        // PIXELBLOCK MODE CAN OPERATE AT 4 PIXELS, NOT 2
                case 8: { DMA32BIT = FLAGS.SD32 & FLAGS.ADD32; DMA16BIT = FLAGS.SD16 & FLAGS.ADD16; }                           // MEMCPY RECTANGLE IS 32/16 BIT CAPABLE
                case 9: { DMA32BIT = FLAGS.SSD32 & FLAGS.ADD32; DMA16BIT = FLAGS.SSD16 & FLAGS.ADD16; }                         // MEMSET RECTANGLE IS 32/16 BIT CAPABLE
            }
            DMAACCESSSIZE = DMA32BIT | ( &DMAMODE[0,3] & PB4pixel ) ? 2b10 : DMA16BIT | &DMAMODE[0,3] ? 2b01: 2b00;             // SET THE ACCESS SIZE ( SPECIAL PIXEL BLOCK IS 32/16 for 4/2 pixels )
            DMAACTIVE = 1;
        }

        if( update ) {
            if( dmamode[3,1] ) {                                                                                                // UPDATE ADDRESSES IF RECTANGLE MODE
                if( |dmacount ) {
                    dmadest = DEST.NEXT; if( ~dmamode[0,1] ) { dmasrc = SRC.NEXT; }
                } else {
                    dmadest = DEST.ADD - DMACOUNT; if( ~dmamode[0,1] ) { dmasrc = SRC.ADD - DMACOUNT; }
                }
            } else {
                switch( dmamode[0,3] ) {                                                                                        // UPDATE ADDRESS IF NOT RECTANGLE MODE
                    default: {}
                    case 1: { dmasrc = SRC.NEXT; }
                    case 2: { dmasrc = SRC.NEXT; dmadest = DEST.PB; }
                    case 3: { dmasrc = SRC.NEXT; dmadest = DEST.NEXT; }
                    case 4: { dmadest = DEST.NEXT; }
                    case 6: { dmasrc = SRC.ADD; dmadest = DEST.ADD; }
                    case 7: { dmasrc = SRC.PB; }
                }
            }
            dmacycles = dmacycles - ~|dmacount;                                                                                 // UPDATE CYCLES WHEN COUNT == 0
            dmacount = |dmacount ? dmacountNEXT : dmamode[3,1] ? DMACOUNT : 0;                                                  // UPDATE COUNT I` != 0, reset if multi-cycle mode
        }

        if( ~DMAACTIVE ) {
            dmasrc = DMASOURCE; dmadest = DMADEST; dmacount = DMACOUNT; dmacycles = DMACYCLES;                                  // IF DMA NOT ACTIVE SET VALUES TO I/O REGISTERS
            dmamode = DMAMODE; writedata = DMASET;
        }
    }
}
