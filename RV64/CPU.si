// RISC-ICE-V
// inspired by https://github.com/sylefeb/Silice/blob/master/projects/ice-v/ice-v.ice
//
// A simple Risc-V RV64GC processor

// RISC-V - MAIN CPU LOOP

unit PAWSCPU(
    input   uint1   clock_CPUdecoder,                                                                                           // 100 MHz clocks for fast decode/register fetch
    input   uint1   clock_cache,                                                                                                // 100 MHz clock for on CPU instruction cache

    output  uint1   cacheselect,                                                                                                // CACHESELECT 0 = instruction, 1 = data (not used but kept for future use)
    output  uint$addr_width$  address,                                                                                          // MEMORY INTERFACE LINES
    output  uint2   accesssize,
    output  uint32  writedata,
    output  uint1   writememory,
    input   uint32  readdata,
    output  uint1   readmemory,
    input   uint1   memorybusy,

    input   uint1   SMTRUNNING,                                                                                                 // SMT CONTROL FLAGS FROM IO REGISTERS
    input   uint$addr_width$  SMTSTARTPC,                                                                                       // HART1 START ADDRESS

    output  uint1   DMASTART,                                                                                                   // DMA CONTROLLER FLAGS     CPU TO DMA START FLAG, ready to surrender bus
    input   uint4   DMAMODE,                                                                                                    //                          DMA START REQUEST WHEN != 0
    input   uint1   DMAACTIVE                                                                                                   //                          DMA ACTIVE
) <reginputs> {
    uint1   COMMIT = uninitialized;                 uint1   COMMIT_SMT = uninitialised;                                         // COMMIT RESULT TO REGISTERS FLAG AND TO WHICH THREAD
    uint1   SMT = 0;                                                                                                            // SMT FLAG
    uint$addr_width$  pc = 0;                       uint$addr_width$  pcSMT = uninitialized;                                    // PROGRAMS COUNTERS FOR MAIN AND SMT THREADS
    uint$addr_width$  PC <:: SMT ? pcSMT : pc;                                                                                  // SELECT PROGRAM COUNTER FOR THIS CYCLE

    uint1   START_LOAD = uninitialised;                                                                                         // START LOAD FROM MEMORY FLAG
    uint1   START_STORE = uninitialised;                                                                                        // START STORE TO MEMORY FLAG
    uint64  memoryinput <:: RV64CONTROL.IS_MA ? LOADMA.memoryinput :                                                            // DETERMINE MEMORY INPUT - FROM MISALIGNED LOAD
                            RV64CONTROL.IS_MEM64 ? LOAD64.memoryinput :                                                         //                          FROM 64 BIT LOAD
                            readdata;                                                                                           //                          FROM STANDARD LOAD
    uint64  memoryoutput <:: RV64CONTROL.IS_FAST ? EXECUTEFAST.memoryoutput : EXECUTESLOW.memoryoutput;                         // DETERMINE MEMORY OUTPUT FROM NORMAL [F]STORE OR ATOMIC OPERATIONS

    uint64  result <:: RV64CONTROL.IS_FPU ? EXECUTEFPU.result : RV64CONTROL.IS_FAST ? EXECUTEFAST.result : EXECUTESLOW.result;  // DETERMINE PRESENT INSTRUCTION RESULT
    uint1   frd <:: RV64CONTROL.IS_FPU ? EXECUTEFPU.frd : RV64CONTROL.writeRegisterF;                                           // DETERMINE PRESENT INSTRUCTION RESULT TYPE (FLOAT/INTEGER)
    uint1   write <:: COMMIT & RV64CONTROL.writeRegister;                                                                       // WRITE TO REGISTERS FLAG

    control RV64CONTROL <@clock_CPUdecoder> (                                                                                   // RISC-V INSTRUCTION DECODER, ADDRESS GENERATOR, INTEGER REGISTERS
        cacheselect <: cacheselect,
        SMT <:: SMT,
        COMMIT_SMT <: COMMIT_SMT,
        frd <: frd,
        write <: write,
        result <: result,
        PC <: PC,
        instruction <: FETCH.instruction,
        compressed <: FETCH.compressed,
        accesssize :> accesssize
    );

    float_control RV64CONTROLF <@clock_CPUdecoder> (                                                                            // RISC-V FLOATING POINT REGISTERS AND REGISTER CLASSIFIERS
        SMT <:: SMT,
        COMMIT_SMT <: COMMIT_SMT,
        frd <: frd,
        write <: write,
        result <: result,
        instruction <: FETCH.instruction
    );

    cpuexecuteFASTPATH EXECUTEFAST(                                                                                             // RISC-V SINGLE CYCLE OPERATIONS
        size32 <: RV64CONTROL.IS_ALU32,
        size32extend <: RV64CONTROL.IS_ALU32SIGNX,
        byteaccess <: RV64CONTROL.loadAddress[0,1],
        opCode <: RV64CONTROL.opCode,
        function3 <: RV64CONTROL.function3,
        function7 <: RV64CONTROL.function7,
        rs1 <: RV64CONTROL.rs1,
        rs2 <: RV64CONTROL.rs2,
        sourceReg1 <: RV64CONTROL.sourceReg1,
        sourceReg2 <: RV64CONTROL.sourceReg2,
        sourceReg2F <: RV64CONTROLF.sourceReg2F,
        immediateValue <: RV64CONTROL.immediateValue,
        memoryinput <: memoryinput,
        AUIPCLUI <: RV64CONTROL.AUIPCLUI,
        nextPC <: RV64CONTROL.nextPC,
        isLOAD <: RV64CONTROL.IS_LOAD,
        isAUIPCLUI <: RV64CONTROL.IS_AUIPCLUI,
        isJAL <: RV64CONTROL.IS_JAL,
        isFENCE <: RV64CONTROL.IS_FENCE,
        LT <: RV64CONTROL.LT,
        LTU <: RV64CONTROL.LTU
    );

    cpuexecuteSLOWPATH EXECUTESLOW(                                                                                             // RISC-V MULTI-CYCLE OPERATIONS
        size32 <: RV64CONTROL.IS_ALU32,
        size32extend <: RV64CONTROL.IS_ALU32SIGNX,
        SMT <: SMT,
        function3 <: RV64CONTROL.function3,
        function7 <: RV64CONTROL.function7,
        rs1 <: RV64CONTROL.rs1, rs2 <: RV64CONTROL.rs2,
        sourceReg1 <: RV64CONTROL.sourceReg1, S1_abs32 <: RV64CONTROL.S1_abs32, S1_abs64 <: RV64CONTROL.S1_abs64,
        sourceReg2 <: RV64CONTROL.sourceReg2, S2_abs32 <: RV64CONTROL.S2_abs32, S2_abs64 <: RV64CONTROL.S2_abs64,
        memoryinput <: memoryinput,
        incCSRinstret <: COMMIT,
        isALU <: RV64CONTROL.IS_ALU,
        isCSR <: RV64CONTROL.IS_CSR,
        isATOMIC <: RV64CONTROL.IS_ATOMIC,
        FPUnewflags <: EXECUTEFPU.FPUnewflags,
        CSRupdateFPUflags <: EXECUTEFPU.CSRupdateFPUflags
    );

    cpuexecuteFPU EXECUTEFPU(                                                                                                   // RISC-V FLOATING POINT OPERATIONS
        opCode <: RV64CONTROL.opCode,
        function3 <: RV64CONTROL.function3,
        function7 <: RV64CONTROL.function7,
        rs2 <: RV64CONTROL.rs2,
        sourceReg1 <: RV64CONTROL.sourceReg1, S1_abs32 <: RV64CONTROL.S1_abs32, S1_abs64 <: RV64CONTROL.S1_abs64,
        sourceReg1F <: RV64CONTROLF.sourceReg1F, sourceReg1Fx <: RV64CONTROLF.sourceReg1Fx, sourceReg1Fxopp <: RV64CONTROLF.sourceReg1Fxopp, typeAF <: RV64CONTROLF.typeAF, typeAopp <: RV64CONTROLF.typeAopp,
        sourceReg2F <: RV64CONTROLF.sourceReg2F, sourceReg2Fx <: RV64CONTROLF.sourceReg2Fx, typeBF <: RV64CONTROLF.typeBF,
        sourceReg3Fx <: RV64CONTROLF.sourceReg3Fx, typeCF <: RV64CONTROLF.typeCF,
        aObINF <: RV64CONTROLF.aObINF, aAbINF <: RV64CONTROLF.aAbINF, aObNAN <: RV64CONTROLF.aObNAN, aObZERO <: RV64CONTROLF.aObZERO, aAbZERO <: RV64CONTROLF.aAbZERO,
        aZEROFRACTION <: RV64CONTROLF.aZEROFRACTION, bZEROFRACTION <: RV64CONTROLF.bZEROFRACTION,
        FLT <: RV64CONTROLF.FLT,
        FEQ <: RV64CONTROLF.FEQ,
        isFASTFPU <: RV64CONTROL.IS_FASTFPU,
        FPUflags <: EXECUTESLOW.FPUflags
    );

    uint1   L0match <:: ( ~SMT & ICACHE_0.tagmatch ) | ( SMT & ICACHE_1.tagmatch );                                             // CPU L0 CACHE MATCH FOR PC
    uint30  L0instruction <:: SMT ? ICACHE_1.instruction : ICACHE_0.instruction;                                                //  L0 instruction
    uint1   L0compressed <:: SMT ? ICACHE_1.compressed : ICACHE_0.compressed;                                                   //  L0 compressed flag
    fetch FETCH(                                                                                                                // Risc-V FETCH INSTRUTION, INCLUDES COMPRESSED EXPANSION AND L0 MATCHES
        clock_CPUdecoder <: clock_CPUdecoder,
        readdata <: readdata,
        memorybusy <: memorybusy,
        L0match <: L0match, L0instruction <: L0instruction, L0compressed <: L0compressed
    );

    load LOAD(  memorybusy <: memorybusy );                                                                                     // 8, 16, 32, 64 BIT LOAD UNITS INCLUDING 16, 32, 64 BIT MISALIGNED LOAD
    load64 LOAD64( loadAddress <: RV64CONTROL.loadAddress, readdata <: readdata, memorybusy <: memorybusy );
    load_misaligned LOADMA( accesssize <: RV64CONTROL.accesssize, loadAddress <: RV64CONTROL.loadAddress, readdata <: readdata, memorybusy <: memorybusy );

        store STORE( memorybusy <: memorybusy );                                                                                // 8, 16, 32, 64 BIT STORE UNITS INCLUDING 16, 32, 64 BIT MISALIGNED STORE
    store64 STORE64( memorybusy <: memorybusy, storeAddress <: RV64CONTROL.storeAddress, storedata <: memoryoutput );
    store_misaligned STOREMA( accesssize <: RV64CONTROL.accesssize, memorybusy <: memorybusy, storeAddress <: RV64CONTROL.storeAddress, storedata <: memoryoutput );

    simple_dualport_bram uint32 L00cache <@clock_cache,@clock> [$L00Iblocks$] = uninitialized;                                  // SMALL ON CPU L0 CACHE - 1 per HART - RESET WHEN FENCE MEM IS ACTIVATED
    simple_dualport_bram uint$L00Ipartaddresswidth$ L00tags <@clock_cache,@clock> [$L00Iblocks$] = uninitialized;
    simple_dualport_bram uint32 L01cache <@clock_cache,@clock> [$L01Iblocks$] = uninitialized;
    simple_dualport_bram uint$L01Ipartaddresswidth$ L01tags <@clock_cache,@clock> [$L01Iblocks$] = uninitialized;
    uint1   ICACHEUPDATE = uninitialised;                                                                                       // CPU L0 CACHE UPDATE FLAG
    uint1   CACHEL0CLEAR = uninitialised;                                                                                       // CPU L0 CACHE CLEAR FLAG, USED AFTER RESET
    uint1   invalidate <:: CACHEL0CLEAR | EXECUTEFAST.fenceACTIVE[0,1];                                                         // CPU L0 CACHE INVALIDATE FLAG, USED AFTER PROGRAM LOAD
    il00cache_read ICACHE_0 <@clock_cache> ( L0cache <:> L00cache, L0tags <:> L00tags, CLS <: ICACHE_0W.CLS, address <: pc );
    il01cache_read ICACHE_1 <@clock_cache> ( L0cache <:> L01cache, L0tags <:> L01tags, CLS <: ICACHE_1W.CLS, address <: pcSMT );
    il00cache_write ICACHE_0W( L0cache <:> L00cache, address <: pc, newinstruction <: FETCH.instruction[2,30], newcompressed <: FETCH.compressed, invalidate <: invalidate );
    il01cache_write ICACHE_1W( L0cache <:> L01cache, address <: pcSMT, newinstruction <: FETCH.instruction[2,30], newcompressed <: FETCH.compressed, invalidate <: invalidate );
    il00tags_write ITAGS_0W( L0tags <:> L00tags, address <: pc );
    il01tags_write ITAGS_1W( L0tags <:> L01tags, address <: pcSMT );

    ICACHE_0W.update := ~SMT & ICACHEUPDATE; ICACHE_1W.update := SMT & ICACHEUPDATE;                                            // UPDATE CPU l0 CACHE FOR MAIN/SMT THREAD FLAG
    ITAGS_0W.update := ~SMT & ICACHEUPDATE; ITAGS_1W.update := SMT & ICACHEUPDATE;                                              // UPDATE CPU l0 TAGS FOR MAIN/SMT THREAD FLAG
    CACHEL0CLEAR := 0;

    FETCH.start := 0;                                                                                                           // FETCH INSTRUCTION FLAG
    START_LOAD := 0; LOAD.start := 0; LOAD64.start := 0; LOADMA.start := 0;                                                     // LOAD FROM MEMORY FLAGS
    START_STORE := 0; STORE.start := 0; STORE64.start := 0; STOREMA.start := 0;                                                 // STORE TO MEMORY FLAGS
    DMASTART := 0;                                                                                                              // DMA CONTROLLER START FLAG
    EXECUTESLOW.start := 0;                                                                                                     // CPU CSR, ATOMIC, INTEGER DIVIDE START FLAG
    EXECUTEFPU.start := 0;                                                                                                      // CPU FPU START FLAG
    ICACHEUPDATE := 0;                                                                                                          // UPDATE CPU L0 CACHE FLAG
    COMMIT := 0;                                                                                                                // COMMIT TO REGISTERS FLAG

    algorithm <autorun> {
        uint16  resetCounter = -1;                                                                                              // RESET COUNTER
        uint16  resetNEXT <:: resetCounter - ~( memorybusy | DMAACTIVE | EXECUTESLOW.busy | EXECUTEFPU.busy |                   // -1 WHEN ALL UNITS ARE NO LONGER BUSY
                                                ICACHE_0W.CLS | ICACHE_1W.CLS |
                                                LOADMA.busy | STOREMA.busy | LOAD64.busy | STORE64.busy |
                                                FETCH.busy | LOAD.busy | STORE.busy );

        CACHEL0CLEAR = 1; while( |resetCounter ) { resetCounter = resetNEXT; }                                                  // WAIT FDR MEMORY AND CPU TO FINISH + DELAY FOR RESET
        cacheselect = 0; FETCH.start = 1; ++:                                                                                       // START FETCH FIRST INSTRUCTION

        while(1) {                                                                                                              // CPU LOOP
            COMMIT_SMT = SMT;                                                                                                   // LATCH THREAD MAIN/SMT

            if( |DMAMODE ) {
//                __display("DMA START");
                DMASTART = 1; while( DMAACTIVE | |DMAMODE ) {}                                                                 // PROCESS MINI-DMA ENGINE REQUESTS
            } else {
                if( FETCH.busy ) { while( FETCH.busy ) {} ++: }                                                             // WAIT FOR FETCH TO FINISH
                cacheselect = 1; ICACHEUPDATE = 1; ++:                                                                          // SWITCH TO DATA CACHE, UPDATE ICACHE, DO ADDRESS GENERATION, REGISTER FETCH

//                __display("DMA %b SMT %b L0 %b PC %h instruction %h compressed %b",DMAACTIVE,SMT,L0match,PC,FETCH.instruction,FETCH.compressed);

                START_STORE = RV64CONTROL.IS_FAST & RV64CONTROL.IS_STORE;                                                       // START STORE ( ONLY IN FAST MODE TO AVOID ATOMIC )
                START_LOAD = RV64CONTROL.IS_LOAD;                                                                               // START LOAD
                EXECUTEFPU.start = RV64CONTROL.IS_FPU;                                                                          // START FPU
                EXECUTESLOW.start = ( RV64CONTROL.IS_ALU & ~RV64CONTROL.IS_FAST ) |                                             // START DIVISION
                                    ( RV64CONTROL.IS_CSR );                                                                     // START CSR

                switch( { RV64CONTROL.IS_LOAD, RV64CONTROL.IS_FAST, RV64CONTROL.IS_STORE } ) {
                    case 3b000: { while( EXECUTESLOW.busy | EXECUTEFPU.busy ) {} }                                              // DIVISION, CSR, FLOATIUNG POINT
                    case 3b010: {}                                                                                              // FAST PATH - ALL BASE + MULTIPLICATION + B EXTENSION (except CLMUL)
                    case 3b011: { while( STORE64.busy | STORE.busy | STOREMA.busy ) {} }                                        // INTEGER + FLOAT/DOUBLE STORE
                    case 3b110: { while( LOAD64.busy | LOAD.busy | LOADMA.busy ) {} }                                           // INTEGER + FLOAT/DOUBLE LOAD
                    default: {                                                                                                  // ATOMIC LOAD - MODIFY - STORE + EMULATION OF LR.W AND SC.W
                        while( LOAD64.busy | LOAD.busy ) {}
                        EXECUTESLOW.start = 1; while( EXECUTESLOW.busy ) {}
                        START_STORE = RV64CONTROL.IS_STORE; while( STORE64.busy | STORE.busy ) {}
                    }
                }

                COMMIT = 1;                                                                                                     // COMMIT REGISTERS AND UPDATE PC AND SWITCH THREADS IF SMT ENABLED
                pc = SMT ? pc : RV64CONTROL.newPC; pcSMT = SMT ? RV64CONTROL.newPC : SMTRUNNING ? pcSMT : SMTSTARTPC;           // MOVE TO NEXT INSTRUCTION
                if( ~EXECUTEFAST.fenceACTIVE[1,1] ) { SMT = ~SMT & SMTRUNNING; }                                                // SWITCH THREADS IF ACTIVE AND NOT FENCED
            }

            if( ~|DMAMODE ) { cacheselect = 0; FETCH.start = 1; }                                                               // START FETCH OF NEXT INSTRUCTION IF NO DMA REQUEST
        }
    }

    always_after {
        switch( { RV64CONTROL.IS_MA, RV64CONTROL.IS_MEM64 } ) {                                                                 // START APPROPRIATE LOAD UNIT
            case 2b00: { LOAD.start = START_LOAD; }
            case 2b01: { LOAD64.start = START_LOAD; }
            default: { LOADMA.start = START_LOAD; }
        }
        switch( { RV64CONTROL.IS_MA, RV64CONTROL.IS_MEM64 } ) {                                                                 // START APPROPRIATE STORE UNIT
            case 2b00: { STORE.start = START_STORE; }
            case 2b01: { STORE64.start = START_STORE; }
            default: { STOREMA.start = START_STORE; }
        }

//        if( |{ LOAD.busy, LOAD64.busy, LOADMA.busy, STORE.busy, STORE64.busy, STOREMA.busy} | ~cacheselect ) {                  // OUTPUT CORRECT ADDRESS ONTO BUS
                address = cacheselect ? LOAD.busy ? RV64CONTROL.loadAddress :
                                        LOAD64.busy ? LOAD64.address :
                                        LOADMA.busy ? LOADMA.address :
                                        STORE.busy ? RV64CONTROL.storeAddress :
                                        STORE64.busy ? STORE64.address :
                                                       STOREMA.address :
                          SMT ? pcSMT : pc;
//        }

        writedata = RV64CONTROL.IS_MA ? STOREMA.writedata :                                                                     // SELECT DATA TO PUT ONTO WRITE BUS    MISALIGNED STORE
                    RV64CONTROL.IS_MEM64 ? STORE64.writedata : memoryoutput;                                                    //                                      64 OR 8/16/32 BIT STORE UNITS
        readmemory = LOAD.readmemory | LOAD64.readmemory | LOADMA.readmemory | FETCH.readmemory;                                // OUTPUT ONTO BUS MEMORY READ FLAGS
        writememory = STORE.writememory | STORE64.writememory | STOREMA.writememory;                                            // OUTPUT ONTO BUS COPY MEMORY WRITE FLAGS
    }
}

unit signnanbox(                                                                                                                // SIGN EXTEND/NAN BOX MEMORYINPUT
    input   uint1   floatload,
    input   uint1   dounsigned,
    input   uint2   accesssize,
    input   uint1   byteaccess,
    input   uint64  memoryinput,
    output! uint64  readdata
) <reginputs> {
    algorithm <autorun> {
        uint1   sign <:: floatload ? 1 :                                                                                         // NAN BOX BIT FOR FLOAT LOAD
                        dounsigned | &accesssize ? 0 :                                                                          // SIGN BIT FOR UNSIGNED OR 64 BIT
                                      accesssize[1,1] ? memoryinput[31,1] :                                                     // EXTRACT SIGN IF REQUIRED FOR 32 BIT
                                      accesssize[0,1] ? memoryinput[15,1] :                                                     //                              16 BIT
                                                        memoryinput[{ byteaccess, 3b111 }, 1 ];                                 //                               8 BIT

        while(1) {
            switch( accesssize ) {
                case 2b00: { readdata = { {56{sign}}, memoryinput[ { byteaccess, 3b000 }, 8 ] }; }                              // SIGN EXTEND 8 BIT LOAD
                case 2b01: { readdata = { {48{sign}}, memoryinput[0,16] }; }                                                    // SIGN EXTEND / NAN BOX 16 BIT LOAD
                case 2b10: { readdata = { {32{sign}}, memoryinput[0,32] }; }                                                    // SIGN EXTEND / NAN BOX 32 BIT LOAD
                case 2b11: { readdata = memoryinput; }                                                                          // COPY 64 BIT LOAD
            }
        }
    }
}
unit cpuexecuteFASTPATH(
    input   uint1   size32,
    input   uint1   size32extend,
    input   uint1   byteaccess,
    input   uint5   opCode,
    input   uint3   function3,
    input   uint7   function7,
    input   uint5   rs1,
    input   uint5   rs2,
    input   int64   sourceReg1,
    input   int64   sourceReg2,
    input   uint64  sourceReg2F,
    input   int64   immediateValue,
    input   int64   memoryinput,
    input   uint64  AUIPCLUI,
    input   uint$addr_width$  nextPC,
    input   uint1   isLOAD,
    input   uint1   isAUIPCLUI,
    input   uint1   isJAL,
    input   uint1   isFENCE,
    output  int64   memoryoutput,
    output  int64   result,
    input   uint1   LT,
    input   uint1   LTU,
    output  uint2   fenceACTIVE(0)
) <reginputs> {
    alu ALU(                                                                                                                    // SINGLE CYCLE INTEGER OPERATIONS
        size32 <: size32, opCode <: opCode, function3 <: function3, function7 <: function7,
        rs1 <: rs1, rs2 <: rs2,
        sourceReg1 <: sourceReg1, sourceReg2 <: sourceReg2,
        immediateValue <: immediateValue,
        LT <: LT, LTU <: LTU
    );
    signnanbox LOAD(                                                                                                            // SIGN EXTEND IF SIGNED LOAD, OR NAN-BOX FOR FLOAT LOAD
        floatload <: opCode[0,1],                                                                                               //  IS FLOAT LOAD
        dounsigned <: function3[2,1],                                                                                           //  IS UNSIGNED INTEGER LOAD
        accesssize <: function3[0,2],                                                                                           //  IS 8 BIT, 16, BIT, 32, 64 BIT LOAD
        byteaccess <: byteaccess,                                                                                               //  ADDRESS LINE 0 FOR 8 BIT LOAD
        memoryinput <: memoryinput                                                                                              //  FROM LOAD UNITS
    );

    memoryoutput := opCode[0,1] ? sourceReg2F : sourceReg2;                                                                     // FLOAT STORE OR STORE

    result := isAUIPCLUI ? AUIPCLUI :                                                                                           // LUI AUIPC
                   isJAL ? nextPC :                                                                                             // JAL[R]
                  isLOAD ? LOAD.readdata :                                                                                      // INTEGER/FLOAT LOAD SIGN EXTENDED/NAN BOIXED BY LOAD UNIT
                           ( size32 & size32extend ) ? { {32{ALU.result[31,1]}}, ALU.result[0,32] } : ALU.result;               // INTEGER ALU AND MULTIPLICATION, SIGN EXTEND 32 bit

    fenceACTIVE := isFENCE ? { |function7[1,2], ~function3[0,1] } : fenceACTIVE;                                                // SET FENCE ACTIVE { IO, MEM }, IO THREAD SWITCH, MEM RESET L0CACHE
}

unit cpuexecuteSLOWPATH(
    input   uint1   size32,
    input   uint1   size32extend,
    input   uint1   start,
    output  uint1   busy(0),
    input   uint1   SMT,
    input   uint3   function3,
    input   uint7   function7,
    input   uint5   rs1,
    input   uint5   rs2,
    input   int64   sourceReg1,
    input   uint32  S1_abs32,
    input   uint64  S1_abs64,
    input   int64   sourceReg2,
    input   uint32  S2_abs32,
    input   uint64  S2_abs64,
    input   int64   memoryinput,
    output  int64   memoryoutput,
    output  int64   result,
    input   uint1   incCSRinstret,
    input   uint1   isCSR,
    input   uint1   isATOMIC,
    input   uint1   isALU,
    output  uint8   FPUflags,
    input   uint5   FPUnewflags,
    input   uint1   CSRupdateFPUflags
) <reginputs> {
    uint3   operation <:: { isALU, isATOMIC, isCSR };

    aluA ALUA( function7 <: function7[2,5], memoryinput <: memoryinput, sourceReg2 <: sourceReg2 );                             // ATOMIC MEMORY OPERATIONS

    uint12  csrRegister <:: { function7, rs2 };                                                                                 // EXTRACT CSR REGISTER NUMBER FROM INSTRUCTION
    CSRblock CSR(                                                                                                               // MANDATORY RISC-V CSR REGISTERS + HARTID == 0 MAIN THREAD == 1 SMT THREAD
        SMT <: SMT,
        csrRegister <: csrRegister,
        function3 <: function3,
        rs1 <: rs1,
        sourceReg1 <: sourceReg1,
        FPUflags :> FPUflags,
        FPUnewflags <: FPUnewflags,
        updateFPUflags <: CSRupdateFPUflags,
        incCSRinstret <: incCSRinstret
    );

    aludivision ALUMD(                                                                                                          // INTEGER 32/64 BIT SIGNED/UNSIGNED DIVISION
        size32 <: size32, function3 <: function3,
        sourceReg1 <: sourceReg1, S1_abs32 <: S1_abs32, S1_abs64 <: S1_abs64,
        sourceReg2 <: sourceReg2, S2_abs32 <: S2_abs32, S2_abs64 <: S2_abs64
    );

    CSR.start := start & isCSR & |function3; ALUMD.start := start & isALU;                                                      // START FLAGS

    result := operation[0,1] ? |function3 ? CSR.result : 0 :                                                                    //  CSR
              operation[1,1] ? function7[3,1] ? memoryinput : function7[2,1] ? 0 : memoryinput :                                //  ATOMIC LOAD - MODIFY - STORE
              size32  & size32extend ? { {32{ALUMD.result[31,1]}}, ALUMD.result[0,32] } : ALUMD.result;                         //  INTEGER DIVISION, WITH SIGN EXTENSION FOR 32 BIT

    memoryoutput := function7[3,1] ? ALUA.result : sourceReg2;                                                                  //  ATOMIC LOAD - MODIFY - STORE OR LR.W SC.W - MEMORUOUTPUT

    algorithm <autorun> { busy = 0; while(1) {
        if( start ) {
            busy = 1;
            onehot( operation ) {                                                                                               // PROVIDE WAIT STATES
                default: { ++: }                                                                                                //  CSR AND ATOMIC OPERATIONS
                case 2: { while( ALUMD.busy ) {} }                                                                              //  INTEGER DIVISION
            }
            busy = 0;
        }
    } }
}

unit cpuexecuteFPU(
    input   uint1   start,
    output  uint1   busy,
    input   uint5   opCode,
    input   uint3   function3,
    input   uint7   function7,
    input   uint5   rs2,
    input   int64   sourceReg1,
    input   uint32  S1_abs32,
    input   uint64  S1_abs64,
    input   uint64  sourceReg1F,
    input   uint64  sourceReg1Fx,
    input   uint64  sourceReg1Fxopp,
    input   uint4   typeAF,
    input   uint4   typeAopp,
    input   uint64  sourceReg2F,
    input   uint64  sourceReg2Fx,
    input   uint4   typeBF,
    input   uint64  sourceReg3Fx,
    input   uint4   typeCF,
    input   uint1   aObINF,                                                                                                     // EITHER A OR B INF?
    input   uint1   aAbINF,                                                                                                     // BOTH A AND B INF?
    input   uint1   aObNAN,                                                                                                     // EITHER A OR B NAN?
    input   uint1   aObZERO,                                                                                                    // EITHER A OR B ZERO?
    input   uint1   aAbZERO,                                                                                                    // BOTH A AND B ZERO?
    input   uint1   aZEROFRACTION,                                                                                              // A FRACTION PART 0, POWER OF 2 OR TRUE ZERO DETECTION
    input   uint1   bZEROFRACTION,                                                                                              // B FRACTION PART 0, POWER OF 2 OR TRUE ZERO DETECTION
    input   uint1   FLT,
    input   uint1   FEQ,
    output  uint1   frd,
    output  int64   result,
    input   uint1   isFASTFPU,
    input   uint8   FPUflags,
    output  uint5   FPUnewflags,
    output  uint1   CSRupdateFPUflags
) <reginputs> {
    uint10  BIAS <:: function7[0,1] ? $BIAS64$ : function7[1,1] ? $BIAS16$ : $BIAS32$;                                          // SELECT BIAS TO PASS WHERE NEEDED ( CALCULATIONS AND DESTINATION FOR CONVERSIONS )
    uint10  SBIAS <:: rs2[0,1] ? $BIAS64$ : rs2[1,1] ? $BIAS16$ : $BIAS32$;                                                     // SELECT BIAS TO PASS WHERE NEEDED ( SOURCE FOR CHANGE PRECISION )

    uint3   converttype <:: {
                                ( function7[2,5] == 5b11000 ),                                                                  // FD2IL
                                ( function7[2,5] == 5b11010 ),                                                                  // IL2FD
                                ( function7[2,5] == 5b01000 )                                                                   // CHANGE PRECISION HSD <-> HSD
                            };
    uint1   fpuconvert <:: ( opCode == 5b10100 ) & |converttype;                                                                // FPU CONVERSION TO/FROM INT OR CHANGE OF PRECISION DETECTION
    uint1   fpufast <:: isFASTFPU | fpuconvert;                                                                                 // SINGLE CYCLE OR CONVERSION DETECTION
    uint1   fpucalc <:: ~fpufast;                                                                                               // CALCULATION DETECTION
    uint3   operation <:: { fpucalc, fpuconvert, fpufast & ~fpuconvert };                                                       // PRESENT INSTRUCTION ROUTE

    fpuSINGLECYCLE FPUFAST(                                                                                                     // FLOATING POINT SINGLE CYCLE OPERATIONS
        dsh <: function7[0,2],
        function3 <: function3[0,2], function7 <: function7[2,5],
        sourceReg1 <: sourceReg1, sourceReg1F <: sourceReg1F, sourceReg2F <: sourceReg2F,
        sign1F <: fp64( sourceReg1Fx ).sign, sign2F <: fp64( sourceReg2Fx ).sign,
        typeAF <: typeAF, typeBF <: typeBF,
        aObNAN <: aObNAN,
        aZEROFRACTION <: aZEROFRACTION,
        FLT <: FLT, FEQ <: FEQ
    );

    uint1   rm <:: ( &FPUflags[5,3] ? function3 : FPUflags[5,3] ) != 3b001;                                                     // SET ROUNDING FLAG ( ONLY RNE AND RTZ SUPPORTED ), FCSR UNLESS 111
    floatcalc FPUCALC(                                                                                                          // FLOATING POINT CALCULATIONS CONTROLLER
        rm <: rm, dsh <: function7[0,2],                                                                                        //  RETURNS RESULT WIDE PACKED IN DOUBLE BITFIELDS
        BIAS <: BIAS,
        opCode <: opCode, function3 <: function3, function7 <: function7[2,5],
        sourceReg1Fx <: sourceReg1Fx, sourceReg2Fx <: sourceReg2Fx, sourceReg3Fx <: sourceReg3Fx,
        typeAF <: typeAF, typeBF <: typeBF, typeCF <: typeCF,
        aObINF <: aObINF, aAbINF <: aAbINF, aObNAN <: aObNAN, aObZERO <: aObZERO, aAbZERO <: aAbZERO,
        aZEROFRACTION <: aZEROFRACTION, bZEROFRACTION <: bZEROFRACTION
    );
    repackage_actual CALCRESULT( dsh <: function7[0,2], a <: FPUCALC.result );                                                  // REPACKAGE CALCULATION RESULT INTO CORRECT BITFIELDS WITH NAN BOXING

    // FLOATING POINT CONVERSIONS
    uint64  convertresult <:: converttype[2,1] ? FPUF2IL.result : converttype[1,1] ? FPUIL2F.result : FPUF_CP.result;
    uint1   convertrm <:: ( function3 != 3b001 );                                                                               // SET ROUNDING FLAG FOR CONVERSIONS ( always uses function3 )
    intlong2float FPUIL2F( rm <: convertrm, dounsigned <: rs2[0,1], il <: rs2[1,1], dsh <: function7[0,2], BIAS <: BIAS, sourceReg1 <: sourceReg1, S1_abs32 <: S1_abs32, S1_abs64 <: S1_abs64 );
    float2intlong FPUF2IL( rm <: convertrm, dounsigned <: rs2[0,1], il <: rs2[1,1], BIAS <: BIAS, sourceReg1Fx <: sourceReg1Fx, typeAF <: typeAF );
    changeprecision FPUF_CP( dest <: function7[0,2], DBIAS <: BIAS, source <: rs2[0,2], SBIAS <: SBIAS, sourceReg1Fx <: sourceReg1Fxopp, typeAF <: typeAopp );

    uint5   convertflags <:: converttype[2,1] ? FPUF2IL.FPUflags : converttype[1,1] ? FPUIL2F.FPUflags : FPUF_CP.FPUflags;
    FPUnewflags := FPUflags | ( fpuconvert ? convertflags : fpucalc ? FPUCALC.FPUnewflags : FPUFAST.FPUnewflags );

    FPUCALC.start := fpucalc & start; CSRupdateFPUflags := 0;                                                                   // START FLAGS AND UPDATE CSR
    result := operation[0,1] ? FPUFAST.result : operation[1,1] ? convertresult : CALCRESULT.repack;                             // COLLECT THE APPROPRIATE RESULT
    frd := fpuconvert ? ( |converttype[0,2] ) : fpucalc ? 1 : FPUFAST.frd;                                                      // WRITE TO F REGISTERS FOR TO FLOAT CONVERSIONS, CALCULATIONS AND SOME SINGLE CYCLE

    algorithm <autorun> { busy = 0; while(1) {
        if( start ) {
            busy = 1; if( operation[2,1] ) { while( FPUCALC.busy ) {} }                                                         // WAIT STATE FOR CALCULATIONS
            busy = 0; CSRupdateFPUflags = 1;
        }
    } }
}

// FETCH UNIT, INCLUDING COMPRESSED INSTRUCTION EXPANSION
unit fetch(
    input   uint1   clock_CPUdecoder,
    input   uint1   start,
    output! uint1   busy,
    output  uint32  instruction,
    output  uint1   compressed,

    input   uint1   L0match,
    input   uint30  L0instruction,
    input   uint1   L0compressed,

    input   uint32  readdata,
    output! uint1   readmemory,
    input   uint1   memorybusy
) <reginputs> {
    compressed00 COMPRESSED00 <@clock_CPUdecoder> ( i16 <: readdata[2,14] );                                                    // COMPRESSED INSTRUCTION EXPANDERS
    compressed01 COMPRESSED01 <@clock_CPUdecoder> ( i16 <: readdata[2,14] );
    compressed10 COMPRESSED10 <@clock_CPUdecoder> ( i16 <: readdata[2,14] );

    readmemory := start & ~L0match;                                                                                             // START MEMORY READ IF NOT AN L0 CACHE MATCH

    algorithm <autorun> { busy = 0; while(1) {
        if( start ) {
            if( L0match ) {
                instruction = { L0instruction, 2b11 }; compressed = L0compressed;                                               // FROM L0 CACHE
            } else {
                busy = 1; while( memorybusy ) {} ++:                                                                            // FROM MEMORY
                compressed = ~&readdata[0,2];                                                                                   // SET COMPRESSED FLAGS
                instruction =  { &readdata[0,2] ? readdata[2,30] :                                                              // 32 BIT INSTRUCTION READ
                                ~|readdata[0,2] ? COMPRESSED00.i32 :                                                            // 16 BIT INSTRUCTION READ
                                  readdata[0,1] ? COMPRESSED01.i32 :
                                                  COMPRESSED10.i32, 2b11 };
                busy = 0;
            }
        }
    } }
}

// LOAD UNITS
// ALIGNED LOADS ARE FOR BYTES OR ...x0 ADDRESSES
// MISALGNED LOADS ARE FOR HALF WORDS, WORDS, LONG WORDS OR FLOATS AT ...xxx1 ADDRESSES
unit load(                                                                                                                      // 8, 16, 32 BIT LOADS WITH SIGN EXTENSION ( ALIGNED )
input   uint1   start,
output! uint1   busy,
output! uint1   readmemory,
input   uint1   memorybusy
) <reginputs> {
    readmemory := start;

    algorithm <autorun> { busy = 0; while(1) {
        if( start ) { busy = 1; while( memorybusy ) {} busy = 0; }                                                              // READ FROM MEMORY
    } }
}
unit load64(                                                                                                                    // 64-BIT LOADS ( ALIGNED )
input   uint1   start,
output! uint1   busy,
output  int64   memoryinput,
input   uint$addr_width$ loadAddress,
output! uint$addr_width$ address,
input   uint32  readdata,
output! uint1   readmemory,
input   uint1   memorybusy
) <reginputs> {
    uint2   latch = uninitialised;
    readmemory := 0; latch := 0;

    algorithm <autorun> {
        uint$addr_width$ loadAddress_p4 <:: loadAddress + 4;

        while(1) {
            if( start ) {
                busy = 1;
                address = loadAddress; readmemory = 1; while( memorybusy ) {} ++: latch = 1;                 // READ FIRST 32 BITS
                address = loadAddress_p4; readmemory = 1; while( memorybusy ) {} ++: latch = 2;             // READ SECOND 32 BITS
                busy = 0;
            }
        }
    }

    always_after {
        if( |latch ) { memoryinput[ { latch[1,1], 5b00000 }, 32 ] = readdata; }
    }
}
unit load_misaligned(                                                                                                           // 16, 32, 64 BITS LOADS FROM ADDRESS ...xxx1 ( mis-aligned byte )
input   uint1   start,
output! uint1   busy,
input   uint2   accesssize,
output  int64   memoryinput,
input   uint$addr_width$ loadAddress,
output! uint$addr_width$ address,
input   uint32  readdata,
output! uint1   readmemory,
input   uint1   memorybusy
) <reginputs> {
    readmemory := 0;

    algorithm <autorun> {
        uint$addr_width$ address_p1 <:: address + 1;
        uint4   count = uninitialised;
        uint4   count_p1 <:: count + 1;
        uint4   maxCOUNT <:: ( 1 << accesssize );

        busy = 0; while(1) {
            if( start ) {
                busy = 1; memoryinput = 0; count = 0; address = loadAddress;                                                    // START AT FIRST BYTE, ZERO DATA
                while( count != maxCOUNT ) {                                                                                    // CONTINUE FOR 2, 4, 8 BYTES
                    readmemory = 1; while( memorybusy ) {} ++:                                                                  // READ FROM ADDRESS
                    memoryinput[ { count, 3b000 }, 8 ] = readdata[ { address[0,1], 3b000 }, 8 ];                                // UPDATE BYE IN DATA
                    address = address_p1; count = count_p1;                                                                     // MOVE TO THE NEXT ADDRESS
                }
                busy = 0;
            }
        }
    }
}

// STORE UNITS
// ALIGNED STORES ARE FOR BYTES OR ...x0 ADDRESSES
// MISALGNED STORES ARE FOR HALF WORDS, WORDS, LONG WORDS OR FLOATS AT ...xxx1 ADDRESSES
unit store(                                                                                                                     // 8, 16, 32 BIT STORES ( ALIGNED )
input   uint1   start,
output! uint1   busy,
output! uint1   writememory,
input   uint1   memorybusy
) <reginputs> {
    writememory := start;

    algorithm <autorun> { busy = 0; while(1) {
        if( start ) { busy = 1; while( memorybusy ) {} busy = 0; }                                                              // WRITE DATA
    } }
}
unit store64(                                                                                                                   // 64 BIT STORES ( ALIGNED )
input   uint1   start,
input   uint64  storedata,
output! uint32  writedata,
input   uint$addr_width$ storeAddress,
output! uint$addr_width$ address,
output! uint1   busy,
output! uint1   writememory,
input   uint1   memorybusy
) <reginputs> {
    uint1   latch = uninitialised;
    writememory := 0; writedata := storedata[ { latch, 5b00000 }, 32 ];

    algorithm <autorun> {
        uint$addr_width$ storeAddress_p4 <:: storeAddress + 4;

        busy = 0; while(1) {
            latch = 0; address = storeAddress;
            if( start ) {
                busy = 1;
                writememory = 1; while( memorybusy ) {}                                                                         // WRITE FIRST 32 BITS
                latch = 1; address = storeAddress_p4; writememory = 1; while( memorybusy ) {}                                   // WRITE SECOND 32 BITS
                busy = 0;
            }
        }
    }
}
unit store_misaligned(                                                                                                          // 16, 32, 64 BITS STORES TO ADDRESS ...xxx1 ( mis-aligned byte )
input   uint1   start,
input   uint64  storedata,
input   uint2   accesssize,
output! uint8   writedata,
input   uint$addr_width$ storeAddress,
output! uint$addr_width$ address,
output! uint1   busy,
output! uint1   writememory,
input   uint1   memorybusy
) <reginputs> {
    uint4   count = uninitialised;
    writememory := 0; writedata := storedata[ { count, 3b000 }, 8 ];

    algorithm <autorun> {
        uint$addr_width$ address_p1 <:: address + 1;
        uint4   count_p1 <:: count + 1;
        uint4   maxCOUNT <:: ( 1 << accesssize );

        busy = 0; while(1) {
            count = 0; address = storeAddress;
            if( start ) {
                busy = 1;                                                                     // START AT FIRST BYTE
                while( count != maxCOUNT ) {                                                                                    // CONTINUE FOR 2, 4, 8 BYTES
                    writememory = 1; while( memorybusy ) {} address =  address_p1; count = count_p1;                        // WRITE TO MEMORY, MOVE TO NEXT BYTE
                }
                busy = 0;
            }
        }
    }
}
