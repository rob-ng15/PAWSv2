unit sprite_layer(
    input   uint10  pix_x,
    input   uint10  pix_x1,
    input   uint9   pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    input   uint1   pix_end,
    output! uint8   pixel,
    output! uint1   sprite_layer_display,

    // For reading sprite characteristics
    $$for i=0,15 do
        input   uint1   sprite_read_active_$i$,
        input   uint5   sprite_read_actions_$i$,
        input   int11   sprite_read_x_$i$,
        input   int10   sprite_read_y_$i$,
        input   uint3   sprite_read_tile_$i$,
    $$end

    // FULL collision detection
    // (1) Bitmap, (2) Tile Map L, (3) Tile Map U, (4) Other Sprite Layer
    input   uint1   collision_layer_1,
    input   uint1   collision_layer_2,
    input   uint1   collision_layer_3,
    input   uint1   collision_layer_4,
    $$for i=0,15 do
        output uint16 collision_$i$,
        output uint4  layer_collision_$i$,
    $$end

    $$for i=0,15 do
        simple_dualport_bram_port0 tiles_$i$,
    $$end
) <reginputs> {
    $$for i=0,15 do
        sprite_generator SPRITE_$i$(                                                                                            // Set sprite generator parameters for each sprite
            pix_x <: pix_x,
            pix_x1 <: pix_x1,
            pix_y <: pix_y,
            pix_active <: pix_active,
            pix_vblank <: pix_vblank,
            sprite_active <: sprite_read_active_$i$,
            sprite_actions <: sprite_read_actions_$i$,
            sprite_x <: sprite_read_x_$i$,
            sprite_y <: sprite_read_y_$i$,
            sprite_tile_number <: sprite_read_tile_$i$,
            tiles <:> tiles_$i$
        );
        uint16      detect_collision_$i$ = uninitialised;                                                                       // Collision detection flag sprite to sprite
        uint4       detect_layer_$i$ = uninitialised;                                                                           // Collision detection flag sprite to other layers
    $$end

    always_after {
        uint16  sprite_collision_frame = { SPRITE_15.pix_visible, SPRITE_14.pix_visible, SPRITE_13.pix_visible,                 // PIXELS TO DISPLAY FOR ALL SPRITES IN LAYER?
                                            SPRITE_12.pix_visible, SPRITE_11.pix_visible, SPRITE_10.pix_visible,
                                            SPRITE_9.pix_visible, SPRITE_8.pix_visible, SPRITE_7.pix_visible,
                                            SPRITE_6.pix_visible, SPRITE_5.pix_visible, SPRITE_4.pix_visible,
                                            SPRITE_3.pix_visible, SPRITE_2.pix_visible, SPRITE_1.pix_visible,
                                            SPRITE_0.pix_visible
                                            };

        {
            sprite_layer_display = pix_active & ( |sprite_collision_frame );                                                    // PIXEL TO DISPLAY?
            pixel =                                                                                                             // SELECT HIGHEST PRIORITY PIXEL, 15 -> 0
                $$for i=0,14 do
                        SPRITE_$15-i$.pix_visible ? SPRITE_$15-i$.pixel :
                $$end
                SPRITE_0.pixel;
        }
        {
            uint4   layer_collision_frame = { collision_layer_1, collision_layer_2, collision_layer_3, collision_layer_4 };     // OTHER LAYERS VISIBLE

            $$for i=0,15 do
                if( SPRITE_$i$.pix_visible ) {
                    detect_collision_$i$ = detect_collision_$i$ | sprite_collision_frame;
                    detect_layer_$i$ = detect_layer_$i$ | layer_collision_frame;
                }
            $$end
        }
        {
            if( pix_end ) {                                                                                                     // OUTPUT AND RESET COLLISION DETECTION FLAGS AT FRAME END
                $$for i=0,15 do
                    collision_$i$ = detect_collision_$i$; layer_collision_$i$ = detect_layer_$i$;
                    detect_collision_$i$ = 0; detect_layer_$i$ = 0;
                $$end
            }
        }
    }
}

unit sprite_generator(
    input   uint10  pix_x,
    input   uint10  pix_x1,
    input   uint9   pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    input   uint1   sprite_active,
    input   uint5   sprite_actions,
    input   int11   sprite_x,
    input   int10   sprite_y,
    input   uint3   sprite_tile_number,
    simple_dualport_bram_port0 tiles,
    output! uint1   pix_visible,
    output! uint8   pixel
) <reginputs> {
    int11   x <:: { 1b0, pix_x };                                                                                                // X COORDINATE
    int11   x1 <:: { 1b0, pix_x1 };                                                                                              // X COORDINATE PLUS 1 FOR PIXEL FETCHING
    int11   xspritex <:: ( x1 - sprite_x );                                                                                      // X PIXEL IN THE SPRITE TILE
    int10   y <:: { 1b0, pix_y };
    int10   yspritey <:: ( y - sprite_y );                                                                                       // Y CORRDINATE
    int11   xspriteshift <:: ( xspritex >>> sprite_actions[3,2] );                                                               // SCALE X PIXEL
    int10   yspriteshift <:: yspritey >>> sprite_actions[3,2];                                                                   // SCALE Y PIXEL
    uint4   revx <:: ~xspriteshift;
    uint4   revy <:: ~yspriteshift;
    uint1   action00 <:: ( ~|sprite_actions[0,2] );                                                                              // CHECK ACTION FLAGS FOR ROTATION
    uint1   action01 <:: ( sprite_actions[0,2] == 2b01 );
    uint1   action10 <:: ( sprite_actions[0,2] == 2b10 );

    uint4 xinsprite <:: sprite_actions[2,1] ? action00 ? xspriteshift : action01 ? yspriteshift : action10 ? revx : revy :       // Calculate position in sprite, handling rotation/reflection
                       sprite_actions[0,1] ? revx : xspriteshift;
    uint4 yinsprite <:: sprite_actions[2,1] ? action00 ? yspriteshift : action01 ? revx : action10 ? revy : xspriteshift :
                       sprite_actions[1,1] ? revy : yspriteshift;

    uint7 spritesize <:: 16 << sprite_actions[3,2];                                                                             // SIZE OF SPRITE 16,32,64,128 PIXELS
    uint1 xinrange <:: ( __signed(x) >= __signed(sprite_x) ) & ( __signed(x) < __signed( sprite_x + spritesize ) );             // IS ON SCREEN X?
    uint1 yinrange <:: ( __signed(y) >= __signed(sprite_y) ) & ( __signed(y) < __signed( sprite_y + spritesize ) );             // IS ON SCREEN Y?

    always_after {
        { tiles.addr0 = { sprite_tile_number, yinsprite, xinsprite }; }                                                                // READ ADDRESS FOR SPRITE TILE
        { pixel = tiles.rdata0; }                                                                                                      // OUTPUT PIXEL COLOUR
        { pix_visible := sprite_active & xinrange & yinrange & ( tiles.rdata0 != 64 ); }                                               // Determine if pixel is visible
    }
}

unit sprite_layer_writer(
    // For setting sprite characteristics
    input   uint4   sprite_set_number,
    input   uint13  sprite_write_value,
    input   uint3   sprite_layer_write,

    // For reading sprite characteristics
    $$for i=0,15 do
        output  uint1   sprite_read_active_$i$,
        output  uint5   sprite_read_actions_$i$,
        output  int11   sprite_read_x_$i$,
        output  int10   sprite_read_y_$i$,
        output  uint3   sprite_read_tile_$i$,
    $$end
) <reginputs> {
    uint5   sprite_actions[16] = uninitialised;                                                                                 // SPRITE ROTATION/REFLECTION/SIZE FLAGS
    int11   sprite_x[16] = uninitialised;                                                                                       // SPRITE X COORDINATES
    int10   sprite_y[16] = uninitialised;                                                                                       // SPRITE Y COORDINATES

    int11   sprite_offscreen_negative <:: -16 << sprite_actions[ sprite_set_number ][3,2];                                      // VALUE FOR SPRITE TO BE OFFSCREEN TOP/LEFT ( -SIZE OF SPRITE )
    uint1   sprite_off_left <:: ( __signed( sprite_x[ sprite_set_number ] ) < __signed( sprite_offscreen_negative ) );          // IS SPRITE OFFSCREEN LEFT?
    uint1   sprite_off_top <:: ( __signed( sprite_y[ sprite_set_number ] ) < __signed( sprite_offscreen_negative ) );           // IS SPRITE OFFSCREEN TOP
    uint1   sprite_offscreen_x <:: sprite_off_left | ( __signed( sprite_x[ sprite_set_number  ] ) > __signed(640) );            // IS SPRITE OFFSCREEN X
    uint1   sprite_offscreen_y <:: sprite_off_top | ( __signed( sprite_y[ sprite_set_number ] ) > __signed(480) );              // IS SPRITE OFFSCREEN Y

    always_after {
        uint1   sprite_active[16] = uninitialised;                                                                              // SPRITE ACTIVE FLAGS
        uint3   sprite_tile_number[16] = uninitialised;                                                                         // SPRITE DISPLAY TILE NUMBER

        {
            // SET ATTRIBUTES + PERFORM UPDATE
            switch( sprite_layer_write ) {
                case 0: {}
                case 1: { sprite_active[ sprite_set_number ] = sprite_write_value[0,1]; }                                       // SET ACTIVE
                case 2: { sprite_actions[ sprite_set_number ] = sprite_write_value[0,5]; }                                      // SET ROTATION/REFLECTION/SIZE FLAGS
                case 4: { sprite_x[ sprite_set_number ] = sprite_write_value[0,11]; }                                           // SET X COORDINATE
                case 5: { sprite_y[ sprite_set_number ] = sprite_write_value[0,10]; }                                           // SET Y COORDINATE
                case 6: { sprite_tile_number[ sprite_set_number ] = sprite_write_value[0,3]; }                                  // SET TILE NUMBER
                case 7: {                                                                                                       // PERFORM SPRITE UPDATE
                    sprite_active[ sprite_set_number ] = ( ( sprite_write_value[12,1] & sprite_offscreen_y ) |                  // IF OFFSCREEN Y AND NOT WRAP
                                                        ( sprite_write_value[11,1] & sprite_offscreen_x ) ) ? 0 :               // OR OFFSCREEN X AND NOT WRAP -> INACTIVE
                                                        sprite_active[ sprite_set_number ];                                     // ELSE PRESENT ACTIVE STATE
                    sprite_tile_number[ sprite_set_number ] = sprite_tile_number[ sprite_set_number ] +                         // INCREMENT TILE NUMBER?
                                                              sprite_write_value[10,1];
                    sprite_x[ sprite_set_number ] = sprite_offscreen_x ? ( sprite_off_left ? __signed(640) :                    // UPDATE X COORDINATE
                                                                                            sprite_offscreen_negative | 1 ) :
                                                    sprite_x[ sprite_set_number ] + { {7{spriteupdate( sprite_write_value ).dxsign}}, spriteupdate( sprite_write_value ).dx };
                    sprite_y[ sprite_set_number ] = sprite_offscreen_y ? ( sprite_off_top ? __signed(480) :                     // UPDATE Y COORDINATE
                                                                                            sprite_offscreen_negative | 1 ) :
                                                    sprite_y[ sprite_set_number ] + { {6{spriteupdate( sprite_write_value ).dysign}}, spriteupdate( sprite_write_value ).dy };
                }
            }
            $$for i=0,15 do
            sprite_read_active_$i$ = sprite_active[$i$];                                                                        // CPU SPRITE READ
            sprite_read_actions_$i$ = sprite_actions[$i$];
            sprite_read_x_$i$ = sprite_x[$i$];
            sprite_read_y_$i$ = sprite_y[$i$];
            sprite_read_tile_$i$ = sprite_tile_number[$i$];
            $$end
        }
    }
}
