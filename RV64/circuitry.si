// CLZ CIRCUITS - TRANSLATED BY @sylefeb + CTZ AND CPOP ADAPTED BY ROB S
// From recursive Verilog module
// https://electronics.stackexchange.com/questions/196914/verilog-synthesize-high-speed-leading-zero-count

// Create a LUA pre-processor function that recursively writes
// circuitries counting the number of leading zeros in variables
// of decreasing width.
// Note: this could also be made in-place without wrapping in a
// circuitry, directly outputting a hierarchical set of trackers (<:)
$$function generate_clz(name,w_in,recurse)
$$ local w_out = clog2(w_in)
$$ local w_h   = w_in//2
$$ if w_in > 2 then generate_clz(name,w_in//2,1) end
circuitry $name$_$w_in$ (input in,output out)
{
$$ if w_in == 2 then
   out = !in[1,1];
$$ else
   uint$clog2(w_in)-1$ half_count = uninitialized;
   uint$w_h$           lhs        = in[$w_h$,$w_h$];
   uint$w_h$           rhs        = in[    0,$w_h$];
   uint1               left_empty = ~|lhs;
   uint$w_h$           select     = left_empty ? rhs : lhs;
   (half_count) = $name$_$w_h$(select);
   out          = {left_empty,half_count};
$$ end
}
$$end

$$function generate_ctz(name,w_in,recurse)
$$ local w_out = clog2(w_in)
$$ local w_h   = w_in//2
$$ if w_in > 2 then generate_ctz(name,w_in//2,1) end
circuitry $name$_$w_in$ (input in,output out)
{
$$ if w_in == 2 then
   out = !in[0,1];
$$ else
   uint$clog2(w_in)-1$ half_count  = uninitialized;
   uint$w_h$           lhs         = in[$w_h$,$w_h$];
   uint$w_h$           rhs         = in[    0,$w_h$];
   uint1               right_empty = ~|rhs;
   uint$w_h$           select      = right_empty ? lhs : rhs;
   (half_count) = $name$_$w_h$(select);
   out          = {right_empty,half_count};
$$ end
}
$$end

$$function generate_cpop(name,w_in,recurse)
$$ local w_out = clog2(w_in)
$$ local w_h   = w_in//2
$$ if w_in > 2 then generate_cpop(name,w_in//2,1) end
circuitry $name$_$w_in$ (input in,output out)
{
$$ if w_in == 2 then
   out = &in[0,2] ? 2 : |in[0,2];
$$ else
   uint$clog2(w_in)$   left_count  = uninitialized;
   uint$clog2(w_in)$   right_count = uninitialized;
   uint$w_h$           lhs         = in[$w_h$,$w_h$];
   uint$w_h$           rhs         = in[    0,$w_h$];
   (left_count)  = $name$_$w_h$(lhs);
   (right_count) = $name$_$w_h$(rhs);
   out           = left_count + right_count;
$$ end
}
$$end

// Produce circuits for 64 bits numbers
$$generate_clz('clz_silice',64)
$$generate_ctz('ctz_silice',64)
$$generate_cpop('cpop_silice',64)

unit clz64(
    input   uint64  number,
    output! uint7   zeros
) <reginputs> {
    always_after {
        ( zeros ) = clz_silice_64( number );
    }
}

unit clz106(
    input   uint106  bitstream,
    output! uint7   count
) <reginputs> {
    uint4   mask <:: { |bitstream3, |bitstream2, |bitstream1, 1b0 };                                                            // FLAG CONTENTS OF EACH SECTION
    uint2   bitstream3 <:: bitstream[104,2];        uint8   bitstream2 <:: bitstream[96,8];                                     // SPLIT 106 BITS INTO 64, 32, 8 AND 2 ( from low to high )
    uint32  bitstream1 <:: bitstream[64,32];        uint64  bitstream0 <:: bitstream[0,64];

    uint2   clz_3 = uninitialised;                  uint4   clz_2 = uninitialised;
    uint6   clz_1 = uninitialised;                  uint7   clz_0 = uninitialised;

    always_after {
        { ( clz_3 ) = clz_silice_2( bitstream3 ); }
        { ( clz_2 ) = clz_silice_8( bitstream2 ); }
        { ( clz_1 ) = clz_silice_32( bitstream1 ); }
        { ( clz_0 ) = clz_silice_64( bitstream0 ); }
        {
            count = ( mask[3,1] ? clz_3 : mask[2,1] ? clz_2 : mask[1,1] ? clz_1 : clz_0 ) +                                     // COUNT LEADING ZEROS FOR NORMALISATION SHIFT
                    ( mask[3,1] ? 0 : mask[2,1] ? 2 : mask[1,1] ? 10 : 42 );
        }
     }
}
