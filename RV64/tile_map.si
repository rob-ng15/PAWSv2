unit tile1616(
    simple_dualport_bram_port0 tiles16x16,
    input  uint6   tile,
    input  uint4   x,
    input  uint4   y,
    output! uint8   pixel
) {
    always_after {
        tiles16x16.addr0 = { tile, y, x };                                                                                      // FIND CURRENT TILE PIXEL
        pixel = tiles16x16.rdata0;                                                                                              // OUTPUT CURRENT TILE PIXEL
    }
}

unit tilemap(
    input   uint1   clockTG,
    simple_dualport_bram_port0 tiles16x16,
    dualport_bram_port0 tiles,

    input   uint10  pix_x,
    input   uint10  pix_x1,
    input   uint9   pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint8   pixel,
    output! uint1   tilemap_display,

    // For scrolling/wrapping
    input   uint6   base_x(0),
    input   uint6   base_y(0),
    input   int5    tm_offset_x,
    input   int5    tm_offset_y
) <reginputs> {
    uint10  xtmpos <:: ( {{6{tm_offset_x[4,1]}}, tm_offset_x } + pix_x1 + 11d16 );                                              // FIND CURRENT X PIXEL COORDINATE IN TERMS OF TILEMAP TILES
    uint9   ytmpos <:: ( {{6{tm_offset_y[4,1]}}, tm_offset_y } + ( 11d16 + pix_y ) );                                           // FIND CURRENT Y PIXEL COORDINATE IN TERMS OF TILEMAP TILES
    uint7   tmxpb <:: ( xtmpos[4,6] + base_x );     uint7   actualxtmpos <:: tmxpb > 41 ? tmxpb - 42 : tmxpb;                   // FIND CURRENT TILE X COORDINATE ADJUSTED FOR OFFSET
    uint7   tmypb <:: ( ytmpos[4,5] + base_y );     uint7   actualytmpos <:: tmypb > 31 ? tmypb - 32 : tmypb;                   // FIND CURRENT TILE Y COORDINATE ADJUSTED FOR OFFSET
    uint4   xintm <:: { 1b0, pix_x[0,4] } + tm_offset_x; uint4   revx <:: ~xintm;                                               // X COORDINATE IN CURRENT TILE
    uint4   yintm <:: { 1b0, pix_y[0,4] } + tm_offset_y; uint4   revy <:: ~yintm;                                               // Y COORDINATE IN CURRENT TILE

    // Apply rotation/reflection
    uint1   action00 <:: ( ~|tmentry( tiles.rdata0 ).action );                                                                  // CHECK ACTION FLAGS FOR ROTATION
    uint1   action01 <:: ( tmentry( tiles.rdata0 ).action == 2b01 );
    uint1   action10 <:: ( tmentry( tiles.rdata0 ).action == 2b10 );
    uint4   xpixel <:: tmentry( tiles.rdata0 ).rflag ? action00 ? xintm : action01 ? yintm : action10 ? revx : revy :           // ROTATE X?
                       tiles.rdata0[6,1] ? revx : xintm;                                                                        // REFLECT X?
    uint4   ypixel <:: tmentry( tiles.rdata0 ).rflag ? action00 ? yintm : action01 ? revx : action10 ? revy : xintm :           // ROTATE Y?
                       tiles.rdata0[7,1] ? revy : yintm;                                                                        // REFLECT Y?

    tile1616 TG <@clockTG> (                                                                                                    // DOUBLE CLOCKED TILE GENERATOR
        tiles16x16 <:> tiles16x16,
        tile <: tmentry( tiles.rdata0 ).tilenumber,
        x <: xpixel,
        y <: ypixel
    );
    tiles.wenable0 := 0; tiles.addr0 := actualxtmpos + actualytmpos * 42;                                                       // SET ADDRESS FOR READING THE TILEMAP

    always_after {
        tilemap_display = pix_active & ( TG.pixel != 64 );                                                                      // IS PIXEL TO DISPLAY?
        pixel = TG.pixel;                                                                                                       // PIXEL COLOUR
    }
}

// CALCULATE NEW OFFSETS AND IF AT MIN/MAX
unit   calcoffset(
    input   int5    offset,
    input   uint4   adjust,
    output  uint1   MIN,
    output  int5    PREV,
    output  uint1   MAX,
    output  int5    NEXT
) <reginputs> {
    int6    offsetPLUS <:: { offset[4,1], offset } + adjust;                                                                    // PRESENT OFFSET PLUS ADJUSTMENT
    int6    offsetMINUS <:: { offset[4,1], offset } - adjust;                                                                   // PRESENT OFFSET MINUS ADJUSTMENT

    always_after {
        MIN = ( offsetMINUS < -15 );                                                                                            // MOVE TO PREVIOUS?
        MAX = ( offsetPLUS > 15 );                                                                                              // MOVE TO NEXT?
        PREV = offsetMINUS + ( MIN ? 16 : 0 );                                                                                  // NEW ADJUSTMENT IF MOVED TO NEXT TILE ( MINIMUM )
        NEXT= offsetPLUS - ( MAX ? 16 : 0 );                                                                                    // NEW ADJUSTMENT IF MOVED TO NEXT TILE ( MAXIMUM )
    }
}
unit tile_map_writer(
    dualport_bram_port1 tiles,

    // Set TM at x, y, character with foreground, background and rotation
    input   uint6   tm_x,
    input   uint6   tm_y,
    input   uint6   tm_character,
    input   uint3   tm_actions,
    input   uint1   tm_write,
    output  uint9   tm_read,

    // For scrolling/wrapping
    output  uint6   base_x(0),
    output  uint6   base_y(0),
    output  int5    tm_offset_x(0),
    output  int5    tm_offset_y(0),

    input   uint4   tm_scrollwrap,
    input   uint4   tm_adjust,
    output  uint4   tm_lastaction,
    output  uint1   tm_active
) <reginputs> {
    calcoffset TMOX( offset <: tm_offset_x, adjust <: tm_adjust );                                                              // X TILEMAP COORDINATE
    calcoffset TMOY( offset <: tm_offset_y, adjust <: tm_adjust );                                                              // Y TILEMAP COORDINATE

    uint7   tmxpb <:: ( tm_x + base_x );            uint7   write_x <:: tmxpb > 41 ? tmxpb - 42 : tmxpb;                        // FIND TILEMAP X COORDINATE
    uint7   tmypb <:: ( tm_y + base_y );            uint7   write_y <:: tmypb > 31 ? tmypb - 32 : tmypb;                        // FIND TILEMAP Y COORDINATE

    tiles.wenable1 := 0; tiles.addr1 := write_x + write_y * 42; tm_read := tiles.rdata1;                                        // TILEMAP WRITE FLAGS

    algorithm <autorun> {
        uint11  tmcsaddr = uninitialized;                                                                                       // CLEAR TILEMAP ADDRESS
        uint11  tmcsNEXT <:: tmcsaddr + 1;                                                                                      // NEXT ADDRESS FOR CLEAR TILEMAP

        while(1) {
            if( tm_active ) {                                                                                                   // CLEAR
                tiles.wdata1 = 0;
                while( tmcsaddr != 1344 ) { tiles.addr1 = tmcsaddr; tiles.wenable1 = 1; tmcsaddr = tmcsNEXT; }
                tm_active = 0;
            } else {
                tmcsaddr = 0;
            }
        }
    }

    always_after {
        if( tm_write ) { tiles.wdata1 = { tm_actions, tm_character }; tiles.wenable1 = 1; }                                     // WRITE TO TILE
        if( |tm_scrollwrap ) { tm_lastaction = 0; }

        switch( tm_scrollwrap ) {
            case 1: {                                                                                                           // MOVE LEFT
                if( TMOX.MAX ) { base_x = ( base_x == 41 ) ? 0 : base_x + 1; tm_lastaction = 1; }
                tm_offset_x = TMOX.NEXT;
            }
            case 2: {                                                                                                           // MOVE UP
                if( TMOY.MAX ) { base_y = ( base_y == 31 ) ? 0 : base_y + 1; tm_lastaction = 2; }
                tm_offset_y = TMOY.NEXT;
            }
            case 3: {                                                                                                           // MOVE RIGHT
                if( TMOX.MIN ) { base_x = ( ~|base_x ) ? 41 : base_x - 1; tm_lastaction = 3; }
                tm_offset_x = TMOX.PREV;
            }
            case 4: {                                                                                                           // MOVE DOWN
                if( TMOY.MIN ) { base_y = ( ~|base_y ) ? 31 : base_y - 1; tm_lastaction = 4; }
                tm_offset_y = TMOY.PREV;
            }
            case 5: { tm_active = 1; base_x = 0; base_y = 0; tm_offset_x = 0; tm_offset_y = 0; }                                // START CLEAR
            default: {}
        }
    }
}
