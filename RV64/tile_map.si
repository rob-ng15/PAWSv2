unit tile1616(
    simple_dualport_bram_port0 tiles16x16,
    input   uint6   tile,
    input   uint4   x,
    input   uint4   y,
    output! uint8   pixel
) {
    tiles16x16.addr0 := { tile, y, x };                                                                                         // FIND CURRENT TILE PIXEL
    pixel := tiles16x16.rdata0;                                                                                                 // OUTPUT CURRENT TILE PIXEL
}

unit tilemap(
    input   uint1   clockTG,
    simple_dualport_bram_port0 tiles16x16,
    dualport_bram_port0 tiles,

    input   uint10  pix_x,
    input   uint10  pix_x1,
    input   uint9   pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint8   pixel,
    output! uint1   tilemap_display,

    // For scrolling/wrapping
    input   uint6   base_x(0),
    input   uint6   base_y(0),
    input   int5    tm_offset_x,
    input   int5    tm_offset_y
) <reginputs> {
    uint11  xtmpos <:: ( {{6{tm_offset_x[4,1]}}, tm_offset_x } + pix_x1 + 11d32 );                                              // FIND CURRENT X PIXEL COORDINATE IN TERMS OF TILEMAP TILES
    uint11  ytmpos <:: ( {{6{tm_offset_y[4,1]}}, tm_offset_y } + ( 11d32 + pix_y ) );                                           // FIND CURRENT Y PIXEL COORDINATE IN TERMS OF TILEMAP TILES
    uint6   tmxpb <:: ( xtmpos[4,6] + base_x );                                                                                 // FIND CURRENT TILE X COORDINATE ADJUSTED FOR OFFSET
    uint6   tmypb <:: ( ytmpos[4,6] + base_y );                                                                                 // FIND CURRENT TILE Y COORDINATE ADJUSTED FOR OFFSET
    uint4   xintm <:: { 1b0, pix_x[0,4] } + tm_offset_x; uint4   revx <:: ~xintm;                                               // X COORDINATE IN CURRENT TILE
    uint4   yintm <:: { 1b0, pix_y[0,4] } + tm_offset_y; uint4   revy <:: ~yintm;                                               // Y COORDINATE IN CURRENT TILE

    // Apply rotation/reflection
    uint1   action00 <:: ( ~|tmentry( tiles.rdata0 ).action );                                                                  // CHECK ACTION FLAGS FOR ROTATION
    uint1   action01 <:: ( tmentry( tiles.rdata0 ).action == 2b01 );
    uint1   action10 <:: ( tmentry( tiles.rdata0 ).action == 2b10 );
    uint4   xpixel <:: tmentry( tiles.rdata0 ).rflag ? action00 ? xintm : action01 ? yintm : action10 ? revx : revy :           // ROTATE X?
                       tiles.rdata0[6,1] ? revx : xintm;                                                                        // REFLECT X?
    uint4   ypixel <:: tmentry( tiles.rdata0 ).rflag ? action00 ? yintm : action01 ? revx : action10 ? revy : xintm :           // ROTATE Y?
                      tiles.rdata0[7,1] ? revy : yintm;                                                                         // REFLECT Y?

    tile1616 TG <@clockTG> (                                                                                                    // DOUBLE CLOCKED TILE GENERATOR
        tiles16x16 <:> tiles16x16,
        tile <: tmentry( tiles.rdata0 ).tilenumber,
        x <: xpixel,
        y <: ypixel
    );

    tiles.addr0 := { tmypb, tmxpb };                                                                                            // SET ADDRESS FOR READING THE TILEMAP
    tilemap_display := pix_active & ( TG.pixel != 64 );                                                                         // IS PIXEL TO DISPLAY?
    pixel := TG.pixel;                                                                                                          // PIXEL COLOUR
}

// CALCULATE NEW OFFSETS AND IF AT MIN/MAX
unit   calcoffset(
    input   int5    offset,
    input   uint4   adjust,
    output  uint1   MIN,
    output  int5    PREV,
    output  uint1   MAX,
    output  int5    NEXT
) <reginputs> {
    int6    offsetPLUS <:: { offset[4,1], offset } + adjust;                                                                    // PRESENT OFFSET PLUS ADJUSTMENT
    int6    offsetMINUS <:: { offset[4,1], offset } - adjust;                                                                   // PRESENT OFFSET MINUS ADJUSTMENT

    MIN := ( offsetMINUS < -15 );                                                                                               // MOVE TO PREVIOUS?
    MAX := ( offsetPLUS > 15 );                                                                                                 // MOVE TO NEXT?
    PREV := offsetMINUS + ( MIN ? 16 : 0 );                                                                                     // NEW ADJUSTMENT IF MOVED TO NEXT TILE ( MINIMUM )
    NEXT := offsetPLUS - ( MAX ? 16 : 0 );                                                                                      // NEW ADJUSTMENT IF MOVED TO NEXT TILE ( MAXIMUM )
}
unit tile_map_writer(
    dualport_bram_port1 tiles,

    // Set TM at x, y, character with foreground, background and rotation
    input   uint6   tm_x,
    input   uint6   tm_y,
    input   uint6   tm_character,
    input   uint3   tm_actions,
    input   uint1   tm_write,
    output  uint9   tm_read,

    // For scrolling/wrapping
    output  uint6   base_x(0),
    output  uint6   base_y(0),
    output  int5    tm_offset_x(0),
    output  int5    tm_offset_y(0),

    input   uint3   tm_scrollwrap,
    input   uint4   tm_adjust,
    output  uint4   tm_lastaction,
    output  uint1   tm_active
) <reginputs> {
    calcoffset TMOX( offset <: tm_offset_x, adjust <: tm_adjust );                                                              // X TILEMAP COORDINATE
    calcoffset TMOY( offset <: tm_offset_y, adjust <: tm_adjust );                                                              // Y TILEMAP COORDINATE

    tiles.wdata1 := tm_active ? 0 : { tm_actions, tm_character };                                                               // SET TILEMAP WRITE TO 0 FOR CLEAR OR TO CPU INPUT
    tiles.wenable1 := tm_write | tm_active;                                                                                     // SET TILEMAP WRITE FLAG
    tm_read := tiles.rdata1;                                                                                                    // RETURN PRESENT TILEMAP LOCATION DATA

    algorithm <autorun> {
        uint6   tmxpb <:: ( tm_x + base_x );            uint6   tmypb <:: ( tm_y + base_y );                                    // FIND TILEMAP X and Y COORDINATES
        uint13  tmcsaddr = uninitialized;               uint13  tmcsNEXT <:: tmcsaddr + 1;                                      // CLEAR TILEMAP ADDRESS, NEXT ADDRESS FOR CLEAR TILEMAP

        uint6   bx_m1 <:: base_x - 1;                   uint6   bx_p1 <:: base_x + 1;
        uint6   by_m1 <:: base_y - 1;                   uint6   by_p1 <:: base_y + 1;

        while(1) {
            if( tm_active ) {                                                                                                   // HANDLE TILEMAP CLEAR
                if( tmcsaddr[12,1] ) { tm_active = 0; } else { tiles.addr1 = tmcsaddr; tmcsaddr = tmcsNEXT; }
            } else {
                tiles.addr1 = { tmypb, tmxpb };                                                                                 // SET TILEMAP ADDRESS TO X AND Y FROM CPU
            }

            if( |tm_scrollwrap ) { tm_lastaction = 0; }                                                                         // SET LASTACTION TO 0 IF REQUEST FROM CPU

            switch( tm_scrollwrap ) {                                                                                           // HANDLE CPU SCROLL/CLEAR/RESET REQUESTS FROM CPU
                case 0: {}
                case 1: {                                                                                                       // MOVE LEFT
                    if( TMOX.MAX ) { base_x = &base_x ? 0 : bx_p1; tm_lastaction = 1; }
                    tm_offset_x = TMOX.NEXT;
                }
                case 2: {                                                                                                       // MOVE UP
                    if( TMOY.MAX ) { base_y = &base_y ? 0 : by_p1; tm_lastaction = 2; }
                    tm_offset_y = TMOY.NEXT;
                }
                case 3: {                                                                                                       // MOVE RIGHT
                    if( TMOX.MIN ) { base_x = ( ~|base_x ) ? 63 : bx_m1; tm_lastaction = 3; }
                    tm_offset_x = TMOX.PREV;
                }
                case 4: {                                                                                                       // MOVE DOWN
                    if( TMOY.MIN ) { base_y = ( ~|base_y ) ? 63 : by_m1; tm_lastaction = 4; }
                    tm_offset_y = TMOY.PREV;
                }
                case 5: { tm_active = 1; tmcsaddr = 0; base_x = 0; base_y = 0; tm_offset_x = 0; tm_offset_y = 0; }              // START CLEAR
                case 6: { base_x = tm_x; base_y = tm_y; }                                                                       // SET BASE
                case 7: { tm_offset_x = 0; tm_offset_y = 0; }                                                                   // RESET OFFSET
            }
        }
    }
}
