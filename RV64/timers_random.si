// Create seconds and milliseconds since boot
// Create 1hz (1 second counter)
unit timesinceboot(
    output  uint64  counter1hz(0),
    output  uint20  counter1mhz(0),
    input   uint64  newtime,
    input   uint1   resettime
) <reginputs> {
    uint5   counter25mhz = uninitialised;
    uint64  counter1hzp1 <:: counter1hz + 1;

    always_after {
        uint1   MIN = ( ~|counter25mhz );
        uint1   MAX = ( counter1mhz == 1000000 );

        if( resettime ) {
            counter1hz = newtime;
            counter1mhz = 0;
            counter25mhz = 0;
        } else {
            switch( { MAX, MIN } ) {
                case 2b00: { counter25mhz = counter25mhz - 1; }
                case 2b01: { counter1mhz = counter1mhz + 1; counter25mhz = 25; }
                case 2b10: { counter1hz = counter1hzp1; counter1mhz =  0; }
                case 2b11: { counter1hz = counter1hzp1; counter1mhz = 0; counter25mhz = counter25mhz - 1; }
            }
        }
    }
}

// Create 1hz (1 second counter)
unit pulse1hz(
    output  uint16  counter1hz(0),
    input   uint1   resetCounter
) <reginputs> {
    uint25  counter25mhz = uninitialised;

    always_after {
        uint1   MIN = ( ~|counter25mhz );

        if( resetCounter ) {
            counter1hz = 0; counter25mhz = 25000000;
        } else {
            if( MIN ) { counter1hz = counter1hz + 1; counter25mhz = 25000000; } else { counter25mhz = counter25mhz - 1; }
        }
    }
}

// Create 1khz (1 milli-second counter)
unit pulse1khz(
    output  uint16  counter1khz(0),
    input   uint16  resetCounter
) <reginputs> {
    uint15  counter25mhz = uninitialised;

    always_after {
        uint1   MIN = ( ~|counter25mhz );
        uint1   RESET = ( |resetCounter );

        if( RESET ) {
            counter1khz = resetCounter; counter25mhz = 25000;
        } else {
            if( MIN ) { if( |counter1khz) { counter1khz = counter1khz - 1; } counter25mhz = 25000; } else { counter25mhz = counter25mhz - 1; }
        }
    }
}

// 16 bit random number generator
// Translation into Silice of LFSR_Plus.v
unit random(
    output  uint16  g_noise_out,
    output  uint16  u_noise_out,
) <reginputs> {
    uint16  rand_ff(24b011000110111011010011101);
    uint18  rand_en_ff(24b001100010011011101100101);

    always_after {
        uint16  temp_u_noise3 = uninitialised;
        uint16  temp_u_noise2 = uninitialised;
        uint16  temp_u_noise1 = uninitialised;
        uint16  temp_u_noise0 = uninitialised;

         temp_u_noise0 = temp_u_noise1; temp_u_noise1 = temp_u_noise2; temp_u_noise2 = temp_u_noise3; temp_u_noise3 = { rand_ff[15,1], rand_ff[15,1], rand_ff[2,13] };
         g_noise_out = ( rand_en_ff[17,1] ) ? ( temp_u_noise3 + temp_u_noise2 + temp_u_noise1 + temp_u_noise0 + ( rand_en_ff[9,1] ? g_noise_out : 0 ) ) :
                       ( rand_en_ff[10,1] ) ? rand_ff : g_noise_out;
         u_noise_out = ( rand_en_ff[17,1] ) ? rand_ff : u_noise_out;
         rand_en_ff = { ( rand_en_ff[7,1] ^ rand_en_ff[0,1] ), rand_en_ff[1,17] };
         rand_ff = { ( rand_ff[5,1] ^ rand_ff[3,1] ^ rand_ff[2,1] ^ rand_ff[0,1] ), rand_ff[1,15] };
    }
}
