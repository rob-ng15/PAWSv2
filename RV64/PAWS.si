$$if ICARUS or VERILATOR then
// PLL for simulation
unit pll(
  output  uint1 video_clock,
  output! uint1 sdram_clock,
  output! uint1 clock_decode,
  output  uint1 compute_clock
) {
  uint3 counter = 0;
  uint8 trigger = 8b11111111;
  sdram_clock   := clock;
  clock_decode   := clock;
  compute_clock := ~counter[0,1]; // x2 slower
  video_clock   := counter[1,1]; // x4 slower
  always {
        counter = counter + 1;
        trigger = trigger >> 1;
  }
}
$$end

unit main(
    // LEDS (8 of)
    output  uint8   leds,
$$if not SIMULATION then
    input   uint$NUM_BTNS$ btns,

    // UART
    output  uint1   uart_tx,
    input   uint1   uart_rx,

    // GPIO
    input   uint28  gn,
    output  uint28  gp,

    // USB PS/2
    input   uint1   us2_bd_dp,
    input   uint1   us2_bd_dn,

    // AUDIO
    output  uint4   audio_l,
    output  uint4   audio_r,

    // SDCARD
    output  uint1   sd_clk,
    output  uint1   sd_mosi,
    output  uint1   sd_csn,
    input   uint1   sd_miso,
$$end

$$if HDMI then
    // HDMI OUTPUT
    output! uint4   gpdi_dp,
$$end
$$if VGA then
    // VGA OUTPUT
    output! uint$color_depth$ video_r,
    output! uint$color_depth$ video_g,
    output! uint$color_depth$ video_b,
    output  uint1 video_hs,
    output  uint1 video_vs,
$$end
$$if VERILATOR then
    output  uint1 video_clock,
$$end
    // SDRAM
    output! uint1  sdram_cle,
    output! uint2  sdram_dqm,
    output! uint1  sdram_cs,
    output! uint1  sdram_we,
    output! uint1  sdram_cas,
    output! uint1  sdram_ras,
    output! uint2  sdram_ba,
    output! uint13 sdram_a,
$$if VERILATOR then
    output! uint1  sdram_clock, // sdram controller clock
    input   uint16 sdram_dq_i,
    output! uint16 sdram_dq_o,
    output! uint1  sdram_dq_en,
$$else
    output uint1  sdram_clk,  // sdram chip clock != internal sdram_clock
    inout  uint16 sdram_dq,
$$end
    inout   uint1   gpdi_sda,   // i2c for rtc
    inout   uint1   gpdi_scl
) <@clock_system,reginputs> {
    uint1   clock_system = uninitialized;
    uint1   clock_system_alt = uninitialized;
    uint1   clock_cpu = uninitialized;
    uint1   clock_decode = uninitialized;
    uint1   clock_cache = uninitialized;
    uint1   clock_palette = uninitialized;
$$if VERILATOR then
    $$clock_25mhz = 'video_clock'
    // --- PLL
    pll clockgen<@clock,!reset>(
      video_clock   :> video_clock,
      sdram_clock   :> sdram_clock,
      clock_decode   :> clock_decode,
      compute_clock :> clock_system,
      compute_clock :> clock_system_alt,
      compute_clock :> clock_cpu,
      clock_decode :> clock_cache,
      compute_clock :> clock_palette,
    );
$$else
    $$clock_25mhz = 'clock'
    // CLOCK/RESET GENERATION
    // CPU + MEMORY
    uint1   sdram_clock = uninitialized;
    uint1   pll_lock_SYSTEM = uninitialized;
    ulx3s_clk_PAWS_SYSTEM clk_gen_SYSTEM (
        clkin    <: $clock_25mhz$,
        clkSYSTEM  :> clock_system,
        clkSDRAM :> sdram_clock,
        clkSYSTEMalt :> clock_system_alt,
        clkSDRAMcontrol :> sdram_clk,
        locked   :> pll_lock_SYSTEM
    );
    uint1   pll_lock_CPU = uninitialized;
    ulx3s_clk_PAWS_CPU clk_gen_CPU (
        clkin    <: $clock_25mhz$,
        clkCPU :> clock_cpu,
        clkDECODE :> clock_decode,
        clkPAL :> clock_palette,
        clkCACHE :> clock_cache,
        locked   :> pll_lock_CPU
    );
$$end

    uint2   ACCESSSIZE <:: DMA.DMAACTIVE ? DMA.DMAACCESSSIZE : CPU.accesssize;                                                  // SELECT ACTIVE BUS, DMA OR CPU    MEMORY ACCESSSIZE
    uint$addr_width$ ADDRESS <:: DMA.DMAACTIVE ? DMA.address : CPU.address;                                                     //                                  ADDRESS
    uint32  WRITEDATA <:: DMA.DMAACTIVE ? DMA.writedata : CPU.writedata;                                                        //                                  WRITEDATA
    uint1   READFLAG <:: CPU.readmemory | DMA.readmemory;                                                                       //                                  READFLAG
    uint1   WRITEFLAG <:: CPU.writememory | DMA.writememory;                                                                    //                                  WRITEFLAG


    uint$addr_width$  address2 <:: ADDRESS + 2;                                                                                 // CPU ADDRESS PLUS 2 ( second 16 bits of 32 bits )
    uint$addr_width$  address0 <:: ADDRESS[1,1] ? address2 : ADDRESS;                                                           // "LOW" 16 BITS, ADDRESS, OR ADDRESS+2 FOR ALIGNING BY 16 BIT

    uint1   SDRAM <:: ADDRESS[$addr_width-1$,1];                                                                                // CHIPSELECT   SDRAM
    uint1   BITMAPDIRECT <:: ADDRESS[$addr_width-2$,2] == 2b01;                                                                 //              FRAMEBUFFER(S)
    uint1   CMAPDIRECT <:: ADDRESS[$addr_width-3$,3] == 3b001;                                                                  //              CHARACTER MAP BUFFER
    uint1   BRAM <:: ~|ADDRESS[$addr_width-3$,3] & ~ADDRESS[15,1];                                                              //              BRAM / BIOS
    uint1   TIMERS <:: ~|ADDRESS[$addr_width-3$,3] & ADDRESS[15,1] & ( ~|ADDRESS[12,2] );                                       //              TIMER REGISTERS
    uint1   VIDEO <:: ~|ADDRESS[$addr_width-3$,3] & ADDRESS[15,1] & ( ADDRESS[12,2] == 2h1 );                                   //              VIDEO BLOCKS REGISTERS
    uint1   AUDIO <:: ~|ADDRESS[$addr_width-3$,3] & ADDRESS[15,1] & ( ADDRESS[12,2] == 2h2 );                                   //              AUDIO REGISTERS
    uint1   IO <:: ~|ADDRESS[$addr_width-3$,3] & ADDRESS[15,1] & ( &ADDRESS[12,2] );                                            //              I/O + DMA + SMT REGISTERS

    // SDRAM chip controller by @sylefeb
    uint1   sdram_reset = uninitialized; clean_reset sdram_rstcond <@sdram_clock,!reset> ( out :> sdram_reset );                // SDRAM RESET SIGNAL GENERATOR
    sdram_r16w16_io sio_fullrate; sdram_r16w16_io sio_halfrate;                                                                 // SDRAM IS 16 BIT 100MHz SDRAM CLOCK, 50MHz SYSTEM CLOCK
    sdram_half_speed_access sdaccess <@sdram_clock,!sdram_reset> ( sd <:> sio_fullrate, sdh <:> sio_halfrate );                 // SDRAM RUNS AT 100MHZ, SYSTEM AT 50MHz
    sdram_controller_autoprecharge_r16_w16 sdram32MB <@sdram_clock,!sdram_reset> (                                              // SDRAM CONTROLLER
        sd        <:> sio_fullrate,                                                                                             // CONTROL SIGNALS GO THROUGH A CLOCK GATE
        sdram_cle :>  sdram_cle,
        sdram_dqm :>  sdram_dqm,
        sdram_cs  :>  sdram_cs,
        sdram_we  :>  sdram_we,
        sdram_cas :>  sdram_cas,
        sdram_ras :>  sdram_ras,
        sdram_ba  :>  sdram_ba,
        sdram_a   :>  sdram_a,
  $$if VERILATOR then
        dq_i       <: sdram_dq_i,
        dq_o       :> sdram_dq_o,
        dq_en      :> sdram_dq_en,
  $$else
        sdram_dq  <:> sdram_dq,
  $$end
    );

    cachecontroller DRAM <@clock_system,!reset> (                                                                               // SDRAM VIA CACHE ( controls 16 BIT <-> 32 BIT )
        sio <:> sio_halfrate,
        clock_cache <: clock_cache,
        accesssize <: ACCESSSIZE,
        address <: ADDRESS[0,$addr_width-1$],
        address2 <: address2[0,$addr_width-1$],
        address0 <: address0[0,$addr_width-1$],
        writedata <: WRITEDATA
    );

    bramcontroller RAM <@clock_system,!reset> (                                                                                 // BRAM CONTROLLER
        accesssize <: ACCESSSIZE,
        address <: ADDRESS,
        address2 <: address2,
        writedata <: WRITEDATA
    );

    io_memmap IO_Map <@clock_system,!reset> (                                                                                   // I/O REGISTERS CONTROLLER
        leds :> leds,                                                                                                           //  LEDS
$$if not SIMULATION then
        gn <: gn,                                                                                                               //  GPIO
        gp :> gp,
        btns <: btns,                                                                                                           //  ULX3S BUTTONS
        uart_tx :> uart_tx,                                                                                                     //  UART
        uart_rx <: uart_rx,
        us2_bd_dp <: us2_bd_dp,                                                                                                 //  USB OTG PORT, FOR PS/2 KEYBOARD
        us2_bd_dn <: us2_bd_dn,
        sd_clk :> sd_clk,                                                                                                       //  SDCARD
        sd_mosi :> sd_mosi,
        sd_csn :> sd_csn,
        sd_miso <: sd_miso,
$$end
        gpdi_sda <:> gpdi_sda,                                                                                                  //  RTC ACCESS
        gpdi_scl <:> gpdi_scl,

        memoryAddress <: ADDRESS,                                                                                               //  MEMORY MAPPING
        writeData <: WRITEDATA,
        DMAACTIVE <: DMA.DMAACTIVE
    );

    timers_memmap TIMERS_Map <@clock_system,!reset> (                                                                           // TIMERS REGISTERS CONTROLLER
        memoryAddress <: ADDRESS[0,6],
        writeData <: WRITEDATA
    );

    $$if SIMULATION then
        uint4 audio_l(0);
        uint4 audio_r(0);
    $$end
    audio_memmap AUDIO_Map <@clock_system,!reset> (                                                                             // AUDIO REGISTERS CONTROLLER
        memoryAddress <: ADDRESS[1,5],
        writeData <: WRITEDATA,
        audio_l :> audio_l,
        audio_r :> audio_r,
        static8bit <: TIMERS_Map.static16bit[0,8]
    );

    video_memmap VIDEO_Map <@clock_system,!reset> (                                                                             // VIDEO REGISTERS AND MEMORY CONTROLLERS
        video_clock <: $clock_25mhz$,
        gpu_clock <: $clock_25mhz$,
        palette_clock <: clock_palette,
        memoryAddressDirect <: ADDRESS,
        memoryAddressDirect0 <: address0,
        accesssize <: ACCESSSIZE,
        memoryAddress <: ADDRESS[0,12],
        writeData <: WRITEDATA,
$$if HDMI then
        gpdi_dp :> gpdi_dp,
$$end
$$if VGA then
        video_r  :> video_r,
        video_g  :> video_g,
        video_b  :> video_b,
        video_hs :> video_hs,
        video_vs :> video_vs,
$$end
        staticGenerator <: TIMERS_Map.static16bit[0,10],
        blink <: TIMERS_Map.cursor,

        sdcardlightcolour <: IO_Map.sdcardlightcolour,
$$if not SIMULATION then
        sdcarderror <: IO_Map.sd_error,
$$end
        JOYSTICK <: IO_Map.JOYSTICK,
        CAPSLOCK <: IO_Map.CAPSLOCK,
        NUMLOCK <: IO_Map.NUMLOCK,
        RESETSTATUS <: IO_Map.RESETSTATUS
    );

    uint1   MEMORYBUSY <:: DRAM.busy |                                                                                          // CPU MEMORY BUSY FLAG FROM    SDRAM
                           ( ( READFLAG | WRITEFLAG ) & SDRAM ) |                                                               //                              SDRAM READ/WRITE REQUEST
                           ( READFLAG & ( BITMAPDIRECT | BRAM | CMAPDIRECT ) );                                                 //                              BRAM BUITMAP CMAP READ REQUEST
    uint32  READDATA <:: SDRAM ? DRAM.readdata :                                                                                // READ FROM SDRAM
                         BITMAPDIRECT ? VIDEO_Map.BITMAPreadDataDirect :                                                        // READ FROM FRAMEBUFFERS
                         CMAPDIRECT ? VIDEO_Map.CMAPreadDataDirect :                                                            // READ FROM CHARACTERMAP
                         BRAM ? RAM.readdata :                                                                                  // READ FROM BRAM
                         TIMERS ? TIMERS_Map.readData :                                                                         // READ FROM TIMERS
                         VIDEO ? VIDEO_Map.readData :                                                                           // READ FROM VIDEO
                         AUDIO ? AUDIO_Map.readData :                                                                           // READ FROM AUDIO
                         IO_Map.readData;                                                                                       // READ FROM I/O

    PAWSCPU CPU <@clock_cpu> (                                                                                                  // PAWS CPU
        clock_CPUdecoder <: clock_decode,                                                                                       //  100MHz DECODE CLOCK
        clock_cache <: clock_cache,                                                                                             //  100MHz CACHE CLOCK
        memorybusy <: MEMORYBUSY,
        readdata <: READDATA,
        SMTRUNNING <: IO_Map.SMTRUNNING,                                                                                        //  SMT CONTROL FROM I/O
        SMTSTARTPC <: IO_Map.SMTSTARTPC[0,27],
        DMAMODE <: IO_Map.DMAMODE,
        DMAACTIVE <: DMA.DMAACTIVE
     );

    dma DMA <@clock_system,!reset> (                                                                                            // MINI DMA CONTROLLER
        start <: CPU.DMASTART,                                                                                                  //  START FROM CPU, SURRENDERS BUS TO DMA CONTROLLER
        memorybusy <: MEMORYBUSY,                                                                                               //  MEMORY BUSY FLAG
        readdata <: READDATA,                                                                                                   //  READ RESULT
        DMASOURCE <: IO_Map.DMASOURCE,                                                                                          //  REGISTERS FROM IO MEMORY MAP
        DMASOURCEADD <: IO_Map.DMASOURCEADD,
        DMADEST <: IO_Map.DMADEST,
        DMADESTADD <: IO_Map.DMADESTADD,
        DMACOUNT <: IO_Map.DMACOUNT,
        DMACYCLES <: IO_Map.DMACYCLES,
        DMAMODE <: IO_Map.DMAMODE,
        DMASET <: IO_Map.DMASET
    );

    DRAM.readflag := SDRAM & READFLAG; DRAM.writeflag := SDRAM & WRITEFLAG;                                                     // SDRAM REQUESTS
    RAM.writeflag := BRAM & WRITEFLAG;                                                                                          // BRAM BIOS WRITE REQUEST
    IO_Map.memoryRead := IO & READFLAG; IO_Map.memoryWrite := IO & WRITEFLAG;                                                   // I/O REGISTERS REQUESTS
    TIMERS_Map.memoryRead := TIMERS & READFLAG; TIMERS_Map.memoryWrite := TIMERS & WRITEFLAG;                                   // TIMERS REGISTERS REQUESTS
    AUDIO_Map.memoryWrite := AUDIO & WRITEFLAG;                                                                                 // AUDIO REGISTERS WRITE REQUEST
    VIDEO_Map.memoryWrite := VIDEO & WRITEFLAG;                                                                                 // VIDEO REGISTERS WRITE REQUEST
    VIDEO_Map.BITMAPWriteDirect := BITMAPDIRECT & WRITEFLAG;                                                                    // FRAMEBUFFERS WRITE REQUEST
    VIDEO_Map.CMAPWriteDirect := CMAPDIRECT & WRITEFLAG;                                                                        // CHARACTER MEMORY READ REQUEST
}
