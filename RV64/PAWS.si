$$if ICARUS or VERILATOR then
// PLL for simulation
unit pll(
  output  uint1 video_clock,
  output! uint1 sdram_clock,
  output! uint1 clock_decode,
  output  uint1 compute_clock
) {
  uint3 counter = 0;
  uint8 trigger = 8b11111111;
  sdram_clock   := clock;
  clock_decode   := clock;
  compute_clock := ~counter[0,1]; // x2 slower
  video_clock   := counter[1,1]; // x4 slower
  always {
        counter = counter + 1;
        trigger = trigger >> 1;
  }
}
$$end

unit main(
    // LEDS (8 of)
    output  uint8   leds,
$$if not SIMULATION then
    input   uint$NUM_BTNS$ btns,

    // UART
    output  uint1   uart_tx,
    input   uint1   uart_rx,

    // GPIO
    input   uint28  gn,
    output  uint28  gp,

    // USB PS/2
    input   uint1   us2_bd_dp,
    input   uint1   us2_bd_dn,

    // AUDIO
    output  uint4   audio_l,
    output  uint4   audio_r,

    // SDCARD
    output  uint1   sd_clk,
    output  uint1   sd_mosi,
    output  uint1   sd_csn,
    input   uint1   sd_miso,
$$end

$$if HDMI then
    // HDMI OUTPUT
    output! uint4   gpdi_dp,
$$end
$$if VGA then
    // VGA OUTPUT
    output! uint$color_depth$ video_r,
    output! uint$color_depth$ video_g,
    output! uint$color_depth$ video_b,
    output  uint1 video_hs,
    output  uint1 video_vs,
$$end
$$if VERILATOR then
    output  uint1 video_clock,
$$end
    // SDRAM
    output! uint1  sdram_cle,
    output! uint2  sdram_dqm,
    output! uint1  sdram_cs,
    output! uint1  sdram_we,
    output! uint1  sdram_cas,
    output! uint1  sdram_ras,
    output! uint2  sdram_ba,
    output! uint13 sdram_a,
$$if VERILATOR then
    output! uint1  sdram_clock, // sdram controller clock
    input   uint16 sdram_dq_i,
    output! uint16 sdram_dq_o,
    output! uint1  sdram_dq_en,
$$else
    output uint1  sdram_clk,  // sdram chip clock != internal sdram_clock
    inout  uint16 sdram_dq,
$$end
    inout   uint1   gpdi_sda,   // i2c for rtc
    inout   uint1   gpdi_scl
) <@clock_system,reginputs> {
    uint1   clock_system = uninitialized;
    uint1   clock_system_alt = uninitialized;
    uint1   clock_cpu = uninitialized;
    uint1   clock_decode = uninitialized;
    uint1   clock_cache = uninitialized;
    uint1   clock_palette = uninitialized;
$$if VERILATOR then
    $$clock_25mhz = 'video_clock'
    // --- PLL
    pll clockgen<@clock,!reset>(
      video_clock   :> video_clock,
      sdram_clock   :> sdram_clock,
      clock_decode   :> clock_decode,
      compute_clock :> clock_system,
      compute_clock :> clock_system_alt,
      compute_clock :> clock_cpu,
      clock_decode :> clock_cache,
      compute_clock :> clock_palette,
    );
$$else
    $$clock_25mhz = 'clock'
    // CLOCK/RESET GENERATION
    // CPU + MEMORY
    uint1   sdram_clock = uninitialized;
    uint1   pll_lock_SYSTEM = uninitialized;
    ulx3s_clk_PAWS_SYSTEM clk_gen_SYSTEM (
        clkin    <: $clock_25mhz$,
        clkSYSTEM  :> clock_system,
        clkSDRAM :> sdram_clock,
        clkSYSTEMalt :> clock_system_alt,
        clkSDRAMcontrol :> sdram_clk,
        locked   :> pll_lock_SYSTEM
    );
    uint1   pll_lock_CPU = uninitialized;
    ulx3s_clk_PAWS_CPU clk_gen_CPU (
        clkin    <: $clock_25mhz$,
        clkCPU :> clock_cpu,
        clkDECODE :> clock_decode,
        clkPAL :> clock_palette,
        clkCACHE :> clock_cache,
        locked   :> pll_lock_CPU
    );
$$end

    // IDENTIFY ADDRESS BLOCK
    uint1   SDRAM <: CPU.address[$addr_width-1$,1];
    uint1   VIDEODIRECT <: ~SDRAM & CPU.address[$addr_width-2$,1];
    uint1   BRAM <: ~SDRAM & ~VIDEODIRECT & ~CPU.address[15,1];
    uint1   IOmem <: ~SDRAM & ~VIDEODIRECT & ~BRAM;
    uint1   TIMERS <: IOmem & ( ~|CPU.address[12,2] );
    uint1   VIDEO <: IOmem & ( CPU.address[12,2] == 2h1 );
    uint1   AUDIO <: IOmem & ( CPU.address[12,2] == 2h2 );
    uint1   IO <: IOmem & ( &CPU.address[12,2] );

    // SDRAM Reset
    uint1   sdram_reset = uninitialized; clean_reset sdram_rstcond <@sdram_clock,!reset> ( out :> sdram_reset );

    // SDRAM chip controller by @sylefeb
    sdram_r16w16_io sio_fullrate; sdram_r16w16_io sio_halfrate;
    sdram_half_speed_access sdaccess <@sdram_clock,!sdram_reset> ( sd <:> sio_fullrate, sdh <:> sio_halfrate );
    sdram_controller_autoprecharge_r16_w16 sdram32MB <@sdram_clock,!sdram_reset> (
        sd        <:> sio_fullrate,
        sdram_cle :>  sdram_cle,
        sdram_dqm :>  sdram_dqm,
        sdram_cs  :>  sdram_cs,
        sdram_we  :>  sdram_we,
        sdram_cas :>  sdram_cas,
        sdram_ras :>  sdram_ras,
        sdram_ba  :>  sdram_ba,
        sdram_a   :>  sdram_a,
  $$if VERILATOR then
        dq_i       <: sdram_dq_i,
        dq_o       :> sdram_dq_o,
        dq_en      :> sdram_dq_en,
  $$else
        sdram_dq  <:> sdram_dq,
  $$end
    );

    // SDRAM ( via CACHE )
    uint1   DRAMreadflag <: SDRAM & CPU.readmemory;
    uint1   DRAMwriteflag <: SDRAM & CPU.writememory;
    cachecontroller DRAM <@clock_system,!reset> (
        sio <:> sio_halfrate,
        clock_cache <: clock_cache,
        accesssize <: CPU.accesssize,
        cacheselect <: CPU.cacheselect,
        address <: CPU.address[0,$addr_width-1$],
        writedata <: CPU.writedata,
        writeflag <: DRAMwriteflag,
        readflag <: DRAMreadflag
    );

    // BRAM (for BIOS AND FAST BRAM ) SELECT BIOS FOR FPGA OR SIMULATION
    uint1   RAMwriteflag <: BRAM & CPU.writememory;
    bramcontroller RAM <@clock_system,!reset> (
        accesssize <: CPU.accesssize,
        address <: CPU.address[0,15],
        writedata <: CPU.writedata,
        writeflag <: RAMwriteflag
    );

    // MEMORY MAPPED I/O + SMT CONTROLS
    // 16 bit cache memory bus, 0 I cache, 16384 D cache
    uint1   IO_MapmemoryRead <: IO & CPU.readmemory;
    uint1   IO_MapmemoryWrite <: IO & CPU.writememory;
    io_memmap IO_Map <@clock_system,!reset> (
        leds :> leds,
$$if not SIMULATION then
        gn <: gn,
        gp :> gp,
        btns <: btns,
        uart_tx :> uart_tx,
        uart_rx <: uart_rx,
        us2_bd_dp <: us2_bd_dp,
        us2_bd_dn <: us2_bd_dn,
        sd_clk :> sd_clk,
        sd_mosi :> sd_mosi,
        sd_csn :> sd_csn,
        sd_miso <: sd_miso,
$$end
        gpdi_sda <:> gpdi_sda,
        gpdi_scl <:> gpdi_scl,

        clock_25mhz <: $clock_25mhz$,

        accesssize <: CPU.accesssize,
        memoryAddress <: CPU.address[0,12],
        writeData <: CPU.writedata,
        memoryWrite <: IO_MapmemoryWrite,
        memoryRead <: IO_MapmemoryRead,
        DMAACTIVE <: CPU.DMAACTIVE,
    );

    uint1   TIMERS_MapmemoryRead <: TIMERS & CPU.readmemory;
    uint1   TIMERS_MapmemoryWrite <: TIMERS & CPU.writememory;
    timers_memmap TIMERS_Map <@clock_system,!reset> (
        clock_25mhz <: $clock_25mhz$,
        memoryAddress <: CPU.address[0,6],
        writeData <: CPU.writedata,
        memoryWrite <: TIMERS_MapmemoryWrite,
        memoryRead <: TIMERS_MapmemoryRead
    );

    $$if SIMULATION then
        uint4 audio_l(0);
        uint4 audio_r(0);
    $$end
    uint1   AUDIO_MapmemoryWrite <: AUDIO & CPU.writememory;
    audio_memmap AUDIO_Map <@clock_system,!reset> (
        clock_25mhz <: $clock_25mhz$,
        memoryAddress <: CPU.address[0,5],
        accesssize <: CPU.accesssize,
        writeData <: CPU.writedata,
        memoryWrite <: AUDIO_MapmemoryWrite,
        audio_l :> audio_l,
        audio_r :> audio_r,
        static8bit <: TIMERS_Map.static16bit[0,8]
    );

    uint1   VIDEO_MapmemoryWrite <: VIDEO & CPU.writememory;
    uint1   VIDEO_MapmemoryWriteDirect <: VIDEODIRECT & CPU.writememory;
    video_memmap VIDEO_Map <@clock_system,!reset> (
        video_clock <: $clock_25mhz$,
        gpu_clock <: $clock_25mhz$,
        palette_clock <: clock_palette,
        memoryAddressDirect <: CPU.address,
        accesssize <: CPU.accesssize,
        memoryAddress <: CPU.address[0,12],
        writeData <: CPU.writedata,
        memoryWrite <: VIDEO_MapmemoryWrite,
        memoryWriteDirect <: VIDEO_MapmemoryWriteDirect,
$$if HDMI then
        gpdi_dp :> gpdi_dp,
$$end
$$if VGA then
        video_r  :> video_r,
        video_g  :> video_g,
        video_b  :> video_b,
        video_hs :> video_hs,
        video_vs :> video_vs,
$$end
        static8bit <: TIMERS_Map.static16bit[0,8],
        blink <: TIMERS_Map.cursor,

        sdcardlightcolour <: IO_Map.sdcardlightcolour,
        JOYSTICK <: IO_Map.JOYSTICK,
        CAPSLOCK <: IO_Map.CAPSLOCK,
        NUMLOCK <: IO_Map.NUMLOCK,
        RESETSTATUS <: IO_Map.RESETSTATUS
    );

    // LINK CPU TO MEMORY CONTROLLERS
    uint1   memorybusy <: DRAM.busy | ( ( CPU.readmemory | CPU.writememory ) & SDRAM ) | ( CPU.readmemory & BRAM ) | ( ( CPU.readmemory | CPU.writememory ) & VIDEODIRECT );
    //uint1   memorybusy <: DRAM.busy | ( ( CPU.readmemory | CPU.writememory ) & ( SDRAM ) ) | ( CPU.readmemory & ( VIDEODIRECT | BRAM ) );
    uint32  readdata <: SDRAM ? DRAM.readdata :
                                VIDEODIRECT ? VIDEO_Map.readDataDirect :
                                BRAM ? RAM.readdata :
                                TIMERS ? TIMERS_Map.readData :
                                VIDEO ? VIDEO_Map.readData :
                                AUDIO ? AUDIO_Map.readData :
                                IO ? IO_Map.readData : 0;
    PAWSCPU CPU <@clock_cpu> (
        clock_CPUdecoder <: clock_decode,
        clock_cache <: clock_cache,
        memorybusy <: memorybusy,
        readdata <: readdata,
        SMTRUNNING <: IO_Map.SMTRUNNING,
        SMTSTARTPC <: IO_Map.SMTSTARTPC[0,27],
        DMASOURCE <: IO_Map.DMASOURCE,
        DMASOURCEADD <: IO_Map.DMASOURCEADD,
        DMADEST <: IO_Map.DMADEST,
        DMADESTADD <: IO_Map.DMADESTADD,
        DMACOUNT <: IO_Map.DMACOUNT,
        DMACYCLES <: IO_Map.DMACYCLES,
        DMASET <: IO_Map.DMASET,
        DMAMODE <: IO_Map.DMAMODE
    );
}

// RAM - 32 bit BRAM controller
$$if not SIMULATION then
$$ brambits = 12
$$else
$$ brambits = 13
$$end
unit bramcontroller(
    input   uint$brambits$  address,
    input   uint2   accesssize,
    input   uint1   writeflag,
    input   uint32  writedata,
    output  uint32  readdata
) <reginputs> {
    $$config['dualport_bram_wmask_byte_wenable0_width'] = 'data'
    $$config['dualport_bram_wmask_byte_wenable1_width'] = 'data'
    $$if not SIMULATION then
        dualport_bram uint16 ram <"dualport_bram_wmask_byte"> [2048] = {file("ROM/BIOS.bin"), pad(uninitialized)};              // RISC-V BIOS ( 4k of BRAM )
    $$else
        dualport_bram uint16 ram <"dualport_bram_wmask_byte"> [4096] = {file("ROM/VBIOS.bin"), pad(uninitialized)};             // RISC-V BIOS FOR VERILATOR - TEST FOR SMT AND FPU ( 8k of BRAM )
    $$end

    ram.wenable0 := 0; ram.addr0 := address[1,$brambits-1$];                                                                    // BRAM FLAGS ram0 lower 16 bits
    ram.wenable1 := 0; ram.addr1 := address[1,$brambits-1$] + 1;                                                                // BRAM FLAGS ram1 upper 16 bits ( next address )
    readdata := { ram.rdata1, ram.rdata0 };                                                                                     // COMBINE { ram1, ram0 } for 32 bit read
    ram.wdata0 := writedata[0,16];                                                                                              // ram0 16/32 bit write lower 16 bits ( default )
    ram.wdata1 := writedata[16,16];                                                                                             // ram1 32 bit write upper 16 bits

    always_after {
        if( writeflag ) {                                                                                                       // BRAM write
            switch( accesssize ) {
                case 2b00: { ram.wdata0 = { {2{writedata[0,8]}} }; ram.wenable0 = address[0,1] ? 2b10 : 2b01; }                 // 8 bit, duplicate and write to correct part of ram0
                case 2b01: { ram.wenable0 = 2b11; }                                                                             // 16 bit
                default: { ram.wenable1 = 2b11; }                                                                               // 32/64 bit
            }
        }
    }
}
