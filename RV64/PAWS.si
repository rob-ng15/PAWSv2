$$if ICARUS or VERILATOR then
// PLL for simulation
unit pll(
  output  uint1 video_clock,
  output! uint1 sdram_clock,
  output! uint1 clock_decode,
  output  uint1 compute_clock
) {
  uint3 counter = 0;
  uint8 trigger = 8b11111111;
  sdram_clock   := clock;
  clock_decode   := clock;
  compute_clock := ~counter[0,1]; // x2 slower
  video_clock   := counter[1,1]; // x4 slower
  always {
        counter = counter + 1;
        trigger = trigger >> 1;
  }
}
$$end

unit main(
    // LEDS (8 of)
    output  uint8   leds,
$$if not SIMULATION then
    input   uint$NUM_BTNS$ btns,

    // UART
    output  uint1   uart_tx,
    input   uint1   uart_rx,

    // GPIO
    input   uint28  gn,
    output  uint28  gp,

    // USB PS/2
    input   uint1   us2_bd_dp,
    input   uint1   us2_bd_dn,

    // AUDIO
    output  uint4   audio_l,
    output  uint4   audio_r,

    // SDCARD
    output  uint1   sd_clk,
    output  uint1   sd_mosi,
    output  uint1   sd_csn,
    input   uint1   sd_miso,
$$end

$$if HDMI then
    // HDMI OUTPUT
    output! uint4   gpdi_dp,
$$end
$$if VGA then
    // VGA OUTPUT
    output! uint$color_depth$ video_r,
    output! uint$color_depth$ video_g,
    output! uint$color_depth$ video_b,
    output  uint1 video_hs,
    output  uint1 video_vs,
$$end
$$if VERILATOR then
    output  uint1 video_clock,
$$end
    // SDRAM
    output! uint1  sdram_cle,
    output! uint2  sdram_dqm,
    output! uint1  sdram_cs,
    output! uint1  sdram_we,
    output! uint1  sdram_cas,
    output! uint1  sdram_ras,
    output! uint2  sdram_ba,
    output! uint13 sdram_a,
$$if VERILATOR then
    output! uint1  sdram_clock, // sdram controller clock
    input   uint16 sdram_dq_i,
    output! uint16 sdram_dq_o,
    output! uint1  sdram_dq_en,
$$else
    output uint1  sdram_clk,  // sdram chip clock != internal sdram_clock
    inout  uint16 sdram_dq,
$$end
    inout   uint1   gpdi_sda,   // i2c for rtc
    inout   uint1   gpdi_scl
) <@clock_system,reginputs> {
    uint1   clock_system = uninitialized;
    uint1   clock_system_alt = uninitialized;
    uint1   clock_cpu = uninitialized;
    uint1   clock_decode = uninitialized;
    uint1   clock_cache = uninitialized;
    uint1   clock_palette = uninitialized;
$$if VERILATOR then
    $$clock_25mhz = 'video_clock'
    // --- PLL
    pll clockgen<@clock,!reset>(
      video_clock   :> video_clock,
      sdram_clock   :> sdram_clock,
      clock_decode   :> clock_decode,
      compute_clock :> clock_system,
      compute_clock :> clock_system_alt,
      compute_clock :> clock_cpu,
      clock_decode :> clock_cache,
      compute_clock :> clock_palette,
    );
$$else
    $$clock_25mhz = 'clock'
    // CLOCK/RESET GENERATION
    // CPU + MEMORY
    uint1   sdram_clock = uninitialized;
    uint1   pll_lock_SYSTEM = uninitialized;
    ulx3s_clk_PAWS_SYSTEM clk_gen_SYSTEM (
        clkin    <: $clock_25mhz$,
        clkSYSTEM  :> clock_system,
        clkSDRAM :> sdram_clock,
        clkSYSTEMalt :> clock_system_alt,
        clkSDRAMcontrol :> sdram_clk,
        locked   :> pll_lock_SYSTEM
    );
    uint1   pll_lock_CPU = uninitialized;
    ulx3s_clk_PAWS_CPU clk_gen_CPU (
        clkin    <: $clock_25mhz$,
        clkCPU :> clock_cpu,
        clkDECODE :> clock_decode,
        clkPAL :> clock_palette,
        clkCACHE :> clock_cache,
        locked   :> pll_lock_CPU
    );
$$end

    uint$addr_width$  address2 <: CPU.address + 2;                                                                              // CPU ADDRESS PLUS 2 ( second 16 bits of 32 bits )
    uint1   SDRAM <: CPU.address[$addr_width-1$,1];                                                                             //  SDRAM
    uint1   BITMAPDIRECT <: CPU.address[$addr_width-2$,2] == 2b01;                                                              //  FRAMEBUFFER(S)
    uint1   CMAPDIRECT <: CPU.address[$addr_width-3$,3] == 3b001;                                                               //  CHARACTER MAP
    uint1   BRAM <: ~|CPU.address[$addr_width-3$,3] & ~CPU.address[15,1];                                                       //  BRAM / BIOS
    uint1   TIMERS <: ~|CPU.address[$addr_width-3$,3] & CPU.address[15,1] & ( ~|CPU.address[12,2] );                            //  TIMER REGISTERS
    uint1   VIDEO <: ~|CPU.address[$addr_width-3$,3] & CPU.address[15,1] & ( CPU.address[12,2] == 2h1 );                        //  VIDEO BLOCKS REGISTERS
    uint1   AUDIO <: ~|CPU.address[$addr_width-3$,3] & CPU.address[15,1] & ( CPU.address[12,2] == 2h2 );                        //  AUDIO REGISTERS
    uint1   IO <: ~|CPU.address[$addr_width-3$,3] & CPU.address[15,1] & ( &CPU.address[12,2] );                                 //  I/O + DMA + SMT REGISTERS

    // SDRAM chip controller by @sylefeb
    uint1   sdram_reset = uninitialized; clean_reset sdram_rstcond <@sdram_clock,!reset> ( out :> sdram_reset );                // SDRAM RESET SIGNAL
    sdram_r16w16_io sio_fullrate; sdram_r16w16_io sio_halfrate;                                                                 // SDRAM IS 16 BIT FOR READ AND WRITE
    sdram_half_speed_access sdaccess <@sdram_clock,!sdram_reset> ( sd <:> sio_fullrate, sdh <:> sio_halfrate );                 // SDRAM RUNS AT 100MHZ, SYSTEM AT 50MHz
    sdram_controller_autoprecharge_r16_w16 sdram32MB <@sdram_clock,!sdram_reset> (                                              // SDRAM CONTROLLER
        sd        <:> sio_fullrate,
        sdram_cle :>  sdram_cle,
        sdram_dqm :>  sdram_dqm,
        sdram_cs  :>  sdram_cs,
        sdram_we  :>  sdram_we,
        sdram_cas :>  sdram_cas,
        sdram_ras :>  sdram_ras,
        sdram_ba  :>  sdram_ba,
        sdram_a   :>  sdram_a,
  $$if VERILATOR then
        dq_i       <: sdram_dq_i,
        dq_o       :> sdram_dq_o,
        dq_en      :> sdram_dq_en,
  $$else
        sdram_dq  <:> sdram_dq,
  $$end
    );

    uint1   DRAMreadflag <: SDRAM & CPU.readmemory;                                                                             // SDRAM READ REQUEST
    uint1   DRAMwriteflag <: SDRAM & CPU.writememory;                                                                           // SDRAM WRITE REQUEST
    uint$addr_width$  address0 <: CPU.address[1,1] ? CPU.address + 2 : CPU.address;                                             // "LOW" 16 BITS, ADDRESS, OR ADDRESS+2 IF MISALIGNED
    cachecontroller DRAM <@clock_system,!reset> (                                                                               // SDRAM VIA CACHE ( controls 16 BIT <-> 32 BIT )
        sio <:> sio_halfrate,
        clock_cache <: clock_cache,
        accesssize <: CPU.accesssize,
        cacheselect <: CPU.cacheselect,
        address <: CPU.address[0,$addr_width-1$],
        address2 <: address2[0,$addr_width-1$],
        address0 <: address0[0,$addr_width-1$],
        writedata <: CPU.writedata,
        writeflag <: DRAMwriteflag,
        readflag <: DRAMreadflag
    );

    uint1   RAMwriteflag <:: BRAM & CPU.writememory;                                                                            // BRAM BIOS READ REQUEST
    bramcontroller RAM <@clock_system,!reset> (                                                                                 // BRAM CONTROLLER
        accesssize <: CPU.accesssize,
        address <: CPU.address,
        address2 <: address2,
        writedata <: CPU.writedata,
        writeflag <: RAMwriteflag
    );

    uint1   IO_MapmemoryRead <: IO & CPU.readmemory;                                                                            // I/O REGISTERS READ REQUEST
    uint1   IO_MapmemoryWrite <:: IO & CPU.writememory;                                                                         // I/O REGISTERS WRITE REQUEST
    io_memmap IO_Map <@clock_system,!reset> (                                                                                   // I/O REGISTERS CONTROLLER
        leds :> leds,
$$if not SIMULATION then
        gn <: gn,
        gp :> gp,
        btns <: btns,
        uart_tx :> uart_tx,
        uart_rx <: uart_rx,
        us2_bd_dp <: us2_bd_dp,
        us2_bd_dn <: us2_bd_dn,
        sd_clk :> sd_clk,
        sd_mosi :> sd_mosi,
        sd_csn :> sd_csn,
        sd_miso <: sd_miso,
$$end
        gpdi_sda <:> gpdi_sda,
        gpdi_scl <:> gpdi_scl,

        memoryAddress <: CPU.address,
        writeData <: CPU.writedata,
        memoryWrite <: IO_MapmemoryWrite,
        memoryRead <: IO_MapmemoryRead,
        DMAACTIVE <: CPU.DMAACTIVE,
    );

    uint1   TIMERS_MapmemoryRead <: TIMERS & CPU.readmemory;                                                                    // TIMERS REGISTERS READ REQUEST
    uint1   TIMERS_MapmemoryWrite <:: TIMERS & CPU.writememory;                                                                 // TIMERS REGISTERS WRITE REQUEST
    timers_memmap TIMERS_Map <@clock_system,!reset> (                                                                           // TIMERS REGISTERS CONTROLLER
        memoryAddress <: CPU.address[0,6],
        writeData <: CPU.writedata,
        memoryWrite <: TIMERS_MapmemoryWrite,
        memoryRead <: TIMERS_MapmemoryRead
    );

    $$if SIMULATION then
        uint4 audio_l(0);
        uint4 audio_r(0);
    $$end
    uint1   AUDIO_MapmemoryWrite <:: AUDIO & CPU.writememory;                                                                   // AUDIO REGISTERS WRITE REQUEST
    audio_memmap AUDIO_Map <@clock_system,!reset> (                                                                             // AUDIO REGISTERS CONTROLLER
        memoryAddress <: CPU.address[1,5],
        writeData <: CPU.writedata,
        memoryWrite <: AUDIO_MapmemoryWrite,
        audio_l :> audio_l,
        audio_r :> audio_r,
        static8bit <: TIMERS_Map.static16bit[0,8]
    );

    uint1   VIDEO_MapmemoryWrite <:: VIDEO & CPU.writememory;                                                                   // VIDEO REGISTERS WRITE REQUEST
    uint1   VIDEO_BITMAP_WriteDirect <: BITMAPDIRECT & CPU.writememory;                                                         // FRAMEBUFFERS WRITE REQUEST
    uint1   VIDEO_CMAP_WriteDirect <: CMAPDIRECT & CPU.writememory;                                                             // CHARACTER MEMORY READ REQUEST
    video_memmap VIDEO_Map <@clock_system,!reset> (                                                                             // VIDEO REGISTERS AND MEMORY CONTROLLERS
        video_clock <: $clock_25mhz$,
        gpu_clock <: $clock_25mhz$,
        palette_clock <: clock_palette,
        memoryAddressDirect <: CPU.address,
        memoryAddressDirect0 <: address0,
        accesssize <: CPU.accesssize,
        memoryAddress <: CPU.address[0,12],
        writeData <: CPU.writedata,
        memoryWrite <: VIDEO_MapmemoryWrite,
        BITMAPWriteDirect <: VIDEO_BITMAP_WriteDirect,
        CMAPWriteDirect <: VIDEO_CMAP_WriteDirect,
$$if HDMI then
        gpdi_dp :> gpdi_dp,
$$end
$$if VGA then
        video_r  :> video_r,
        video_g  :> video_g,
        video_b  :> video_b,
        video_hs :> video_hs,
        video_vs :> video_vs,
$$end
        staticGenerator <: TIMERS_Map.static16bit[0,10],
        blink <: TIMERS_Map.cursor,

        sdcardlightcolour <: IO_Map.sdcardlightcolour,
        JOYSTICK <: IO_Map.JOYSTICK,
        CAPSLOCK <: IO_Map.CAPSLOCK,
        NUMLOCK <: IO_Map.NUMLOCK,
        RESETSTATUS <: IO_Map.RESETSTATUS
    );

    uint1   memorybusy <: DRAM.busy |                                                                                           // SDRAM BUSY
                          ( ( CPU.readmemory | CPU.writememory ) & SDRAM ) |                                                    // READ/WRITE REQUEST SIGNAL BUSY IF SDRAM
                          ( CPU.readmemory & ( BITMAPDIRECT | BRAM | CMAPDIRECT ) );                                            // READ REQUEST SIGNAL BUSY IF FRAMEBUFFERS CHARACTERMAP OR BRAM
    uint32  readdata <: SDRAM ? DRAM.readdata :                                                                                 // READ FROM SDRAM
                        BITMAPDIRECT ? VIDEO_Map.BITMAPreadDataDirect :                                                         // READ FROM FRAMEBUFFERS
                        CMAPDIRECT ? VIDEO_Map.CMAPreadDataDirect :                                                             // READ FROM CHARACTERMAP
                        BRAM ? RAM.readdata :                                                                                   // READ FROM BRAM
                        TIMERS ? TIMERS_Map.readData :                                                                          // READ FROM TIMERS
                        VIDEO ? VIDEO_Map.readData :                                                                            // READ FROM VIDEO
                        AUDIO ? AUDIO_Map.readData :                                                                            // READ FROM AUDIO
                        IO ? IO_Map.readData : 0;                                                                               // READ FROM I/O
    PAWSCPU CPU <@clock_cpu> (                                                                                                  // PAWS CPU
        clock_CPUdecoder <: clock_decode,                                                                                       //  100MHz DECODE CLOCK
        clock_cache <: clock_cache,                                                                                             //  100MHz CACHE CLOCK
        memorybusy <: memorybusy,                                                                                               //  MEMORY BUSY FLAG
        readdata <: readdata,                                                                                                   //  MEMORY READ RESULT ( 32 bit )
        SMTRUNNING <: IO_Map.SMTRUNNING,                                                                                        //  SMT CONTROL FROM I/O
        SMTSTARTPC <: IO_Map.SMTSTARTPC[0,27],
        DMASOURCE <: IO_Map.DMASOURCE,                                                                                          //  DMA CONTROL FROM I/O
        DMASOURCEADD <: IO_Map.DMASOURCEADD,
        DMADEST <: IO_Map.DMADEST,
        DMADESTADD <: IO_Map.DMADESTADD,
        DMACOUNT <: IO_Map.DMACOUNT,
        DMACYCLES <: IO_Map.DMACYCLES,
        DMASET <: IO_Map.DMASET,
        DMAMODE <: IO_Map.DMAMODE
    );
}

// RAM - BRAM controller
unit bramcontroller(
    input   uint12  address,
    input   uint12  address2,
    input   uint2   accesssize,
    input   uint1   writeflag,
    input   uint32  writedata,
    output  uint32  readdata
) <reginputs> {
    $$config['dualport_bram_wmask_byte_wenable0_width'] = 'data'
    $$config['dualport_bram_wmask_byte_wenable1_width'] = 'data'
    $$if not SIMULATION then
        dualport_bram uint16 ram <"dualport_bram_wmask_byte"> [2048] = {file("ROM/BIOS.bin"), pad(uninitialized)};              // BIOS WITH I/O
    $$else
        dualport_bram uint16 ram <"dualport_bram_wmask_byte"> [2048] = {file("ROM/VBIOS.bin"), pad(uninitialized)};             // BIOS FOR VERILATOR
    $$end

    ram.wenable0 := 0; ram.addr0 := address[1,11]; ram.wenable1 := 0; ram.addr1 := address2[1,11];                              // BRAM FLAGS, ram0 LOW 16 BITS, ram1 HIGH 16 BITS
    ram.wdata0 := ~|accesssize ? { {2{writedata[0,8]}} } : writedata[0,16];                                                     // ram0 LOW, 8 bit duplicate, else lower 16 bits
    ram.wdata1 := writedata[16,16];                                                                                             // ram1 HIGH 16 bits

    readdata := { ram.rdata1, ram.rdata0 };                                                                                     // READ 32 BITS, COMBINE ram1 HIGH AND ram0 LOW

    always_after {
        if( writeflag ) {
            switch( accesssize ) {
                case 2b00: { ram.wenable0 = { address[0,1], ~address[0,1] }; }                                                  // 8 BIT WRITE
                default: { ram.wenable0 = 2b11; ram.wenable1 = {2{accesssize[1,1]}}; }                                          // 16,32,64 BIT WRITE
            }
        }
    }
}
