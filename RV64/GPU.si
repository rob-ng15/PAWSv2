circuitry copycoordinates( input x, input y, output x1, output y1 ) { x1 = x; y1 = y; }                                         // COPY COORDINATES CIRCUIT

unit gpu_queue(
    output  int11   bitmap_x_write,                                                                                             // TO FRAMEBUFFER PIXEL WRITER
    output  int11   bitmap_y_write,
    output  uint8   bitmap_colour_write,
    output  uint8   bitmap_colour_write_alt,
    output  uint1   bitmap_write,
    output  uint9   bitmap_crop_left,
    output  uint9   bitmap_crop_right,
    output  uint8   bitmap_crop_top,
    output  uint8   bitmap_crop_bottom,
    output  uint4   gpu_active_dithermode,

    input   uint9   crop_left,                                                                                                  // CPU REQUESTED CROPPING RECTANGLE
    input   uint9   crop_right,
    input   uint8   crop_top,
    input   uint8   crop_bottom,

    input   int11   gpu_x,                                                                                                      // CPU REQUESTED GPU OPERATION
    input   int11   gpu_y,
    input   uint8   gpu_colour,
    input   uint8   gpu_colour_alt,
    input   int11   gpu_param0,
    input   int11   gpu_param1,
    input   int11   gpu_param2,
    input   int11   gpu_param3,
    input   int11   gpu_param4,
    input   int11   gpu_param5,
    input   uint4   gpu_write,
    input   uint4   gpu_dithermode,

    simple_dualport_bram_port0 blit1tilemap,                                                                                    // STORAGE FOR 1 BIT 16x16 TILES
    simple_dualport_bram_port0 characterGenerator8x8,                                                                           // STORAGE FOR 512 8x8 CHARACTERS
    simple_dualport_bram_port0 colourblittilemap,                                                                               // STORAGE FOR COLOUR 16x16 TILES

    input   uint2   pb_mode,                                                                                                    // PIXEL BLOCK PARAMETERS/REQUESTS FROM CPU
    input   uint8   pb_colour,
    input   uint8   pb_colour8r,
    input   uint8   pb_colour8g,
    input   uint8   pb_colour8b,
    input   uint2   pb_newpixel,
    simple_dualport_bram_port0 pb_colourmap,

    output  uint1   queue_full(0),
    output  uint1   queue_complete(1),
    output  uint1   gpu_active
) <reginputs> {
    gpu GPU(
        blit1tilemap <:> blit1tilemap,
        characterGenerator8x8 <:> characterGenerator8x8,
        colourblittilemap <:> colourblittilemap,
        pb_colourmap <:> pb_colourmap,
        bitmap_x_write :> bitmap_x_write, bitmap_y_write :> bitmap_y_write,
        bitmap_colour_write :> bitmap_colour_write, bitmap_colour_write_alt :> bitmap_colour_write_alt,
        bitmap_write :> bitmap_write,
        gpu_active_dithermode :> gpu_active_dithermode,
        pb_mode <: pb_mode, pb_colour <: pb_colour, pb_colour8r <: pb_colour8r, pb_colour8g <: pb_colour8g, pb_colour8b <: pb_colour8b, pb_newpixel <: pb_newpixel,
        gpu_active :> gpu_active
    );

    uint4   queue_write = 0;                                                                                                    // QUEUED GPU OPERATION
    uint1   queue_busy <:: |queue_write;                                                                                        // IS QUEUE OCCUPIED?

    GPU.gpu_write := 0;                                                                                                         // GPU START OPERATION FLAG
    queue_full := queue_busy ; queue_complete := ~( gpu_active | queue_full );                                                  // QUEUE FULL OR COMPLETE?

    always_after {
        int11   queue_x = uninitialised;                int11   queue_y = uninitialised;                                        // QUEUE STORAGE
        uint8   queue_colour = uninitialised;           uint8   queue_colour_alt = uninitialised;
        int11   queue_param0 = uninitialised;           int11   queue_param1 = uninitialised;
        int11   queue_param2 = uninitialised;           int11   queue_param3 = uninitialised;
        int11   queue_param4 = uninitialised;           int11   queue_param5 = uninitialised;
        uint4   queue_dithermode = uninitialised;
        uint9   queue_cropL = uninitialised;            uint8   queue_cropT = uninitialised;
        uint9   queue_cropR = uninitialised;            uint8   queue_cropB = uninitialised;

        bitmap_crop_left = GPU.crop_left; bitmap_crop_right = GPU.crop_right;                                                   // SEND CROPPING RECTANGLE TO BITMAP WRITER
        bitmap_crop_top = GPU.crop_top; bitmap_crop_bottom = GPU.crop_bottom;

        if( queue_busy & ~gpu_active ) {                                                                                        // DISPATCH FROM QUEUE
            GPU.gpu_dithermode = queue_dithermode; GPU.gpu_colour = queue_colour; GPU.gpu_colour_alt = queue_colour_alt;
            ( GPU.gpu_x, GPU.gpu_y ) = copycoordinates( queue_x, queue_y );
            ( GPU.gpu_param0, GPU.gpu_param1 ) = copycoordinates( queue_param0, queue_param1 );
            ( GPU.gpu_param2, GPU.gpu_param3 ) = copycoordinates( queue_param2, queue_param3 );
            ( GPU.crop_left, GPU.crop_right ) = copycoordinates( queue_cropL, queue_cropR );
            ( GPU.crop_top, GPU.crop_bottom ) = copycoordinates( queue_cropT, queue_cropB );

            switch( queue_write ) {                                                                                             // COPY REQUESTED OPERATION OR SPLIT QUADRILATERAL
                case 0: {}
                case 14: { ( GPU.gpu_param0, GPU.gpu_param1 ) = copycoordinates( queue_param4, queue_param5 ); GPU.gpu_write = 6; queue_write = 0; }  // QUADRILATERAL, SECOND TRIANGLE TO GPU
                case 15: { GPU.gpu_write = 6; queue_write = 14; }                                                               // QUADRILATERAL, SEND FIRST TRIANGLE TO GPU
                default: { GPU.gpu_write = queue_write; queue_write = 0; }                                                      // EVERYTHING ELSE, SEND TO GPU
            }
        }

        if( |gpu_write ) {                                                                                                      // QUEUE CPU REQUEST
            queue_write = gpu_write;                                                                                            // COPY REQUEST
            queue_dithermode = gpu_dithermode; queue_colour = gpu_colour; queue_colour_alt = gpu_colour_alt;
            ( queue_x, queue_y ) = copycoordinates( gpu_x, gpu_y );
            ( queue_param0, queue_param1 ) = copycoordinates( gpu_param0, gpu_param1 );
            ( queue_param2, queue_param3 ) = copycoordinates( gpu_param2, gpu_param3 );
            ( queue_param4, queue_param5 ) = copycoordinates( gpu_param4, gpu_param5 );
            ( queue_cropL, queue_cropR ) = copycoordinates( crop_left, crop_right );
            ( queue_cropT, queue_cropB ) = copycoordinates( crop_top, crop_bottom );
        }
    }
}

unit gpu(
    simple_dualport_bram_port0 blit1tilemap,
    simple_dualport_bram_port0 characterGenerator8x8,
    simple_dualport_bram_port0 colourblittilemap,
    simple_dualport_bram_port0 pb_colourmap,

    // GPU to SET and GET pixels
    output int11   bitmap_x_write,
    output int11   bitmap_y_write,
    output uint8   bitmap_colour_write,
    output uint8   bitmap_colour_write_alt,
    output uint1   bitmap_write,
    output uint4   gpu_active_dithermode,

    input   uint9   crop_left,
    input   uint9   crop_right,
    input   uint8   crop_top,
    input   uint8   crop_bottom,

    input   int11   gpu_x,
    input   int11   gpu_y,
    input   uint8   gpu_colour,
    input   uint8   gpu_colour_alt,
    input   int11   gpu_param0,
    input   int11   gpu_param1,
    input   int11   gpu_param2,
    input   int11   gpu_param3,
    input   int11   gpu_param4,
    input   int11   gpu_param5,
    input   uint4   gpu_write,
    input   uint4   gpu_dithermode,

    input   uint2   pb_mode,
    input   uint8   pb_colour,
    input   uint8   pb_colour8r,
    input   uint8   pb_colour8g,
    input   uint8   pb_colour8b,
    input   uint2   pb_newpixel,

    output  uint1   gpu_active(0),
) <reginputs> {
    rectangle GPUrectangle(                                                                                                     // GPU FILLED RECTANGLE
        crop_left <: crop_left, crop_right <: crop_right, crop_top <: crop_top, crop_bottom <: crop_bottom,
        x <: gpu_x, y <: gpu_y, x1 <: gpu_param0, y1 <: gpu_param1
    );
    line GPUline(                                                                                                               // GPU 1/x WIDE PIXEL LINE
        x <: gpu_x, y <: gpu_y, x1 <: gpu_param0, y1 <: gpu_param1,
        width <: gpu_param2[0,8]
    );
    circle GPUcircle(                                                                                                           // GPU OUTLINE/FILLED CIRCLE
        x <: gpu_x, y <: gpu_y, radius <: gpu_param0, sectormask <: gpu_param1
    );
    triangle GPUtriangle(                                                                                                       // GPU FILLED TRIANGLE ( used x2 for quadrilateral )
        crop_left <: crop_left, crop_right <: crop_right, crop_top <: crop_top, crop_bottom <: crop_bottom,
        x <: gpu_x, y <: gpu_y, x1 <: gpu_param0, y1 <: gpu_param1, x2 <: gpu_param2, y2 <: gpu_param3
    );
    blit GPUblit(                                                                                                               // GPU BLITTER
        blit1tilemap <:> blit1tilemap,                                                                                          // 1 BIT 16x16 TILES
        characterGenerator8x8 <:> characterGenerator8x8,                                                                        // 8x8 CHARACTERS
        colourblittilemap <:> colourblittilemap,                                                                                // COLOUR 16x16 TILES
        x <: gpu_x, y <: gpu_y,
        tile <: gpu_param0[0,9], scale <: gpu_param1[0,2], action <: gpu_param2[0,3]
    );
    pixelblock GPUpixelblock(                                                                                                   // PIXELBLOCK FOR RAPID TRANSFER OF BITMAPS
        colourmap <:> pb_colourmap,                                                                                             // INCLUDING RGBA -> RGBM or GREY
        x <: gpu_x, y <: gpu_y, width <: gpu_param0,
        ignorecolour <: gpu_param1,
        mode <: pb_mode, colour <: pb_colour,
        colour8r <: pb_colour8r, colour8g <: pb_colour8g, colour8b <: pb_colour8b,
        newpixel <: pb_newpixel
    );

    GPUrectangle.start := 0; GPUline.start := 0; GPUcircle.start := 0; GPUtriangle.start := 0; GPUblit.start := 0; GPUpixelblock.start := 0;

    always_after {
        // GPU UNIT BUSY FLAGS
        uint6   gpu_busy_flags = { GPUpixelblock.busy, |GPUblit.busy, GPUtriangle.busy, GPUcircle.busy, GPUrectangle.busy, GPUline.busy };
        uint1   gpu_busy = ( |gpu_busy_flags );

        if( |gpu_write ) {                                                                                                  // START GPU DRAWING UNIT FROM QUEUE ENTRY
            gpu_active_dithermode = 0; bitmap_colour_write = gpu_colour; bitmap_colour_write_alt = gpu_colour_alt;          // RESET TO THE COMMON DEFAULTS
            GPUcircle.filledcircle = gpu_write[0,1]; GPUblit.tilecharacter = gpu_write[0,1];

            switch( gpu_write ) {
                default: {}
                case 1: { ( bitmap_x_write, bitmap_y_write ) = copycoordinates(  gpu_x, gpu_y );}                           // PLOT POINT (X,Y) DIRECT, NO GPU ACTIVATION
                case 2: { GPUline.start = 1; }                                                                              // DRAW LINE FROM (X,Y) to (PARAM0,PARAM1)
                case 3: { gpu_active_dithermode = gpu_dithermode; GPUrectangle.start = 1; }                                 // DRAW RECTANGLE FROM (X,Y) to (PARAM0,PARAM1)
                case 4: { GPUcircle.start = 1; }                                                                            // DRAW CIRCLE CENTRE (X,Y) with RADIUS PARAM0
                case 5: { gpu_active_dithermode = gpu_dithermode; GPUcircle.start = 1; }                                    // DRAW FILLED CIRCLE CENTRE (X,Y) with RADIUS PARAM0
                case 6: { gpu_active_dithermode = gpu_dithermode; GPUtriangle.start = 1; }                                  // DRAW FILLED TRIANGLE WITH VERTICES (X,Y) (PARAM0,PARAM1) (PARAM2,PARAM3)
                case 7: { GPUblit.start = 1; }                                                                              // BLIT 16 x 16 TILE PARAM0 TO (X,Y)
                case 8: { GPUblit.start = 1; }                                                                              // BLIT 8 x 8 CHARACTER PARAM0 TO (X,Y) as 8 x 8
                case 9: { GPUblit.start = 2; }                                                                              // BLIT 16 x 16 COLOUR TILE PARAM0 TO (X,Y) as 16 x 16
                case 10: { GPUpixelblock.start = 1; }                                                                       // START THE PIXELBLOCK WRITER AT (x,y) WITH WIDTH PARAM0, IGNORE COLOUR PARAM1
                // 11                                                                                                       // DRAW FILLED ELLIPSE CENTE (X,Y) RADII ( PARAM0,PARAM1)
                // 12                                                                                                       // DRAW ELLIPSE CENTE (X,Y) RADII ( PARAM0,PARAM1)
                // 13
                // 14                                                                                                       // QUEUE CONTROLLED QUADRILATERAL, TRIANGLE 2
                // 15                                                                                                       // QUEUE CONTROLLED QUADRILATERAL, TRIANGLE 1
            }
        }

        if( gpu_busy ) {                                                                                                    // COPY OUTPUT TO THE BITMAP WRITER
            onehot( gpu_busy_flags ) {
                case 0: { ( bitmap_x_write, bitmap_y_write ) = copycoordinates(  GPUline.bitmap_x_write, GPUline.bitmap_y_write ); }
                case 1: { ( bitmap_x_write, bitmap_y_write ) = copycoordinates(  GPUrectangle.bitmap_x_write, GPUrectangle.bitmap_y_write ); }
                case 2: { ( bitmap_x_write, bitmap_y_write ) = copycoordinates(  GPUcircle.bitmap_x_write, GPUcircle.bitmap_y_write ); }
                case 3: { ( bitmap_x_write, bitmap_y_write ) = copycoordinates(  GPUtriangle.bitmap_x_write, GPUtriangle.bitmap_y_write ); }
                case 4: {
                    ( bitmap_x_write, bitmap_y_write ) = copycoordinates(  GPUblit.bitmap_x_write, GPUblit.bitmap_y_write );
                    if( GPUblit.busy[1,1] ) { bitmap_colour_write = GPUblit.bitmap_colour_write; }
                }
                case 5: { ( bitmap_x_write, bitmap_y_write ) = copycoordinates(  GPUpixelblock.bitmap_x_write, GPUpixelblock.bitmap_y_write ); bitmap_colour_write = GPUpixelblock.bitmap_colour_write; }
            }
        }
        bitmap_write = ( gpu_write == 1 ) | GPUline.bitmap_write | GPUrectangle.bitmap_write | GPUcircle.bitmap_write | GPUtriangle.bitmap_write | GPUblit.bitmap_write | GPUpixelblock.bitmap_write;

        gpu_active = ( |gpu_write[1,3] ) | gpu_busy;
    }
}

// HELPER - DECIDE IF MIN/MAX ARE WITHIN CROP
unit istodraw(
    input   int11   crop_left,
    input   int11   crop_right,
    input   int11   crop_top,
    input   int11   crop_bottom,
    input   int11   min_x,
    input   int11   min_y,
    input   int11   max_x,
    input   int11   max_y,
    output  uint1   draw
) <reginputs> {
    always_after {
        draw = ~|{ ( max_x < crop_left ), ( max_y < crop_top ), ( min_x > crop_right ), ( min_y > crop_bottom ) };
    }
}

// HELPER - APPLY CROPPING RECTANGLE FOR RECTANGLES AND TRIANGLES
unit applycrop(
    input   int11   crop_left,
    input   int11   crop_right,
    input   int11   crop_top,
    input   int11   crop_bottom,
    input   int11   x1,
    input   int11   y1,
    input   int11   x2,
    input   int11   y2,
    output  int11   min_x,
    output  int11   min_y,
    output  int11   max_x,
    output  int11   max_y
) <reginputs> {
    always_after {
        min_x = ( x1 < crop_left ) ? crop_left : x1;
        max_x = ( ( x2 > crop_right ) ? crop_right : x2 );
        min_y = ( y1 < crop_top ) ? crop_top : y1;
        max_y = 1 + ( ( y2 > crop_bottom ) ? crop_bottom : y2 );
    }
}

// RECTANGLE - OUTPUT PIXELS TO DRAW A RECTANGLE
unit preprectangle(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint9   crop_left,
    input   uint9   crop_right,
    input   uint8   crop_top,
    input   uint8   crop_bottom,
    input   int11   x,
    input   int11   y,
    input   int11   param0,
    input   int11   param1,
    output  int11   min_x,
    output  int11   min_y,
    output  int11   max_x,
    output  int11   max_y,
    output  uint1   todraw
) <reginputs> {
    uint1   xcompareparam0 <:: ( x < param0 );          uint1   ycompareparam1 <:: ( y < param1 );
    int11   x1 <:: xcompareparam0 ? x : param0;         int11   y1 <:: ycompareparam1 ? y : param1;
    int11   x2 <:: xcompareparam0 ? param0 : x;         int11   y2 <:: ycompareparam1 ? param1 : y;

    applycrop CROP( crop_left <: crop_left, crop_right <: crop_right, crop_top <: crop_top, crop_bottom <: crop_bottom,
                    x1 <: x1, y1 <: y1, x2 <: x2, y2 <: y2, min_x :> min_x, min_y :> min_y, max_x :> max_x, max_y :> max_y );

    istodraw TODRAW( crop_left <: crop_left, crop_right <: crop_right, crop_top <: crop_top, crop_bottom <: crop_bottom,
                min_x <: CROP.min_x, min_y <: CROP.min_y, max_x <: CROP.max_x, max_y <: CROP.max_y );

    todraw := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) { busy = 1; ++: ++: todraw = TODRAW.draw; busy = 0; }
        }
    }
}
unit drawrectangle(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint9   min_x,
    input   uint8   min_y,
    input   uint9   max_x,
    input   uint8   max_y,
    output  uint9   bitmap_x_write,
    output  uint8   bitmap_y_write,
    output  uint1   bitmap_write
) <reginputs> {
    uint8   yNEXT <:: bitmap_y_write + 1;
    uint1   lineend <:: ( bitmap_x_write == max_x );

    always_after {
        switch( { start, busy } ) {
            case 2b01: {
                if( lineend ) {                                                                                                 // Move to next pixel
                    ( bitmap_x_write, bitmap_y_write ) = copycoordinates(min_x, yNEXT );
                } else {
                    bitmap_x_write = bitmap_x_write + 1;
                }
                busy = ~( lineend & ( yNEXT == max_y ) );                                                                       // More to do?
            }
            case 2b10: { busy = 1; }
            default: { ( bitmap_x_write, bitmap_y_write ) = copycoordinates(min_x, min_y ); }                                   // Move to 1st pixel
        }

        bitmap_write = busy;                                                                                                    // Output pixels
    }
}
unit rectangle (
    input   uint1   start,
    output  uint1   busy(0),
    input   uint9   crop_left,
    input   uint9   crop_right,
    input   uint8   crop_top,
    input   uint8   crop_bottom,
    input   int11   x,
    input   int11   y,
    input   int11   x1,
    input   int11   y1,

    output  uint9   bitmap_x_write,
    output  uint8   bitmap_y_write,
    output  uint1   bitmap_write
) <reginputs> {
    preprectangle PREP(
        start <: start,
        crop_left <: crop_left, crop_right <: crop_right, crop_top <: crop_top, crop_bottom <: crop_bottom,
        x <: x, y <: y, param0 <: x1, param1 <: y1
    );
    drawrectangle RECTANGLE(
        min_x <: PREP.min_x, min_y <: PREP.min_y, max_x <: PREP.max_x, max_y <: PREP.max_y,
        bitmap_x_write :> bitmap_x_write, bitmap_y_write :> bitmap_y_write, bitmap_write :> bitmap_write,
        start <: PREP.todraw
    );

    busy := start | PREP.busy | PREP.todraw | RECTANGLE.busy;
}

// LINE - OUTPUT PIXELS TO DRAW A LINE via BRESENHAM'S LINE DRAWING ALGORITHM
unit absolutedelta(                                                                                                             // ABSOLUTRE/POSITIVE DELTA/DIFFERENCE BETWEEN TWO INPUTS
    input   int11   value1,                                                                                                     // FIRST VALUE
    input   int11   value2,                                                                                                     // SECOND VALUE
    output! uint1   v1v2,                                                                                                       // OUTPUT COMPARISON
    output! int11   delta                                                                                                       // OUTPUT ABSOLUTE/POSITIVE DELTA/DIFFERENCE
) {
    always_after {
        v1v2 = ( __signed(value1) < __signed(value2) );                                                                         // COMPARE
        delta = ( v1v2 ? value2 : value1 ) - ( v1v2 ? value1 : value2 );                                                        // LARGEST - SMALLEST
    }
}
unit prepline(
    input   uint1   start,
    output  uint1   todraw,
    input   int11   x,
    input   int11   y,
    input   int11   param0,
    input   int11   param1,
    output  int11   x1,
    output  int11   y1,
    output  int11   dx,
    output  int11   dy,
    output  uint1   dv,
    output  int11   numerator,
    output  int11   max_count
) <reginputs> {
    absolutedelta DX( value1 <: x, value2 <: param0 );                                                                          // COMPARE X AND PARAM0 ( x1 < x2 of inputs )
    absolutedelta DY( value1 <: y, value2 <: param1 );                                                                          // COMPARE Y AND PARAM1 ( y1 < y2 of inputs )

    todraw := 0;

    always_after {
        uint1   dxdy = ( DX.delta > DY.delta );

        if( start ) {
            if( DX.v1v2 ) { x1 = x; y1 = y; dv = DY.v1v2; } else { x1 = param0; y1 = param1; dv = ~DY.v1v2; }                   // ENSURE START AT LEFT, DETERMINE IF UP/DOWN

            dx = DX.delta; dy = DY.delta;                                                                                       // LATCH DELTAS

            numerator = dxdy ? ( DX.delta[1,10] ) : -( DY.delta[1,10] );
            max_count = ( dxdy ? DX.delta : DY.delta ) + 1;                                                                     // NUMBER OF PIXELS TO DRAW

            todraw = 1;
        }
    }
}
unit drawline(
    input   uint1   start,
    output  uint1   busy(0),
    input   int11   start_x,
    input   int11   start_y,
    input   int11   start_numerator,
    input   int11   dx,
    input   int11   dy,
    input   uint1   dv,
    input   int11   max_count,
    input   uint8   width,
    output  int11   bitmap_x_write,
    output  int11   bitmap_y_write,
    output  uint1   bitmap_write
) <reginputs> {
    int11   x = uninitialized;                      int11   offset_x = uninitialised;
    int11   y = uninitialized;                      int11   offset_y = uninitialised;

    bitmap_write := 0;

    algorithm <autorun> {
        int11   numerator = uninitialized;
        uint1   n2dx <:: numerator > (-dx);                 uint1   n2dy <:: numerator < dy;
        uint1   dxdy <:: dx > dy;
        int11   count = uninitialized;
        int11   offset_start <:: -( width[1,7] );
        uint8   pixel_count = uninitialised;

        while(1) {
            if( start ) {
                busy = 1; ( x, y ) = copycoordinates( start_x, start_y ); numerator = start_numerator; count = 0; offset_x = 0; offset_y = 0;
                while( count != max_count ) {
                    if( width == 1 ) {
                        bitmap_write = 1;
                    } else {
                        pixel_count = 0; offset_x = dxdy ? 0 : offset_start; offset_y = dxdy ? offset_start : 0;
                        while( pixel_count != width ) {
                            bitmap_write = 1;
                            offset_x = offset_x + ~dxdy; offset_y = offset_y + dxdy;
                            pixel_count = pixel_count + 1;
                        }
                    }
                    numerator = numerator - ( n2dx ? dy : 0 ) + ( n2dy ? dx : 0 ); count = count + 1; x = x + n2dx; y = n2dy ? (y + ( dv ? 1 : -1 )) : y;
                }
                busy = 0;
            }
        }
    }

    always_after {
        bitmap_x_write = x + offset_x;
        bitmap_y_write = y + offset_y;
    }
}
unit line(
    input   uint1   start,
    output  uint1   busy(0),
    input   int11   x,
    input   int11   y,
    input   int11   x1,
    input   int11   y1,
    input   uint8   width,
    output  int11   bitmap_x_write,
    output  int11   bitmap_y_write,
    output  uint1   bitmap_write
) <reginputs> {
    prepline PREP(
        start <: start,
        x <: x, y <: y, param0 <: x1, param1 <: y1
    );
    drawline LINE(
        start_x <: PREP.x1, start_y <: PREP.y1,
        start_numerator <: PREP.numerator,
        dx <: PREP.dx, dy <: PREP.dy, dv <: PREP.dv,
        max_count <: PREP.max_count, width <: width,
        bitmap_x_write :> bitmap_x_write, bitmap_y_write :> bitmap_y_write,
        bitmap_write :> bitmap_write,
        start <: PREP.todraw
    );
    busy := start | PREP.todraw | LINE.busy;
}

//  CIRCLE - OUTPUT PIXELS TO DRAW AN OUTLINE OR FILLED CIRCLE
unit arccoords(
    input   int11   xc,
    input   int11   yc,
    input   int11   active_x,
    input   int11   count,
    input   uint3   arc,
    output  int11   bitmap_x_write,
    output  int11   bitmap_y_write,
    output  uint1   centrepixel
) <reginputs> {
    always_after {
        // PLUS OR MINUS OFFSETS
        int11   ycpax = yc + active_x;                      int11   ycpc = yc + count;

        switch( arc ) {
            case 0: { bitmap_x_write = xc + active_x; bitmap_y_write = ycpc; }
            case 1: { bitmap_y_write = yc - count; }
            case 2: { bitmap_x_write = xc - active_x; }
            case 3: { bitmap_y_write = ycpc; }
            case 4: { bitmap_x_write = xc + count; bitmap_y_write = ycpax; }
            case 5: { bitmap_y_write = yc - active_x; }
            case 6: { bitmap_x_write = xc - count; }
            case 7: { bitmap_y_write = ycpax; }
        }

        centrepixel = ( ~|count & ~|active_x );
    }
}
unit drawcircle(
    input   uint1   start,
    output  uint1   busy(0),
    input   int11   xc,
    input   int11   yc,
    input   int11   radius,
    input   int11   start_numerator,
    input   uint8   draw_sectors,
    input   uint1   filledcircle,
    output  int11   bitmap_x_write,
    output  int11   bitmap_y_write,
    output  uint1   bitmap_write
) <reginputs> {
    int11   active_x = uninitialized;
    int11   active_y = uninitialized;
    int11   count = uninitialised;
    uint4   arc = uninitialised;
    arccoords ARC( xc <: xc, yc <: yc, active_x <: active_x, count <: count, arc <: arc );

    bitmap_write := 0;

    algorithm <autorun> {
        int11   numerator = uninitialised;
        int11   countNEXT <:: filledcircle ? count - 1 : min_count;
        int11   min_count = uninitialised;

        while(1) {
            if( start ) {
                busy = 1;
                active_x = 0; active_y = radius; count = radius; min_count = (-1); numerator = start_numerator;
                while( active_y >= active_x ) {
                    if( ARC.centrepixel ) {
                        bitmap_write = |draw_sectors;                                                                        // DETECT IF CENTRE PIXEL, OUTPUT ONCE
                    } else {
                        arc = 0;
                        while( ~arc[3,1] ) {
                            bitmap_write = draw_sectors[arc,1]; arc = arc + 1;                                          // OUTPUT PIXELS IN THE 8 SEGMENTS/ARCS AS PER MASK
                        }
                    }
                    if( countNEXT == min_count ) {
                        active_x = active_x + 1; active_y = active_y - ( ~numerator[10,1] & |numerator );
//                        ( active_x, active_y ) = copycoordinates( active_xNEXT, active_yNEXT );
                        count = active_y; min_count = min_count + 1; numerator = numerator[10,1] ? numerator + { active_x, 2b00 } + 6 : numerator + { (active_x - active_y), 2b00 } + 10;
                    } else {
                        count = countNEXT;
                    }
                }
                busy = 0;
            }
        }
    }

    always_after {
        bitmap_x_write = ARC.centrepixel ? xc : ARC.bitmap_x_write;
        bitmap_y_write = ARC.centrepixel ? yc : ARC.bitmap_y_write;
    }
}
unit circle(
    input   uint1   start,
    output  uint1   busy(0),
    input   int11   x,
    input   int11   y,
    input   int11   radius,
    input   uint8   sectormask,
    input   uint1   filledcircle,

    output  int11  bitmap_x_write,
    output  int11  bitmap_y_write,
    output  uint1  bitmap_write
) <reginputs> {
    int11   absradius <:: radius[10,1] ? -radius : radius;
    int11   gpu_numerator <:: 3 - ( { absradius, 1b0 } );

    drawcircle CIRCLE(
        xc <: x, yc <: y,
        radius <: absradius,
        start_numerator <: gpu_numerator,
        filledcircle <: filledcircle,
        bitmap_x_write :> bitmap_x_write, bitmap_y_write :> bitmap_y_write, bitmap_write :> bitmap_write,
        start <: start
    );
    CIRCLE.draw_sectors := { sectormask[5,1], sectormask[6,1], sectormask[1,1], sectormask[2,1], sectormask[4,1], sectormask[7,1], sectormask[0,1], sectormask[3,1] };
    busy := start | CIRCLE.busy;
}

// TRIANGLE - OUTPUT PIXELS TO DRAW A FILLED TRIANGLE
unit swaponcondition(                                                                                                           // SWAP (x1,y1) AND (x2,y2) IF CONDITION IS TRUE
    input   int11   x1,
    input   int11   x2,
    input   int11   y1,
    input   int11   y2,
    input   uint1   condition,
    output  int11   nx1,
    output  int11   nx2,
    output  int11   ny1,
    output  int11   ny2
) <reginputs> {
    always_after {
        nx1 = condition ? x2 : x1; nx2 = condition ? x1 : x2; ny1 = condition ? y2 : y1; ny2 = condition ? y1 : y2;
    }
}
unit minmax3(                                                                                                                   // RETURN MIN AND MAX OF 3 NUMBERS
    input   int11   n1,
    input   int11   n2,
    input   int11   n3,
    output  int11   min,
    output  int11   max
) <reginputs> {
    always_after {
        min = ( n1 < n2 ) ? ( ( n1 < n3 ) ? n1 : n3 ) : ( ( n2 < n3 ) ? n2 : n3 );                                              // RETURN MIN OF 3 NUMBERS
        max = ( n1 > n2 ) ? ( ( n1 > n3 ) ? n1 : n3 ) : ( ( n2 > n3 ) ? n2 : n3 );                                              // RETURN MAX OF 3 NUMBERS
    }
}
unit checkslope(                                                                                                                // CHECK SLOPE OF ( x1, y1 ) -> ( x2, y2 ) AND ( x1, y1 ) -> ( x3, y3 )
    input   int11   x1,
    input   int11   y1,
    input   int11   x2,
    input   int11   y2,
    input   int11   x3,
    input   int11   y3,
    output  uint1   needsswap                                                                                                   // SWAP IF ANTI-CLOCKWISE
) <reginputs> {
    int22   slope1 <:: ( y2 - y1 ) * ( x3 - x2 );
    int22   slope2 <:: ( y3 - y2 ) * ( x2 - x1 );

    always_after {
        needsswap = ( slope1 >= slope2 );
    }
}
unit preptriangle(                                                                                                              // SORT COORDINATES SO (X1,Y1) ARE TOP LEFT THEN CLOCKWISE
    input   uint1   start,
    output  uint1   busy(0),
    input   int11   crop_left,
    input   int11   crop_right,
    input   int11   crop_top,
    input   int11   crop_bottom,
    input   int11   x,
    input   int11   y,
    input   int11   param0,
    input   int11   param1,
    input   int11   param2,
    input   int11   param3,
    output  int11   x1,
    output  int11   y1,
    output  int11   x2,
    output  int11   y2,
    output  int11   x3,
    output  int11   y3,
    output  uint9   min_x,
    output  uint8   min_y,
    output  uint9   max_x,
    output  uint8   max_y,
    output  uint1   todraw
) <reginputs> {
    swaponcondition SWAP1( x1 <: param0, y1 <: param1, x2 <: param2, y2 <: param3 );                                            // -> ( x2, y2 ) and ( x3, y3 )
    swaponcondition SWAP2( x1 <: x, y1 <: y, x2 <: SWAP1.nx1, y2 <: SWAP1.ny1 );                                                // -> ( x1, y1 ) and ( x2, y2 )
    swaponcondition SWAP3( x1 <: SWAP2.nx1, y1 <: SWAP2.ny1, x2 <: SWAP1.nx2, y2 <: SWAP1.ny2 );                                // -> ( x1, y1 ) and ( x3, y3 )
    swaponcondition SWAP4( x1 <: SWAP2.nx2, y1 <: SWAP2.ny2, x2 <: SWAP3.nx2, y2 <: SWAP3.ny2 );                                // -> ( x2, y2 ) and ( x3, y3 )
    swaponcondition SWAP5( x1 <: SWAP3.nx1, y1 <: SWAP3.ny1, x2 <: SWAP4.nx1, y2 <: SWAP4.ny1,                                  // -> ( x1, y1 ) and ( x2, y2 )
                            nx1 :> x1, ny1 :> y1 );                                                                             //    FINAL ( x1, y1 )

    checkslope MAKECLOCKWISE( x1 <: SWAP5.nx1, y1 <: SWAP5.ny1,                                                                 // CHECK SLOPES TO ENSURE CLOCKWISE FROM TOP
                              x2 <: SWAP5.nx2, y2 <: SWAP5.ny2,
                              x3 <: SWAP4.nx2, y3 <: SWAP4.ny2 );

    swaponcondition SWAP6( x1 <: SWAP5.nx2, y1 <: SWAP5.ny2, x2 <: SWAP4.nx2, y2 <: SWAP4.ny2,                                  // -> ( x2, y2 ) and ( x3, y3 )
                            nx1 :> x2, ny1 :> y2, nx2 :> x3, ny2 :> y3, condition <: MAKECLOCKWISE.needsswap );                 // FINAL SWAP DETERMINED BY SLOPES TO ENSURE CLOCKWISE

    minmax3 X( n1 <: x1, n2 <: x2, n3 <: x3 );      minmax3 Y( n1 <: y1, n2 <: y2, n3 <: y3 );                                  // DEFINE BOUNDING BOX BY TRIANGLE COORDINATES
    applycrop CROP( crop_left <: crop_left, crop_right <: crop_right, crop_top <: crop_top, crop_bottom <: crop_bottom,         // APPLY CROP TO TRIANGLE COORDINATES
                    x1 <: X.min, y1 <: Y.min, x2 <: X.max, y2 <: Y.max,
                    min_x :> min_x, min_y :> min_y, max_x :> max_x, max_y :> max_y );                                           //  OUTPUT BOUNDING BOX
    istodraw TODRAW( crop_left <: crop_left, crop_right <: crop_right, crop_top <: crop_top, crop_bottom <: crop_bottom,        // DETERMINE IF ANY TRIANGLE PIXELS ARE IN RANGE
                min_x <: CROP.min_x, min_y <: CROP.min_y, max_x <: CROP.max_x, max_y <: CROP.max_y );

    todraw := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1;
                ++: ++: ++: ++: ++: ++: ++:                                                                                     // ( x1, y1 ) ARE TOP LEFT, THEN CLOCKWISE
                todraw = TODRAW.draw;                                                                                           // START TRIANGLE DRAWING IF PIXELS TO DRAW
                busy = 0;
            }
        }
    }

    always_after {
        SWAP1.condition = ( param3 < param1 );                                                                                  // ( y3 < y2 )                  SORT SO AS ( x1, y1 ) AT TOP
        SWAP2.condition = ( SWAP1.ny1 < y );                                                                                    // ( y2 < y1 )
        SWAP3.condition = ( SWAP1.ny2 < SWAP2.ny1 );                                                                            // ( y3 < y1 )
        SWAP4.condition = ( SWAP3.ny2 < SWAP2.ny2 );                                                                            // ( y3 < y2 )
        SWAP5.condition = ( SWAP4.ny1 == SWAP3.ny1 ) & ( SWAP4.nx1 < SWAP3.nx1 ) ;                                              // ( y2 == y1 ) & ( x2 < x1 )   SORT SO AS ( x1, y1 ) AT TOP LEFT if y1 == y2
    }
}
unit intriangle(                                                                                                                // DETERMINE IF A POINT IS INSIDE THE TRIANGLE
    input   int11   x0,                                                                                                         // REQUIRES POINTS TO BE CLOCKWISE FROM THE TOP LEFT POINT
    input   int11   y0,
    input   int11   x1,
    input   int11   y1,
    input   int11   x2,
    input   int11   y2,
    input   int11   px,
    input   int11   py,
    output  uint1   IN
) <reginputs> {
    int23   step1 <:: (( x2 - x1 ) * ( py - y1 ) - ( y2 - y1 ) * ( px - x1 ));
    int23   step2 <:: (( x0 - x2 ) * ( py - y2 ) - ( y0 - y2 ) * ( px - x2 ));
    int23   step3 <:: (( x1 - x0 ) * ( py - y0 ) - ( y1 - y0 ) * ( px - x0 ));

    always_after {
        IN =  ~|{ step1[22,1], step2[22,1], step3[22,1] };
    }
}
unit drawtriangle(                                                                                                              // OUTPUT PIXELS FOR THE TRIANGLE
    input   uint1   start,                                                                                                      // TRIES TO SCAN THE MINIMUM NUMBER OF PIXELS POSSIBLE
    output  uint1   busy(0),
    input   uint9   min_x,
    input   uint8   min_y,
    input   uint9   max_x,
    input   uint8   max_y,
    input   int11   x0,
    input   int11   y0,
    input   int11   x1,
    input   int11   y1,
    input   int11   x2,
    input   int11   y2,
    output  uint9   bitmap_x_write,
    output  uint8   bitmap_y_write,
    output  uint1   bitmap_write
) <reginputs> {
    intriangle IS( x0 <: x0, x1 <: x1, x2 <: x2, px <: px, y0 <: y0, y1 <: y1, y2 <: y2, py <: py );                            // DETERMINE IF WORKING POINT IS IN THE TRIANGLE
    uint1   beenInTriangle = uninitialized;                                                                                     // LOG IF BEEN IN TRIANGLE ON WORKING LINE

    uint9   px = uninitialized;                         uint9   pxNEXT <:: px + ( dx ? 1 : (-1) );                              // PRESENT WORKING COORDINATE X AND NEXT
    uint8   py = uninitialized;                         uint8   pyNEXT <:: py + 1;                                              // PRESNET WORKING COORDINATE Y AND NEXT
    uint9   sx = uninitialised;                         uint9   sxSAVE <:: px + ( dx ? (-1) : 1 );                              // SAVED COORDINATE WHEN DROPPING DOWN
    uint1   eol <:: px == ( dx ? max_x : min_x );                                                                               // AT END OF LINE ( MIN_X OR MAX_X )
    uint3   state = 1;                                                                                                          // STATE, { CHECK, DOWN AND IN TRIANGLE, SCAN UNTIL EXIT }
    uint1   dx = uninitialized;                                                                                                 // X DIRECTION, 1 == RIGHT, 0 == LEFT

    bitmap_x_write := px; bitmap_y_write := py; bitmap_write := busy & IS.IN;                                                   // OUTPUT IF ( PX, PY ) IS.IN THE TRIANGLE

    always_after {
        if( start ) {
            busy = 1; dx = 1; py = min_y; state = 1; beenInTriangle = 0;
            px = min_x;
//            if( ( y0 == min_y ) & ( x0 > min_x ) & ( x0 <= max_x ) ) { px = x0 - 1; } else { px = min_x; }
         } else {
            if( py != max_y ) {
                beenInTriangle = IS.IN | beenInTriangle;                                                                        // SET TO 1 IF EVER BEEN IN TRIANGLE ON THIS LINE
                onehot( state ) {
                    case 0: {                                                                                                   // NORMAL STATE, MOVE UNTIL IN THEN OUT OF TRIANGLE
                        if( beenInTriangle ^ IS.IN ) {
                            beenInTriangle = 0; py = pyNEXT; state = 4;                                                         // LEFT THE TRIANGLE, MOVE TO NEXT LINE AND CHANGE STATE TO CHECK
                        } else {
                            if( eol )  {
                                dx = ~dx; beenInTriangle = 0; py = pyNEXT;                                                      // AT END OF LINE, SWITCH DIRECTION AND MOVE TO THE NEXT LINE
                            } else {
                                px = pxNEXT;                                                                                    // MOVE TO THE NEXT PIXEL
                            }
                        }
                    }
                    case 1: {                                                                                                   // SECONDARY STATE, MOVED DOWN AND WAS IN TRIANGLE
                        if( ( beenInTriangle ^ IS.IN ) | eol ) {
                            px = sx; dx = ~dx; state = 1;                                                                       // LEFT THE TRIANGLE OR EOL, GOT TO SAVED POSITION, SWITCH DIRECTION, GO TO NORMAL STATE
                        } else {
                            px = pxNEXT;                                                                                        // MOVE TO THE NEXT PIXEL
                        }
                    }
                    case 2: {                                                                                                   // CHECK STATE AFTER MOVING DOWN
                        if( IS.IN ) {
                            sx = sxSAVE; px = pxNEXT;                                                                           // MOVED DOWN AND IN TRIANGLE, SAVE AND MOVE TO NEXT PIXEL
                        } else {
                            dx = ~dx;                                                                                           // MOVED DOWN AND OUTSIDE THE TRIANGLE, SWITCH DIRECTION
                        }
                        state = IS.IN ? 2 : 1;
                    }
                }
            } else {
                busy = 0;
            }
        }
    }
}
unit triangle(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint9   crop_left,
    input   uint9   crop_right,
    input   uint8   crop_top,
    input   uint8   crop_bottom,
    input   int11   x,
    input   int11   y,
    input   int11   x1,
    input   int11   y1,
    input   int11   x2,
    input   int11   y2,
    output  uint9   bitmap_x_write,
    output  uint8   bitmap_y_write,
    output  uint1   bitmap_write
) <reginputs> {
    preptriangle PREP(                                                                                                          // SORT THE COORDINATES AND FIND THE BOUNDING BOX
        start <: start,
        crop_left <: crop_left, crop_right <: crop_right, crop_top <: crop_top, crop_bottom <: crop_bottom,
        x <: x, y <: y, param0 <: x1, param1 <: y1, param2 <: x2, param3 <: y2
    );

    drawtriangle TRIANGLE(                                                                                                      // DRAW THE TRIANGLE IF ANY PIXELS TO DRAW
        min_x <: PREP.min_x, max_x <: PREP.max_x, min_y <: PREP.min_y, max_y <: PREP.max_y,
        x0 <: PREP.x1, y0 <: PREP.y1, x1 <: PREP.x2, y1 <: PREP.y2, x2 <: PREP.x3, y2 <: PREP.y3,
        bitmap_x_write :> bitmap_x_write, bitmap_y_write :> bitmap_y_write, bitmap_write :> bitmap_write,
        start <: PREP.todraw
    );

    busy := start | PREP.busy | PREP.todraw | TRIANGLE.busy;
}

// BLIT - ( tilecharacter == 0 ) OUTPUT PIXELS TO BLIT AN 8 x 8 CHARACTER ( PARAM1 == 0 as 8 x 8, == 1 as 16 x 16, == 2 as 32 x 32, == 3 as 64 x 64 )
// COLOURBLIT - OUTPUT PIXELS TO BLIT A 16 x 16 TILE ( PARAM1 == 0 as 16 x 16, == 1 as 32 x 32, == 2 as 64 x 64, == 3 as 128 x 128 )
unit blitscale(
    input   uint7   offset,
    input   uint2   scale,
    output  uint7   base,
    output  int11   scaled
) <reginputs> {
    always_after {
        base = offset;
        scaled = offset << scale;
    }
}
unit blittilexy(
    input   uint7   px,
    input   uint7   py,
    input   uint3   action,
    output  uint4   xinblittile,
    output  uint3   xinchartile,
    output  uint4   yinblittile,
    output  uint3   yinchartile
) <reginputs> {
    // find y and x positions within the tile/character bitmap handling rotation or reflection
    always_after {
        uint4   revx4 = ~px[0,4];
        uint4   revy4 = ~py[0,4];
        uint3   revx3 = ~px[0,3];
        uint3   revy3 = ~py[0,3];
        uint1   action00 = ( ~|action[0,2] );
        uint1   action01 = ( action[0,2] == 2b01 );
        uint1   action10 = ( action[0,2] == 2b10 );

        xinblittile = ( action[2,1] ?  action00 ? revx4 : action01 ? py[0,4] : action10 ? px[0,4] : revy4 : action[0,1] ? px[0,4] : revx4 );
        yinblittile = action[2,1] ? action00 ? py[0,4] : action01 ? px[0,4] : action10 ? revy4 : revx4 : action[1,1] ? revy4 :  py[0,4];
        xinchartile = ( action[2,1] ? action00 ? revx3 : action01 ? py[0,3] : action10 ? px[0,3] : revy3 : action[0,1] ?  px[0,3] : revx3 );
        yinchartile = action[2,1] ? action00 ? py[0,3] : action01 ? px[0,3] : action10 ? revy3 : revx3 : action[1,1] ? revy3 :  py[0,3];
    }
}
unit cololurblittilexy(
    input   uint7   px,
    input   uint7   py,
    input   uint3   action,
    output  uint4   xintile,
    output  uint4   yintile
) <reginputs> {
    // find y and x positions within the tile bitmap handling rotation or reflection
    always_after {
        uint4   revx = ~px[0,4];
        uint4   revy = ~py[0,4];
        uint1   action00 = ( ~|action[0,2] );
        uint1   action01 = ( action[0,2] == 2b01 );
        uint1   action10 = ( action[0,2] == 2b10 );

        xintile = action[2,1] ? action00 ? px[0,4] : action01 ? revy : action10 ? revx : py[0,4] : action[0,1] ? revx :  px[0,4];
        yintile = action[2,1] ? action00 ? py[0,4] : action01 ? px[0,4] : action10 ? revy : revx : action[1,1] ? revy :  py[0,4];
    }
}
unit blit(
    input   uint2   start,
    output  uint2   busy(0),
    simple_dualport_bram_port0 blit1tilemap,
    simple_dualport_bram_port0 characterGenerator8x8,
    simple_dualport_bram_port0 colourblittilemap,

    input   int11   x,
    input   int11   y,
    input   uint9   tile,
    input   uint2   scale,
    input   uint3   action,

    output  int11   bitmap_x_write,
    output  int11   bitmap_y_write,
    output  uint1   bitmap_write,
    output  uint8   bitmap_colour_write,

    input   uint1   tilecharacter
) <reginputs> {
    // START POSITION ON THE SCREEN, POSITION IN TILE/CHARACTER AND PIXEL COUNT FOR SCALING
    uint4   x2 = uninitialised;                     int11   x2NEXT <:: x2 + 1;
    uint4   y2 = uninitialised;
    blitscale PXS( scale <: scale );
    blitscale PYS( scale <: scale );


    // FIND X AND Y WITHIN THE TILE/CHARACTER BITMAP
    blittilexy BTXY( px <: PXS.base, py <: PYS.base, action <: action );
    cololurblittilexy CBTXY( px <: PXS.base, py <: PYS.base, action <: action );

    // CONTROL THE OUTPUT OF A PIXEL
    uint1   dooutput = uninitialised;                   dooutput := 0;

    // ADDRESEES INTO THE BLITTER TILES
    blit1tilemap.addr0 := { tile, BTXY.yinblittile }; characterGenerator8x8.addr0 := { tile, BTXY.yinchartile }; colourblittilemap.addr0 := { tile, CBTXY.yintile, CBTXY.xintile };
    bitmap_write := 0;

    algorithm <autorun> {
        // MAX PIXELS IN TILE AND NUMBER OF TIMES TO USE EACH PIXEL
        uint5   max_pixels <:: { tilecharacter, ~tilecharacter, 3b000 };
        uint4   max_count <:: ( 1 << scale );

        while(1) {
            if( |start ) {
                busy = start; PYS.offset = 0;
                while( PYS.offset != max_pixels ) {
                    PXS.offset = 0;
                    while( PXS.offset != max_pixels ) {
                        y2 = 0;
                        while( y2 != max_count ) { x2 = 0; while( x2 != max_count ) { dooutput = 1; } y2 =  y2 + 1; }
                        PXS.offset = PXS.base + 1;
                    }
                    PYS.offset = PYS.base + 1;
                }
                busy = 0;
            }
        }
    }

    always_after {
        if( dooutput ) {
            bitmap_x_write = x + PXS.scaled + x2;
            bitmap_y_write = y + PYS.scaled + y2;
            bitmap_colour_write = colourblittilemap.rdata0;
            bitmap_write = busy[0,1] ? tilecharacter ? blit1tilemap.rdata0[BTXY.xinblittile, 1] :                               // OUTPUT 1 BIT PIXEL
                                                       characterGenerator8x8.rdata0[BTXY.xinchartile, 1] :                      // OUTPUT CHARACTER PIXEL
                                       colourblittilemap.rdata0 != 64;                                                          // OUTPUT COLOUR PIXEL
            x2 = x2NEXT;
        }
    }
}

// PIXELBLOCK - OUTPUT PIXELS TO RECTANGLE START AT X, Y WITH WIDTH PARAM0, PIXELS PROVIDED SEQUENTIALLY BY CPU, MOVE ALONG RECTANGLE UNTIL STOP RECEIVED
// CAN HANDLE 256 colours, with one defined as transparent or 24bit RGB colours, scaling to the PAWS colour map
unit pixelblock(
    input   uint1   start,
    output  uint1   busy(0),
    simple_dualport_bram_port0 colourmap,

    input   int11   x,
    input   int11   y,
    input   int11   width,
    input   uint8   ignorecolour,

    input   uint2   mode,
    input   uint8   colour,
    input   uint8   colour8r,
    input   uint8   colour8g,
    input   uint8   colour8b,
    input   uint2   newpixel,

    output  int11   bitmap_x_write,
    output  int11   bitmap_y_write,
    output  uint8   bitmap_colour_write,
    output  uint1   bitmap_write
) <reginputs> {
    uint2   toprocess = uninitialised;              uint1   dooutput = uninitialised;
    int11   xNEXT <:: bitmap_x_write + 1;           int11   yNEXT <:: bitmap_y_write + 1;

    colourmap.addr0 := colour;                                                                                                  // LOOKUP THE COLOUR FROM THE REMAPPER
    bitmap_write := 0; dooutput := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1; bitmap_x_write = x - 1; bitmap_y_write = y;                                                           // COPY STARTING COORDINATES ( one to the left as moved before drawing )
                while( ~&toprocess ) { dooutput = |toprocess; }                                                                 // KEEP GOING UNTIL STOP RECEIVED
                busy = 0;
            }
        }
    }

    always_after {
        uint8   rrgggbbm = { colour8r[6,2], colour8g[5,3], colour8b[6,2], colour8r[5,1] & colour8b[5,1] };                      // RGB -> RGBM
        uint8   grey = ( ( colour8r * 3 + colour8g * 6 + colour8b ) * 205 ) >> 11;                                              // RGB -> GREYSCALE

        if( reset ) { busy = 0; }

        bitmap_colour_write = ( toprocess == 1 ) ? mode[0,1] ? colourmap.rdata0 : colour :                                      // 8 BIT COLOUR, REMAP?
                                                   mode[0,1] ? ( grey == 64 ) & ~mode[1,1] ? 65 : grey :                        // RGB -> GREY
                                                               ( rrgggbbm == 64 ) & ~mode[1,1] ? 128 : rrgggbbm;                // RGB -> RGBM

        if( dooutput ) {                                                                                                        // OUTPUT A PIXEL
            if( bitmap_x_write == ( x + width - 1) ) {
                ( bitmap_x_write, bitmap_y_write ) = copycoordinates( x, yNEXT );                                               // MOVE TO NEXT LINE
            } else {                                                                                                            // OR
                bitmap_x_write = xNEXT;                                                                                         // MOVE TO NEXT PIXEL
            }
            bitmap_write = ( ( toprocess[0,1] ) & ( mode[1,1] | ( colour != ignorecolour ) ) ) | ( toprocess[1,1] );            // WRITE IF 8 BIT AND !ignore OR WRITEALL OR RGB
        }

        toprocess = newpixel;                                                                                                   // DETECT NEW PIXEL
    }
}
