// SL @sylefeb 2020-08
//
// Simple SDcard controller
// only supports SDHC/SDXC
//
// Stays in slow xfer mode
//
// Timings for 25 MHz
// Tested ok at 50 MHz
// Tested ok at 100 MHz
//
// GNU AFFERO GENERAL PUBLIC LICENSE
// Version 3, 19 November 2007
//
// A copy of the license full text is included in
// the distribution, please refer to it for details.

// Write Support by @rob-ng15 2021
// Based upon http://elm-chan.org/docs/mmc/mmc_e.html and https://openlabpro.com/guide/interfacing-microcontrollers-with-sd-card/
// Additional information from https://chlazza.nfshost.com/sdcardinfo.html

group sdcardio {
    uint32  addr_sector = 0,
    uint1   read_sector = 0,
    uint1   write_sector = 0,
    uint16  offset = 0,
    uint1   ready = 0,
    uint1   error = 0
}

interface sdcardio_ctrl {
    input   addr_sector,
    input   read_sector,
    input   write_sector,
    input   offset,
    output  ready,
    output  error
}

unit sdcard(
    output  uint1   sd_clk(0),                                                                                                  // SDCARD   CLK SIGNAL
    output  uint1   sd_mosi(1),                                                                                                 //          OUT TO SDCARD
    output  uint1   sd_csn(1),                                                                                                  //          CS (CARD SELECT)
    input   uint1   sd_miso,                                                                                                    //          IN FROM SDCARD
    sdcardio_ctrl   io,                                                                                                         // CONTROL INTERFACE
    simple_dualport_bram_port0 buffer_write,                                                                                    // WRITE SECTOR BUFFER  FROM CPU (READ ONLY BY UNIT)
    simple_dualport_bram_port1 buffer_read                                                                                      // READ SECTOR BUFFER   FROM SDCARD (WRITTEN BY UNIT)
) <reginputs> {
    uint40  status = 0;
    uint48  cmd0 = 48b010000000000000000000000000000000000000010010101;                                                         // GO_IDLE_STATE
    uint48  cmd8 = 48b010010000000000000000000000000011010101010000111;                                                         // SEND_IF_COND
    uint48  cmd13 = 48b010011010000000000000000000000000000000011111111;                                                        // SEND_STATUS
    uint48  cmd16 = 48b010100000000000000000000000000100000000000010101;                                                        // SET_BLOCKLEN
    uint48  cmd17 = 48b010100010000000000000000000000000000000001010101;                                                        // READ_SINGLE_BLOCK
    uint48  cmd24 = 48b010110000000000000000000000000000000000001010101;                                                        // WRITE_BLOCK
    uint48  cmd55 = 48b011101110000000000000000000000000000000000000001;                                                        // APP_CMD
    uint48  acmd41 = 48b011010010100000000000000000000000000000000000001;                                                       // ACDM SD_SEND_OP_COND
                    // 01ccccccaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarrrrrrr1

    uint1   do_read_sector = 0;
    uint1   do_write_sector = 0;
    uint32  do_addr_sector = 0;

    uint9 read_next <:: buffer_read.addr1 + 1;
    uint9 write_next <:: buffer_write.addr0 + 1;

    uint10  progress = uninitialized;
    uint10  progress_p1 <:: progress + 1;

    buffer_read.wenable1 := 1; // writes to the read buffer

    algorithm <autorun> {

        subroutine send( input uint48 cmd, readwrites sd_clk, writes sd_mosi ) {                                                // SEND A COMMAND TO THE SDCARD
            uint16  count = 0; uint16  count_p1 <:: count + 1;
            uint48  shift = uninitialized;

            shift = cmd; while (count != $2*256*48$) {                                                                          // LATCH COMMAND, 48 BITS FOR EACH COMMAND
                if( &count[0,8] ) {                                                                                             //  EVERY 256 PULSES
                    sd_clk = ~sd_clk;                                                                                           //      SWITCH THE CLK
                    if( !sd_clk ) { sd_mosi = shift[47,1]; shift = shift << 1; }                                                //      IF CLK LOW, SEND THE BIT
                }
                count =  count_p1;
            }
            sd_mosi = 1;                                                                                                        // MOSI FINISHES HIGH
        }                                                                                                                       // NOTE: CLK FINISHES LOW

        subroutine sendbyte( input uint8 byte, readwrites sd_clk, writes sd_mosi ) {                                            // SEND A BYTE TO THE SDCARD ( FF will pulse the clock signal )
            uint8   count = 0; uint8   count_p1 <:: count + 1;
            uint4   n = 0; uint4   n_p1 <:: n + 1;
            uint8   shift = uninitialized;

            shift = byte; while( n != 8 ) {                                                                                     // LATCH BYTE, 8 BITS PER VYTE
                if( &count ) {                                                                                                  //  EVERY 256 PULSES
                    sd_clk = ~sd_clk;                                                                                           //      SWITCH THE CLK
                    if( !sd_clk ) { sd_mosi = shift[7,1]; shift = shift << 1; n = n_p1; }                                       //      IF CLK LOW, SEND THE BIT
                }
                count = count_p1;
            }
        }                                                                                                                       // NOTE: CLK FINISHES LOW

        subroutine waitbusy( readwrites sd_clk, reads sd_miso ) {                                                               // WAIT FOR THE SDCARD TO RETURN FROM BUSY ( MISO will go low )
            uint8   count = 0; uint8   count_p1 <:: count + 1;
            uint1   finished = 0;

            while( ~finished ) {                                                                                                // LOOP UNTIL MISO GOES LOW
                if( &count ) {                                                                                                  //  EVERY 256 PULSES
                    sd_clk = ~sd_clk;                                                                                           //      SWITCH THE CLK
                    if( !sd_clk ) { finished = sd_miso; }                                                                       //      IF CLK LOW, READ MISO
                }
                count = count_p1;
            }
        }                                                                                                                       // NOTE: CLK FINISHES LOW

        // READ xx BITS FROM THE SDCARD
        subroutine read( input uint6 len, input uint1 wait, output uint40 answer, input uint8 rate, readwrites sd_clk, reads sd_miso ) {
            uint16  count = 0; uint16  count_p1 <:: count + 1;
            uint6   n = 0; uint6   n_p1 <:: n + 1;

            answer = -1; while( (wait && answer[len-1,1]) || ((!wait) && n != len) ) {                                          // LOOP UNTIL ALL ANSWER BITS HAVE BEEN READ
                if( (count&rate) == rate ) {                                                                                    //  EVERY rate PULSES
                    sd_clk = ~sd_clk;                                                                                           //      SWITCH THE CLK
                    if( !sd_clk ) { answer = {answer[0,39],sd_miso}; n = n_p1; }                                                //      IF CLK LOW, READ THE BIT
                }
                count = count_p1;
            }
        }                                                                                                                       // NOTE: CLK FINISHES LOW

        // SDCARD INITIALISATION STARTS HERE
        // SWITCHES CARD TO SPI MODE BY SENDING CLK PULSES AT 400KHz WITH CS_N = 1 AND MOSI = 1;
        uint26  count = 0; uint26  count_p1 <:: count + 1; while( count != 50000000 ) { count = count_p1; }                     // 1 SECOND DELAY DURING POWER UP
        while( count != $100000+2*256*80$ ) { if( &count[0,8] ) { sd_clk = ~sd_clk; } count = count_p1; }                       // START SPI MODE, 74+ CLOCK PULSES AT 400KHz

        sd_csn = 0; buffer_read.addr1 = 0;                                                                                      // SET CS (INVERTED) AND POINTER INTO BUFFER

        () <- send <- ( cmd0 ); ( status ) <- read <- ( 8,1,255 );                                                              // GO_IDLE_STATE -> R1
        () <- send <- ( cmd8 ); ( status ) <- read <- ( 40,1,255 );                                                             // SEND_IF_COND -> R7
        while (1) {                                                                                                             // LOOP UNTIL SPI MODE ACKNOWLEDGED
            () <- send <- ( cmd55 ); ( status ) <- read <- ( 8,1,255 );                                                         //  APP_CMD -> R1
            () <- send <- ( acmd41 ); ( status ) <- read <- ( 8,1,255 );                                                        //  SD_SEND_OP_COND -> R1 ( all 0 for syceess )
            if( ~|status[0,8] ) { break; }
        }
        () <- send <- ( cmd16 ); ( status ) <- read <- ( 8,1,255 );                                                             // SET_BLOCKLEN 512 -> R1

        // SDCARD READ/WRITE HANDLING, WAIT FOR READ/WRITE FLAG FROM CPU AND HANDLE
        io.ready = 1; while (1) {
            progress = 0;

            if( do_read_sector ) {                                                                                              // CPU READ REQUEST
                do_read_sector = 0;

                () <- send <- ( { cmd17[40,8], do_addr_sector, cmd17[0,8] } ); ( status ) <- read <- ( 8,1,3 );                 // READ_SINGLE_BLOCK embed ADDR -> R1

                io.error = |status[0,8]; if( ~|status[0,8] ) {                                                                  // IF STATUS == 00 READ 512 BYTES
                    ( status ) <- read <- ( 1,1,3 );                                                                            //  WAIT FOR FE FROM THE SDCARD ( low bit )

                    buffer_read.addr1 = io.offset;                                                                              // MOVE TO OFFSET WITHIN THE BUFFER
                    ( buffer_read.wdata1 ) <- read <- ( 8,0,3 );
                    while( ~&progress[0,9] ) {
                        ( buffer_read.wdata1 ) <- read <- ( 8,0,3 ); buffer_read.addr1 = read_next; progress = progress_p1;     // READ 512 BYTES
                    }
                    ( status ) <- read <- ( 16,1,3 );                                                                           // READ CRC
                }
                io.ready = 1;
            }

            if (do_write_sector) {                                                                                              // CPU WRITE REQUEST
                do_write_sector = 0;

                buffer_write.addr0 = io.offset;                                                                                 // MOVE TO OFFSET WITHIN THE BUFFER

                () <- send <- ( { cmd24[40,8], do_addr_sector, cmd24[0,8] } ); ( status ) <- read <- (8,1,3 );                  // WRITE_BLOCK	 embed ADDR -> R1
                while( |status[0,8] ) { ( status ) <- read <- ( 8,1,3 ); }                                                      // AWAIT STATUS == 0

                () <- sendbyte <- ( 8hff ); () <- sendbyte <- ( 8hff ); () <- sendbyte <- ( 8hff ); () <- sendbyte <- ( 8hfe ); // SEND DUMMY CLOCKS THEN START TOKEN FE

                while( progress != 512 ) {
                    () <- sendbyte <- ( buffer_write.rdata0 ); buffer_write.addr0 = write_next; progress = progress_p1;         // WRITE 512 BYTES
                }

                () <- sendbyte <- ( 8hff ); () <- sendbyte <- ( 8hff );                                                         // SEND DUMMY CRC FFFF
                ( status ) <- read <- ( 8,1,3 ); io.error = ~( status == 8h05 );                                                // IF STATUS == 05 FLAG ERROR

                () <- waitbusy <- ( );                                                                                          // WAIT FOR CARD TO COMPLETE WRITE
                () <- send <- ( cmd13 ); ( status ) <- read <- ( 8,1,3 ); ( status ) <- read <- ( 8,1,3 );                      // SEND_STATUS -> R2

                io.ready = 1;
            }
        }
    }

    always_after {
        if( io.read_sector | io.write_sector ) {                                                                                // LATCH CPU READ/WRITE REQUESTS
            do_read_sector = io.read_sector;
            do_write_sector = io.write_sector;
            do_addr_sector = io.addr_sector;
            io.ready = 0;
        }
    }
}

// -------------------------
