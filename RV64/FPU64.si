// FMIN FMAX FSGNJ FSGNJN FSGNJX FEQ FLT FLE FCLASS FMV
unit floatclass(                                                                                                                // CLASSIFY FLOATING POINT INPUT ( FCLASS.S FCLASS.D )
    input   uint1   df,                                                                                                         // DOUBLE OR FLOAT FLAG
    input   uint64  sourceReg1F,                                                                                                // REGISTER INPUT TO CLASSIFY
    input   uint4   typeAF,                                                                                                     // { INF sNAN qNAN ZERO } OF REGISTER INPUT
    input   uint1   sign1F,                                                                                                     // SIGN OF REGISTER INPUT
    output  uint10  FCLASS                                                                                                      // 10 bit INTEGER CLASSIFICATION OF REGISTER INPUT
) <reginputs> {
    uint1   TRUEZERO <:: ~|( df ? fp64( sourceReg1F ).fraction : fp32( sourceReg1F ).fraction );                                // CHECK FRACTION == 0 ( NOT SUBNORMAL )

    always_after {
        FCLASS = {  typeAF[1,1],                                                                                                // 512  qNAN
                    typeAF[2,1],                                                                                                // 256  sNAN
                    typeAF[3,1] & ~sign1F,                                                                                      // 128  +INF
                    ~|typeAF & ~sign1F,                                                                                         // 64   +NORMAL
                    typeAF[0,1] & ~sign1F & ~TRUEZERO,                                                                          // 32   +SUBNORMAL
                    typeAF[0,1] & ~sign1F & TRUEZERO,                                                                           // 16   +0
                    typeAF[0,1] & sign1F & TRUEZERO,                                                                            // 8    -0
                    typeAF[0,1] & sign1F & ~TRUEZERO,                                                                           // 4    -SUBNORMAL
                    ~|typeAF & sign1F,                                                                                          // 2    -NORMAL
                    typeAF[3,1] & sign1F                                                                                        // 1    -INF
        };
   }
}
unit floateqltle(                                                                                                               // FLOATING POINT COMPARISONS ( uses base comparison less/equal generator )
    input   uint2   function3,                                                                                                  // COMPARISON TYPE SWITCH
    input   uint1   EQUAL,                                                                                                      // IS EQUAL FLAG A == B
    input   uint1   LESS,                                                                                                       // IS LESS FLAG A < B
    input   uint4   typeAF,                                                                                                     // { INF sNAN qNAN ZERO } OF A
    input   uint4   typeBF,                                                                                                     // { INF sNAN qNAN ZERO } OF B
    output  uint1   COMPARE,                                                                                                    // RESULT OF COMPARISON
    output  uint5   flags                                                                                                       // FLOATING POINT FLAGS FOR COMPARISON
) <reginputs> {
    uint1   NAN <:: |( typeAF[1,2] | typeBF[1,2] );                                                                             // DETECT NAN INPUT
    uint3   LTEQ <:: { EQUAL, LESS, LESS | EQUAL };                                                                             // BIT ARRAY FOR COMPARISON FLAGS

    always_after {
        { COMPARE = ~NAN & LTEQ[ function3, 1 ]; }                                                                              // 0 IF NAN ELSE COMPARISON FLAG
        { flags = { function3[1,1] ? ( typeAF[2,1] | typeBF[2,1] ) : NAN, 4b0000 }; }                                           // RETURN NV FLAG IF FLT OR FLE AND NAN IS AN INPUT
    }
}
unit floatminmax(                                                                                                               // FLOATING POINT MIN / MAX
    input   uint1   df,                                                                                                         // DOUBLE OR FLOAT FLAG
    input   uint1   function3,                                                                                                  // MIN == 0, MAX == 1
    input   uint64  sourceReg1F,                                                                                                // REGISTER INPUT A
    input   uint64  sourceReg2F,                                                                                                // REGISTER INPUT B
    input   uint4   typeAF,                                                                                                     // { INF sNAN qNAN ZERO } OF A
    input   uint4   typeBF,                                                                                                     // { INF sNAN qNAN ZERO } OF B
    input   uint1   LESS,                                                                                                       // IS LESS FLAG A < B
    output  uint64  MINMAX,                                                                                                     // RESULT OF MIN/MAX(a,b)
    output  uint5   flags                                                                                                       // FLOATING POINT FLAGS FOR MIN/MAX
) <reginputs> {
    uint64  qNAN <:: df ? 64h7FF8000000000000 : 64hffffffff7fc00000;                                                            // RETURN qNAN FOR 32/64 bit
    uint1   NAN <:: |( typeAF[1,2] | typeBF[1,2] );                                                                             // DETECT NAN INPUT

    always_after {
        { MINMAX = NAN ? qNAN : ( function3[0,1] ^ LESS ) ? ( df ? sourceReg1F : { 32hffffffff, sourceReg1F[0,32] } ) :         // EITHER INPUT NAN RETURN qNAN ELSE DO MIN MAX AND SELECT REGISTER
                                                            ( df ? sourceReg2F : { 32hffffffff, sourceReg2F[0,32] } ); }        // ( NAN boxed if float )
        { flags = { NAN, 4b0000 }; }                                                                                            // FLAGS SIGNALLING NAN INPUT
    }
}
unit floatsign(                                                                                                                 // FLOATING POINT FSGNJ FSGNJN FSGNJX SIGN INJECTION
    input   uint1   df,                                                                                                         // DOUBLE OR FLOAT FLAG
    input   uint2   function3,                                                                                                  // SWITCH FSGNJ == 00, FSGNJN == 01, FSGNJX == 10
    input   uint64  sourceReg1F,                                                                                                // REGISTER INPUT 1
    input   uint1   sign1F,                                                                                                     // SIGN OF REGISTER INPUT 1
    input   uint1   sign2F,                                                                                                     // SIGN OF REGISTER INPUT 2
    output  uint64  SIGN                                                                                                        // RESULT OF SIGN INJECTION
) <reginputs> {
    uint1   SIGNBIT <:: function3[1,1] ? sign1F ^ sign2F : function3[0,1] ^ sign2F;                                             // DETERMINE SIGN FOR INJECTION XOR FOR JX OPPOSITE FOR JN COPY FOR J

    always_after {
        SIGN = df ? { SIGNBIT, sourceReg1F[0,63] } : { 32hffffffff, SIGNBIT, sourceReg1F[0,31] };                               // INJECT SIGN ( NAN boxed if float )
   }
}
unit fpuSINGLECYCLE(
    input   uint1   df,                                                                                                         // DOUBLE OR FLOAT FLAG
    input   uint2   function3,                                                                                                  // SWITCH FOR COMPARE MINMAX AND SIGN OPERATIONS
    input   uint5   function7,                                                                                                  // SWITCH TO DETERMINE WHICH OPERATIONS
    input   uint64  sourceReg1,                                                                                                 // INTEGER REGISTER FOR FMV
    input   uint64  sourceReg1F,                                                                                                // INPUT FLOAT REGISTER 1
    input   uint64  sourceReg2F,                                                                                                // INPUT FLOAT REGISTER 2
    input   uint4   typeAF,                                                                                                     // { INF sNAN qNAN ZERO } OF INPUT FLOAT REGISTER 1
    input   uint4   typeBF,                                                                                                     // { INF sNAN qNAN ZERO } OF INPUT FLOAT REGISTER 2
    input   uint1   FLT,                                                                                                        // sourceReg1F < sourceReg2F
    input   uint1   FEQ,                                                                                                        // sourceReg1F == sourceReg2F
    input   uint5   FPUflags,                                                                                                   // PRESENT FPU FLAGS
    output  uint5   FPUnewflags,                                                                                                // NEW FPU FLAGS
    output  uint64  result,                                                                                                     // RESULT ( NAN boxed if float, sign extended if int )
    output  uint1   frd                                                                                                         // IS RESULT FLOAT/DOUBLE OR INT/LONG
) <reginputs> {
    uint1   sign1F <:: df ? fp64( sourceReg1F ).sign : fp32( sourceReg1F ).sign;                                                // EXTRACT SIGN OF sourceReg1F
    uint1   sign2F <:: df ? fp64( sourceReg2F ).sign : fp32( sourceReg2F ).sign;                                                // EXTRACT SIGN OF sourceReg2F

    floatclass FPUclass(                                                                                                        // GENERATE FCLASS
        df <: df,
        sourceReg1F <: sourceReg1F,
        typeAF <: typeAF,
        sign1F <: sign1F
    );
    floateqltle FPUeqltle(                                                                                                      // GENERATE FEQ FLT FLE
        function3 <: function3,
        EQUAL <: FEQ,
        LESS <: FLT,
        typeAF <: typeAF,
        typeBF <: typeBF
    );
    floatminmax FPUminmax(                                                                                                      // GENERATE FMIN FMAX
        df <: df,
        function3 <: function3[0,1],
        sourceReg1F <: sourceReg1F,
        sourceReg2F <: sourceReg2F,
        typeAF <: typeAF,
        typeBF <: typeBF,
        LESS <: FLT
    );
    floatsign FPUsign(                                                                                                          // GENERATE SGNJ FSGNJN FSGNJX
        df <: df,
        function3 <: function3,
        sourceReg1F <: sourceReg1F,
        sign1F <: sign1F,
        sign2F <: sign2F
    );

    always_after {
        {
            switch( function7[3,2] ) {                                                                                          // RESULT
                case 2b00: { result = function7[0,1] ? FPUminmax.MINMAX : FPUsign.SIGN; }                                       // FMIN FMAX FSGNJ FSGNJN FSGNJX ( NAN BOXED FOR FLOAT )
                case 2b10: { result = FPUeqltle.COMPARE; }                                                                      // FEQ FLT FLE
                default: { result = function7[1,1] ? df ? sourceReg1 : { 32hffffffff, sourceReg1[0,32] } :                      // FCLASS FMV.X.W FMV.W.X
                                    function3[0,1] ? FPUclass.FCLASS :
                                                     df ? sourceReg1F : { {32{sourceReg1F[31,1]}}, sourceReg1F[0,32] }; }
            }
        }
        {
            switch( function7[3,2] ) {                                                                                          // FLAGS
                case 2b00: { FPUnewflags = FPUflags | ( function7[0,1] ? FPUminmax.flags : 0 ); }                               // FMIN FMAX FSGNJ FSGNJN FSGNJX
                case 2b10: { FPUnewflags = FPUflags | FPUeqltle.flags; }                                                        // FEQ FLT FLE
                default: { FPUnewflags = FPUflags; }                                                                            // FCLASS FMV.X.W FMV.W,X
            }
        }
        { frd = function7[3,1] ? function7[1,1] : ~|function7[3,2]; }                                                           // FRD for FMIN FMAX FSGNJ FSGNJN FSGNJX AND FMV.W.X
    }
}

// FPU CALCULATION CONTROLLER FOR FUSED ADD SUB MUL DIV SQRT
unit floatcalc(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint1   df,
    input   uint5   opCode,
    input   uint3   function3,
    input   uint5   function7,
    input   uint64  sourceReg1F,
    input   uint64  sourceReg2F,
    input   uint64  sourceReg3F,
    input   uint4   typeAF,
    input   uint4   typeBF,
    input   uint4   typeCF,

    input   uint8   FPUflags,
    output  uint5   FPUnewflags,
    output  uint64  result
) <reginputs> {
    typeF typeMF( df <: df, a <: FPUmultiply.result );                                                                          // CLASSIFY THE RESULT FROM MULTIPLICATION FOR FUSED OPERATIONS

    uint64  a <:: opCode[2,1] ? sourceReg1F :                                                                                   // SELECT A FOR ADDSUB FROM SOURCEREG1F OR RESULT OF MULTIPLICATION FOR FUSED
                                df ? { opCode[1,1] ^ FPUmultiply.result[63,1], FPUmultiply.result[0,63] } :                     // SWITCHING SIGN IF A NEGATED MULTIPLY
                                     { 32hffffffff, opCode[1,1] ^ FPUmultiply.result[31,1], FPUmultiply.result[0,31] };
    uint64  b <:: opCode[2,1] ? df ? { function7[0,1] ^ sourceReg2F[63,1], sourceReg2F[0,63] } :                                // SELECT B FOR ADDSUB FROM SOURCEREG2F OR SOURCEREG3F FOR FUSED
                                     { 32hffffffff, function7[0,1] ^ sourceReg2F[31,1], sourceReg2F[0,31] }:                    // SWITCHING SIGN IF SUBTRACTION
                                df ? { opCode[0,1] ^ sourceReg3F[63,1], sourceReg3F[0,63] } :
                                     { 32hffffffff, opCode[0,1] ^ sourceReg3F[31,1], sourceReg3F[0,31] };
    uint4   typea <:: opCode[2,1] ? typeAF : typeMF.type;                                                                       // SELECT TYPE OF A FOR ADDSUB
    uint4   typeb <:: opCode[2,1] ? typeBF : typeCF;                                                                            // SELECT TYPE OF B FOR ADDSUB

    floataddsub FPUaddsub(
        df <: df,
        a <: a,
        b <: b,
        typeAF <: typea,
        typeBF <: typeb,
        OF <: MAKERESULT.OF,
        UF <: MAKERESULT.UF,
        combined <: MAKERESULT.combined
    );
    floatmultiply FPUmultiply(
        df <: df,
        a <: sourceReg1F,
        b <: sourceReg2F,
        typeAF <: typeAF, typeBF <:
        typeBF,
        OF <: MAKERESULT.OF,
        UF <: MAKERESULT.UF,
        combined <: MAKERESULT.combined
    );
    floatdivide FPUdivide(
        df <: df,
        a <: sourceReg1F,
        b <: sourceReg2F,
        typeAF <: typeAF,
        typeBF <: typeBF,
        OF <: MAKERESULT.OF,
        UF <: MAKERESULT.UF,
        combined <: MAKERESULT.combined
    );
    floatsqrt FPUsqrt(
        df <: df,
        a <: sourceReg1F,
        typeAF <: typeAF,
        OF <: MAKERESULT.OF,
        UF <: MAKERESULT.UF,
        combined <: MAKERESULT.combined
    );

    uint3   rm <:: &FPUflags[5,3] ? function3 : FPUflags[5,3];                                                                  // SET ROUNDING FLAG ( ONLY RNE AND RTZ SUPPORTED )
    doroundcombine MAKERESULT(                                                                                                  // DO ROUNDING AND COMBINING
        df <: df,
        rm <: rm
    );

    uint4   unitbusy <:: { FPUsqrt.busy, FPUdivide.busy, FPUmultiply.busy, FPUaddsub.busy };                                    // UNIT BUSY FLAGS
    uint1   isbusy <:: |unitbusy;                                                                                               // WAIT FOR CALCULATIONS TO FINISH

    FPUaddsub.start := 0; FPUmultiply.start := 0; FPUdivide.start := 0; FPUsqrt.start := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1;
                if( opCode[2,1] ) {
                    switch( function7[0,2] ) {                                                                                  // START 2 REGISTER FPU OPERATIONS
                        default: { FPUaddsub.start = 1; }                                                                       // FADD FSUB
                        case 2b10: { FPUmultiply.start = 1; }                                                                   // FMUL
                        case 2b11: { FPUsqrt.start = function7[3,1]; FPUdivide.start = ~function7[3,1]; }                       // FSQRT / FDIV
                    }
                    while( isbusy ) {}                                                                                          // WAIT FOR FINISH
                } else {
                    FPUmultiply.start = 1; while( isbusy ) {}                                                                   // START 3 REGISTER FUSED FPU OPERATION - MULTIPLY
                    FPUaddsub.start = 1; while( isbusy ) {}                                                                     //                                        ADD / SUBTRACT
                }
                busy = 0;
            }
        }
    }

    always_after {
        uint5   flags = uninitialised;                                                                                          // UNIT RESULT FLAGS
        {
            if( isbusy ) {
                onehot( unitbusy ) {                                                                                            // SELECT EXPONENT FOR ROUNDING AND COMBINING
                    case 0: { MAKERESULT.exponent = FPUaddsub.sumexp; }
                    case 1: { MAKERESULT.exponent = FPUmultiply.productexp; }
                    case 2: { MAKERESULT.exponent = FPUdivide.quotientexp; }
                    case 3: { MAKERESULT.exponent = FPUsqrt.squarerootexp; }
                }
            }
        }
        {
            if( isbusy ) {
                onehot( unitbusy ) {                                                                                            // SELECT NORMALISED FRACTION FOR ROUNDING AND COMBINING
                    case 0: { MAKERESULT.bitstream = FPUaddsub.normalfraction; }
                    case 1: { MAKERESULT.bitstream = FPUmultiply.normalfraction; }
                    case 2: { MAKERESULT.bitstream = FPUdivide.normalfraction; }
                    case 3: { MAKERESULT.bitstream = FPUsqrt.normalfraction; }
                }
            }
        }
        {
            if( isbusy ) {                                                                                                      // SELECT RESULT SIGN FOR ROUNDING AND COMBINING
                MAKERESULT.sign = |( { 1b0, FPUdivide.quotientsign, FPUmultiply.productsign, FPUaddsub.sumsign } & unitbusy );
            }
        }
        {                                                                                                                       // SELECT RESULT
            if( opCode[2,1] ) {                                                                                                 // SINGLE OPERATION
                switch( function7[0,2] ) {
                    default: { result = FPUaddsub.result; }                                                                     // FADD FSUB
                    case 2b10: { result = FPUmultiply.result; }                                                                 // FMUL
                    case 2b11: { result = function7[3,1] ? FPUsqrt.result : FPUdivide.result; }                                 // FSQRT FDIV
                }
            } else {                                                                                                            // FUSED OPERATIONS
                result = FPUaddsub.result;
            }
        }
        { FPUnewflags = FPUflags[0,5] | flags; }                                                                                // RETURN NEW FLAGS
        {                                                                                                                       // SELECT FLAGS
            if( opCode[2,1] ) {                                                                                                 // SINGLE OPERATION
                switch( function7[0,2] ) {
                    default: { flags = FPUaddsub.flags & 5b00110; }                                                             // FADD FSUB
                    case 2b10: { flags = FPUmultiply.flags & 5b00110; }                                                         // FMUL
                    case 2b11: { flags = function7[3,1] ? FPUsqrt.flags & 5b00110 : FPUdivide.flags & 5b01110; }                // FSQRT FDIV
                }
            } else {                                                                                                            // FUSED OPERATIONS
                flags = ( FPUmultiply.flags & 5b10110 ) | ( FPUaddsub.flags & 5b00110 );
            }
        }
    }
}

// Rob Shelton ( @robng15 Twitter, @rob-ng15 GitHub )
// Simple 32bit FPU calculation/conversion routines
// Designed for as small as FPGA usage as possible,
// not for speed.
//
// Copyright (c) 2021 Rob Shelton
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// Donated to Silice by @sylefeb
// MIT license, see LICENSE_MIT in Silice repo root
//
// NB: Error states are those required by Risc-V floating point

// IDENTIFY { infinity, signalling NAN, quiet NAN, ZERO } CHECKS FOR NAN-BOXING OF FLOAT
unit typeF(
    input   uint1   df,                                                                                                         // DOUBLE OR FLOAT FLAG
    input   uint64  a,                                                                                                          // REGISTER VALUE TO CHECK
    output  uint4   type                                                                                                        // { INF sNAN qNAN ZERO } OF INPUT REGISTER
) <reginputs> {
    uint1   expFF <:: df ? &fp64(a).exponent : &fp32(a).exponent;                                                               // CHECK FOR EXP = ALL 1s ( signals INF/NAN )
    uint1   zeroFRACTION <:: df ? ~|fp64(a).fraction : ~|fp32(a).fraction;                                                      // FRACTION == 0, INF, == 100... qNAN, == 0xxx... ( xxx... != 0 ) sNAN
    uint1   boxed <:: &a[32,32];                                                                                                // NAN-boxing, upper 32 bits all 1s

    always_after {
        type = df ? { expFF & zeroFRACTION,                                                                                     // INF
                      expFF & ~fp64(a).fraction[51,1] & ~zeroFRACTION,                                                          // sNAN
                      expFF & fp64(a).fraction[51,1],                                                                           // qNAN
                      ~|( fp64(a).exponent ) } :                                                                                // ZERO / SUBNORMAL
               boxed ?
                    { expFF & zeroFRACTION,                                                                                     // INF
                      expFF & ~fp32(a).fraction[22,1] & ~zeroFRACTION,                                                          // sNAN
                      expFF & fp32(a).fraction[22,1],                                                                           // qNAN
                      ~|( fp32(a).exponent ) } :                                                                                // ZERO / SUBNORMAL
                    4b0010;                                                                                                     // FLOAT NOT BOXED, ISSUE qNAN

    }
}

// CONVERSIONS TO HANDLE FCVT.dest.source
unit intlong2floatdouble(                                                                                                       // 32/64 BIT INTEGER TO 32/64 BIT FLOATING POINT, NAN BOXED FOR 32 BIT FLOATING POINT
    input   uint3   rm,                                                                                                         // ROUDNING MODE
    input   uint1   dounsigned,                                                                                                 // UNSIGNED CONVERSION FLAG
    input   uint1   il,                                                                                                         // FROM INTEGER == 0 OR LONG == 1
    input   uint1   df,                                                                                                         // TO DOUBLE == 1 OR FLOAT == 0
    input   uint64  sourceReg1,                                                                                                 // REGISTER VALUE TO CONVERT
    input   uint32  S1_abs32,                                                                                                   // 32 bit ABSOLUTE VALUE
    input   uint64  S1_abs64,                                                                                                   // 64 bit ABSOLUTE VALUE
    output  uint64  result,                                                                                                     // RESULTING DOUBLE OR FLOAT
    output  uint1   FPUflags                                                                                                    // FPU FLAGS
) <reginputs> {
    uint64  number <:: il ? sign ? S1_abs64 : sourceReg1 : sign ? S1_abs32 : sourceReg1[0,32];                                  // EXTRACT ABSOLUTE VALUE
    clz64 CLZ( number <: number );                                                                                              // COUNT LEADING ZEROS

    uint1   sign <:: ~dounsigned & sourceReg1[ il ? 63 : 31, 1 ];                                                               // EXTRACT SIGN IF SIGNED CONVERSION
    uint1   NZ <:: |( il ? sourceReg1 : sourceReg1[0,32] );                                                                     // CHECK IF NOT ZERO
    uint1   NX <:: df ? ( il ? ( CLZ.zeros < 10 ) : 0 ) : ( CLZ.zeros < 40 );                                                   // DETERMINE IF NOT EXACT, TOO MANY BITS
    int13   exponent <:: ( df ? 1086 : 190 ) - CLZ.zeros;                                                                       // GENERATE EXPONENT AND ADD BIAS
    uint64  fraction <:: number << CLZ.zeros;                                                                                   // GENERATE FRACTION BY SHIFTING TO THE LEFT
    uint1   roundingbit <:: fraction[ il ? 10 : 39, 1 ] & ( rm != 3b001 );                                                      // EXTRACT ROUNDING BIT OR ZERO IF ROUND TO ZERO
    uint52  fraction52 <:: fraction[11,52] + roundingbit;                                                                       // GENERATE ROUNDED FRACTION FOR DOUBLE
    uint23  fraction23 <:: fraction[40,23] + roundingbit;                                                                       // GENERATE ROUNDED FRACTION FOR FLOAT

    always_after {
        { result =  df ? NZ ? { sign, exponent[0,11], fraction52 } : 64h00000000000 :                                           // GENERATE DOUBLE OR ZERO
                         NZ ? { 32hffffffff, sign, exponent[0,8], fraction23 } : 64hffffffff00000000; }                         // GENERATE FLOAT OR ZERO ( NAN boxed )
        { FPUflags = NX; }                                                                                                      // FLAGS
    }
}

unit floatdouble2intlong(                                                                                                       // 32/64 BIT FLOATING POINT TO 32/64 BIT INTEGER, SIGN EXTENSION FOR SIGNED CONVERSIONS
    input   uint3   rm,                                                                                                         // ROUDNING MODE
    input   uint1   dounsigned,                                                                                                 // UNSINGED CONVERSION FLAG
    input   uint1   il,                                                                                                         // TO INTEGER == 0 OR LONG == 1
    input   uint1   df,                                                                                                         // FROM DOUBLE == 1 OR FLOAT == 0
    input   uint64  sourceReg1F,                                                                                                // REGISTER VALUE TO CONVERT
    input   uint4   typeAF,                                                                                                     // { INF sNAN qNAN ZERO } OF INPUT REGISTER
    output  uint64  result,                                                                                                     // RESULTING LONG OR INTEGER
    output  uint5   FPUflags                                                                                                    // FPU FLAGS
) <reginputs> {
    uint1   sign <:: sourceReg1F[ df ? 63 : 31, 1 ];                                                                            // EXTRACT SIGN BIT
    int13   exp <:: ( df ? fp64( sourceReg1F ).exponent : fp32( sourceReg1F ).exponent ) - ( df ? 1023 : 127 );                 // EXTRACT EXPONENT AND REMOVE BIAS
    uint1   NV <:: ( exp > ( dounsigned ? il ? 63 : 31 : il ? 62 : 30 ) ) | ( dounsigned & sign ) | typeAF[3,1] | |typeAF[1,2]; // INVALID IF TOO LARGE, UNSIGNED AND NEGATIVE, INFINITY OR NAN
    uint65  fraction <:: ( il ? ( df ? { 1b1, fp64( sourceReg1F ).fraction, 12b0 } :                                            // EXTRACT FRACTION AND EXTEND TO 65 BITS
                                       { 1b1, fp32( sourceReg1F ).fraction, 41b0 } ) :
                                ( df ? { 1b1, sourceReg1F[20,32] } :                                                            // EXTRACT FRACTION AND CUT OR EXTEND TO 33 BITS
                                       { 1b1, fp32( sourceReg1F ).fraction, 9b0 } ) )
                          >> ( ( il ? 63 : 31 ) - exp );                                                                        // SHIFT RIGHT TO ALIGN
    uint1   roundingbit <:: fraction[0,1] & ( rm != 3b001 );                                                                    // EXTRACT ROUNDING BIT
    uint64  unsignedfraction <:: fraction[1,64] + roundingbit;                                                                  // GENERATE ROUNDED 64 bit ABSOLUTE INTEGER
    uint32  unsignedfraction32 <:: fraction[1,32] + roundingbit;                                                                // GENERATE ROUNDED 32 bit ABSOLUTE INTEGER

    uint64  min <:: il ? 64h8000000000000000 : 64hffffffff80000000;                                                             // MINIMUM NEGATIVE INTEGER
    uint64  max <:: il ? 64h7fffffffffffffff : 64h000000007fffffff;                                                             // MAXIMUM POSITIVE INTEGER

    always_after {
        {
            if( typeAF[0,1] ) {
                result = 0;                                                                                                     // ZERO INPUT RETURN ZERO
            } else {
                if( dounsigned ) {
                    if( NV ) {
                        result = sign ? 0 : 64hffffffffffffffff;                                                                // 0 IF SIGNED, -1 IF NAN OR +INF
                    } else {
                        result = il ? unsignedfraction : unsignedfraction32;                                                    // RETURN UNSIGNED FRACTIVE
                    }
                } else {
                    if( NV ) {
                        result = sign ? min : max;                                                                              // MIN FOR SIGNED OUT OF RANGE, MAX FOR UNSIGNED OUT OF RANGE
                    } else {
                        result =  : il ? sign ? -unsignedfraction : unsignedfraction :                                          // RETURN CORRECTLY SIGNED RESULT
                                         sign ? -unsignedfraction32 : unsignedfraction32;
                    }
                }
            }
        }
        { FPUflags = { NV, 4b0000 }; }                                                                                          // FLAGS
    }
}

unit changeprecision(                                                                                                           // FLOAT <-> DOUBLE ( EXTEND OR TRUNCATE )
    input   uint1   df,                                                                                                         // TO DOUBLE == 1 OR FLOAT == 0
    input   uint64  sourceReg1F,                                                                                                // REGISTER VALUE TO EXTEND / TRUNCATE
    input   uint4   typeAS,                                                                                                     // { INF sNAN qNAN ZERO } ASSUMING FLOAT
    input   uint4   typeAD,                                                                                                     // { INF sNAN qNAN ZERO } ASSUMING DOUBLE
    output  uint64  result,                                                                                                     // EXTENDED OR TRUNCATED RESULT
    output  uint3   FPUflags                                                                                                    // FPU FLAGS
) <reginputs> {
    uint4   typeAF <:: df ? typeAS : typeAD;                                                                                    // SELECT TYPE FOR SINGLE / DOUBLE
    uint1   sign <:: df ? fp32( sourceReg1F ).sign : fp64( sourceReg1F ).sign;                                                  // SELECT SIGN BIT
    int13   exp <:: ( df ? fp32( sourceReg1F ).exponent : fp64( sourceReg1F ).exponent ) + ( df ? 896 : -896 );                 // SELECT EXPONENT AND ADJUST BOAS

    uint64  xINF <:: df ? { sign, 63h7FF0000000000000 } : { 32hffffffff, sign, 31h7f800000 };                                   // RETURN SIGNED INFINITY FOR 32/64 bit
    uint64  sNAN <:: df ? 64h7FF4000000000000 : 64hffffffff7fa00000;                                                            // RETURN sNAN FOR 32/64 bit
    uint64  qNAN <:: df ? 64h7FF8000000000000 : 64hffffffff7fc00000;                                                            // RETURN qNAN FOR 32/64 bit
    uint64  xZERO <:: df ? { sign, 63h0 } : { 32hffffffff, sign, 31h0 };                                                        // RETURN SIGNED ZERO FOR 32/64 bit

    uint1   OF = uninitialised;                                                                                                 // OVERFLOW FLAG
    uint1   UF = uninitialised;                                                                                                 // UNDERFLOW FLAG
    OF := 0; UF := 0;                                                                                                           // HOLD AT ZERO

    always_after {
        {
            switch( typeAF ) {
                default: {
                    if( df ) {
                        result = { fp32( sourceReg1F ).sign, exp[0,11], fp32( sourceReg1F ).fraction, 29b0 };                   // VALID NUMBER, TO DOUBLE ALWAYS SUCEEDS
                    } else {
                        if( &exp[0,8] | |exp[8,4] ) {
                            result = xINF; OF = 1;                                                                              // VALID NUMBER, TO FLOAT BUT OVERFLOWED RETURN SIGNED INFINITY
                        } else {
                            if( exp[12,1] ) {
                                result = xZERO; UF = 0;                                                                         // VALID NUMBER, TO FLOAT BUT UNDERFLOWED RETURN SIGNED ZERO
                            } else {
                                result = { 32hffffffff, sign, exp[0,8], fp64( sourceReg1F ).fraction[29,23] };                  // VALID NUMBER, TO FLOAT ( NAN boxed )
                            }
                        }
                    }
                }
                case 4b1000: { result = xINF; }                                                                                 // INPUT IS INFINITY
                case 4b0100: { result = sNAN; }                                                                                 // INPUT IS sNAN
                case 4b0010: { result = qNAN; }                                                                                 // INPUT IS qNAN
                case 4b0001: { result = xZERO; }                                                                                // INPUT IS ZERO
            }
        }
        { FPUflags =    { OF, UF, 1b0 }; }                                                                                      // FLAGS
    }
}

// NORMALISE A 106 BIT MANTISSA SO THAT THE MSB IS ONE, FOR ADDSUB ALSO DECREMENT THE EXPONENT FOR EACH SHIFT LEFT
// EXTRACT THE 53 BITS FOLLOWING THE MSB (1.xxxx) FOR ROUNDING
unit donormal(
    input   uint106 bitstream,                                                                                                  // RESULT FROM CALCULATION
    output  uint53  normalfraction                                                                                              // NORMALISED FRACTION 1.xxx
) <reginputs> {
    clz106 CLZ106( bitstream <: bitstream );                                                                                    // COUNT LEADING ZEROS
    uint106 temporary <:: ( bitstream << CLZ106.count );                                                                        // SHIFT FRACTION LEFT SO 1.xxxx

    always_after {
        { normalfraction = temporary[ 52, 53 ]; }                                                                               // EXTRACT 53 BITS ( 1 extra for rounding )
    }
}
unit donormalexp(
    input   int13   exp,                                                                                                        // EXPONENT FROM ADDITION / SUBTRACTION
    input   uint106 bitstream,                                                                                                  // RESULT FROM CALCULATION
    output  int13   newexponent,                                                                                                // ADJUSTED EXPONENT FOR ADDITION / SUBTRACTION
    output  uint53  normalfraction                                                                                              // NORMALISED FRACTION 1.xxx
) <reginputs> {
    clz106 CLZ106( bitstream <: bitstream );                                                                                    // COUNT LEADING ZEROS
    uint106 temporary <:: ( bitstream << CLZ106.count );                                                                        // SHIFT FRACTION LEFT SO 1.xxxx

    always_after {
        { normalfraction = temporary[ 52, 53 ]; }                                                                               // EXTRACT 53 BITS ( 1 extra for rounding )
        { newexponent = exp - CLZ106.count; }                                                                                   // ADDSUB EXPONENT ADJUSTMENT
    }
}

// ROUND 52 ( double ) 23 ( float ) BIT FRACTION FROM NORMALISED FRACTION USING NEXT TRAILING BIT
// ADD BIAS TO EXPONENT AND ADJUST EXPONENT IF ROUNDING FORCES
// COMBINE COMPONENTS TO FLOATING POINT NUMBER - USED BY CALCULATIONS
// UNDERFLOW return 0, OVERFLOW return infinity
unit overflow(
    input   uint1   df,
    input   int13   exponent,
    output! uint1   OF
) <reginputs> {
    always_after { OF = ( exponent > ( df ? 2046 : 254 ) ); }                                                                   // OVERFLOW IF EXPONENT PLUS BIAS IS > 2 * BIAS
}
unit newexp(
    input   uint1   df,
    input   uint53  roundfraction,
    input   uint1   lsb,
    input   int13   exponent,
    output  int13   newexponent
) <reginputs> {
    always_after {
        newexponent = ( df ? ( ( ~|roundfraction[0,52] & lsb ) ? 1024 : 1023 ) :                                                // IF ROUNDING OVERFLOWED INCREASE EXPONENT BY 1
                             ( ( ~|roundfraction[0,23] & lsb ) ? 128 : 127 ) ) + exponent;                                      // WHEN ADDING BIAS
    }
}
unit doroundcombine(
    input   uint3   rm,                                                                                                         // ROUNDING MODE ( RNE OR RTZ SUPPORTED )
    input   uint1   df,                                                                                                         // DOUBLE OR FLOAT
    input   uint1   sign,                                                                                                       // RESULT SIGN
    input   uint53  bitstream,                                                                                                  // NORMALISED BITSTREAM 1.xxxx
    input   int13   exponent,                                                                                                   // EXPONENT ( no bias )
    output! uint1   OF,                                                                                                         // OVERFLOW FLAG
    output! uint1   UF,                                                                                                         // UNDERFLOW FLAG
    output! uint64  combined                                                                                                    // COMBIUNED DOUBLE OR FLOAT ROUNDED AND COMBINED
) <reginputs> {
    uint1   lsb <:: ( rm == 3b001 ) ? 0 : bitstream[ df ? 0 : 29, 1 ];                                                          // EXTRACT TRAILING BIT AFTER FRACTIONAL PART FOR ROUNDING OR 0 IF RTZ
    uint52  roundfraction <:: df ? ( bitstream[1,52] + lsb ) :  ( bitstream[30,23] + lsb );                                     // EXTRACT RESULT FRACTION AND PERFORM ROUNDING
    newexp EXP( df <: df, lsb <: lsb, roundfraction <: roundfraction, exponent <: exponent );                                   // GENERATE RESULT EXP, ADJUSTED IF ROUNDING OVERFLOWED
    overflow OVER( df <: df, exponent <: EXP.newexponent, OF :> OF );                                                           // CHECK FOR OVERFLOW ( exponent > 2 * bias )

    uint64  xZERO <:: df ? { sign, 63h0 } : { 32hffffffff, sign, 31h0 };                                                        // RETURN SIGNED ZERO FOR 32/64 bit
    uint64  xINF <:: df ? { sign, 63h7FF0000000000000 } : { sign, 63hffffffff7f800000 };                                        // RETURN SIGNED INFINITY FOR 32/64 bit

    always_after {
        { UF = EXP.newexponent[12,1]; }                                                                                         // UNDERFLOW IF EXPONENT IS NEGATIVE
        { combined = EXP.newexponent[12,1] ? xZERO : OVER.OF ? xINF :                                                           // UNDERFLOW RETURN SIGNED ZERO, OVERFLOW RETTURN SIGNED INFINITY
                                             df ? { sign, EXP.newexponent[0,11], roundfraction } :                              // RETURN DOUBLE RESULT
                                                  { 32hffffffff, sign, EXP.newexponent[0,8], roundfraction[0,23] }; }           // RETURN FLOAT RESULT ( NAN boxed )
    }
}

// ADDSUB ADD/SUBTRACT TWO FLOATING POINT NUMBERS ( SUBTRACT ACHIEVED BY ALTERING SIGN OF SECOND INPUT BY CALCULATION CONTROL UNIT ABOVE )
unit equaliseexpaddsub(
    input   uint1   df,
    input   uint64  a,
    input   uint64  b,
    output  uint106 newsigA,
    output  uint106 newsigB,
    output  int13   resultexp,
) <reginputs> {
    // BREAK DOWN INITIAL float32 INPUTS - SWITCH SIGN OF B IF SUBTRACTION
    uint106 sigA <:: df ? { 2b01, fp64(a).fraction, 52b0 } : { 2b01, fp32(a).fraction, 81b0 };                                  // LEFT ALIGN FRACTIONS
    uint106 sigB <:: df ? { 2b01, fp64(b).fraction, 52b0 } : { 2b01, fp32(b).fraction, 81b0 };                                  // LEFT ALIGN FRACTIONS
    uint1   AvB <:: ( df ? fp64(a).exponent : fp32(a).exponent ) < ( df ? fp64(b).exponent : fp32(b).exponent );                // FIND SMALLEST EXPONENT
    uint106 aligned <:: ( AvB ? sigA : sigB ) >>                                                                                // SHIFT SMALLER INPUT RIGHT BY DIFFERENCE IN EXPONENTS
                        ( ( AvB ? ( df ? fp64(b).exponent : fp32(b).exponent ) : ( df ? fp64(a).exponent : fp32(a).exponent ) ) -
                          ( AvB ? ( df ? fp64(a).exponent : fp32(a).exponent ) : ( df ? fp64(b).exponent : fp32(b).exponent ) ) );

    always_after {
        { newsigA = AvB ? aligned : sigA; }                                                                                     // A BECOMES ALIGNED FRACTION IF SMALLER EXPONENT
        { newsigB = AvB ? sigB : aligned;  }                                                                                    // B BECOMES ALIGNED FRACTION IF SMALLER EXPONENT
        { resultexp = ( AvB ? ( df ? fp64(b).exponent : fp32(b).exponent ) : ( df ? fp64(a).exponent : fp32(a).exponent ) ) -   // RESULT EXPONENT IS LARGEST EXPONENT ( +1 FOR OVERFLOW )
                              ( df ? 1022 : 126 ); }
    }
}
unit dofloataddsub(
    input   uint1   df,
    input   uint1   signA,
    input   uint106 sigA,
    input   uint1   signB,
    input   uint106 sigB,
    output  uint1   resultsign,
    output  uint106 resultfraction
) <reginputs> {
    uint1   AvB <:: ( sigA > sigB );                                                                                            // FIND LARGEST FRACTION ( when exponents are equal )
    uint1   sign <:: ( signA ^ signB ) ? ( signA ? AvB : ~AvB ) : signA;                                                        // DETERMINE RESULT SIGN

    always_after {
        { resultsign = sign; }                                                                                                  // GENERATE RESULT SIGN
        { if( signA ^ signB ) {
            resultfraction = ( signA ^ sign ? sigB : sigA ) - ( signA ^ sign ? sigA : sigB );                                   // PERFORM SUBTRACTION
        } else {
            resultfraction = sigA + sigB; }                                                                                     // PERFORM DIVISION
        }
    }
}
unit floataddsub(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint1   df,                                                                                                         // DOUBLE OR FLOAT
    input   uint64  a,                                                                                                          // A INPUT FOR A+B OR A-B
    input   uint64  b,                                                                                                          // B INPUT FOR A+B OR A-B
    input   uint4   typeAF,                                                                                                     // { INF sNAN qNAN ZERO } FOR A
    input   uint4   typeBF,                                                                                                     // { INF sNAN qNAN ZERO } FOR B
    output  uint1   sumsign,                                                                                                    // RESULT SIGN
    output  int13   sumexp,                                                                                                     // RESULT EXPONENT
    output  uint53  normalfraction,                                                                                             // NORMALISED RESULT FRACTION
    input   uint1   OF,                                                                                                         // OVERFLOW FLAG
    input   uint1   UF,                                                                                                         // UNDERFLOW FLAG
    input   uint64  combined,                                                                                                   // DOUBLE OR FLOAT RESULT ROUNDED AND COMBINED
    output  uint5   flags,                                                                                                      // OPERATION FLAGS
    output  uint64  result                                                                                                      // RESULT OF CALCULATION
) <reginputs> {
    uint1   signA <:: df ? fp64( a ).sign : fp32( a ).sign;                                                                     // SIGN A
    uint1   signB <:: df ? fp64( b ).sign : fp32( b).sign;                                                                      // SIGN B
    uint1   IF <:: ( typeAF[3,1] | typeBF[3,1] );                                                                               // DETECT INFINITY
    uint1   NN <:: ( |typeAF[1,2] | |typeBF[1,2] );                                                                             // DETECT NAN
    uint1   NV <:: ( typeAF[3,1] & typeBF[3,1]) & ( signA ^ signB );                                                            // INVALID IF BOTH INFINITY WITH DIFFERING SIGNS
    uint2   ACTION <:: { IF | NN, typeAF[0,1] | typeBF[0,1] };                                                                  // DO ADDITION IF NOT INFINITY, NAN OR ZERO

    uint64  qNAN <:: df ? 64h7FF8000000000000 : 64hffffffff7fc00000;                                                            // RETURN qNAN FOR 32/64 bit
    uint64  ZERO <:: df ? 0 : 64hffffffff00000000;                                                                              // RETURN ZERO FOR 32/64 bit

    equaliseexpaddsub EQUALISEEXP( df <: df, a <: a, b <: b );                                                                  // EQUALISE THE EXPONENTS AND ALIGN THE FRACTIONS
    dofloataddsub ADDSUB(                                                                                                       // 1 IS ADDED TO THE EXPONENT IN CASE OF OVERFLOW, NORMALISING WILL ADJUST
        df <: df,
        signA <: signA, sigA <: EQUALISEEXP.newsigA,                                                                            // PASS ALIGNED FRACTIONS AND SIGN FOR ADDITION / SUBTRACTION
        signB <: signB, sigB <: EQUALISEEXP.newsigB,
        resultsign :> sumsign                                                                                                   // PASS THE RESULT SIGN
    );
    donormalexp NORMAL(
        exp <: EQUALISEEXP.resultexp,
        bitstream <: ADDSUB.resultfraction,
        newexponent :> sumexp,
        normalfraction :> normalfraction
    );

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1; if( ~|ACTION & |ADDSUB.resultfraction ) { ++: ++: busy = 0; } else { busy = 0; }                      // PROVIDE WAIT STATES
            }
        }
    }

    always_after {
        {
            switch( ACTION ) {
                case 2b00: { result = |ADDSUB.resultfraction ? combined : ZERO; }                                               // CALCULATION IS VALID, CHECK FOR ZERO RESULT
                case 2b01: {
                    result = ( typeAF[0,1] & typeBF[0,1] ) ? ZERO : df ? ( typeBF[0,1] ? a : b ) :                              // ZERO INPUT, CHECK FOR BOTH OR RETURN OTHER
                                                                         { 32hffffffff, typeBF[0,1] ? a[0,32] : b[0,32] };
                }
                default: {
                    switch( { IF, NN } ) {
                        case 2b10: {
                            result = NV ? qNAN : df ? ( typeAF[3,1] ? a : b ) :                                                 // INFINITY RETURN NAN IF OPPOSITE SIGNS ELSE RETURN INFINITY
                                                      { 32hffffffff, typeAF[3,1] ? a[0,32] : b[0,32] };
                        }
                        default: { result = qNAN; }                                                                             // NAN RETURN NAN
                    }
                }
            }
        }
        { flags = { NV, 1b0, ~|ACTION & OF, ~|ACTION & UF, 1b0 }; }
    }
}

// MULTIPLY TWO FLOATING POINT NUMBERS
unit floatmultiply(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint1   df,                                                                                                         // DOUBLE OR FLOAT
    input   uint64  a,                                                                                                          // A INPUT FOR A*B
    input   uint64  b,                                                                                                          // B INPUT FOR A*B
    input   uint4   typeAF,                                                                                                     // { INF sNAN qNAN ZERO } FOR A
    input   uint4   typeBF,                                                                                                     // { INF sNAN qNAN ZERO } FOR B
    output  uint1   productsign,                                                                                                // RESULT SIGN
    output  int13   productexp,                                                                                                 // RESULT EXPONENT
    output  uint53  normalfraction,                                                                                             // NORMALISED RESULT FRACTION
    input   uint1   OF,                                                                                                         // OVERFLOW FLAG
    input   uint1   UF,                                                                                                         // UNDERFLOW FLAG
    input   uint64  combined,                                                                                                   // DOUBLE OR FLOAT RESULT ROUNDED AND COMBINED
    output  uint5   flags,                                                                                                      // OPERATION FLAGS
    output  uint64  result                                                                                                      // RESULT OF CALCULATION
) <reginputs> {
    uint1   ZERO <:: (typeAF[0,1] | typeBF[0,1] );                                                                              // DETECT ZERO
    uint1   IF <:: ( typeAF[3,1] | typeBF[3,1] );                                                                               // DETECT INFINITY
    uint1   NN <:: ( |typeAF[1,2] | |typeBF[1,2] );                                                                             // DETECT NAN
    uint1   NV <:: IF & ZERO;                                                                                                   // INVALID IF INFINITY x ZERO
    uint2   ACTION <:: { IF | NN, ZERO };

    uint64  qNAN <:: df ? 64h7FF8000000000000 : 64hffffffff7fc00000;                                                            // RETURN qNAN FOR 32/64 bit
    uint64  xINF <:: df ? { productsign, 63h7FF0000000000000 } : { 32hffffffff, productsign, 31h7f800000 };                     // RETURN SIGNED INFINITY FOR 32/64 bit
    uint64  xZERO <:: df ? { productsign, 63h0 } : { 32hffffffff, productsign, 31h0 };                                          // RETURN SIGNED ZERO FOR 32/64 bit

    uint106  product <:: ( df ? { 1b1, fp64( a ).fraction } : { 1b1, fp32( a ).fraction, 29b0 } ) *                             // CALCULATE THE PRODUCT BY MUTLIPLYING LEFT ALIGNED FRACTIONS
                         ( df ? { 1b1, fp64( b ).fraction } : { 1b1, fp32( b ).fraction, 29b0 } );

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1; if( |ACTION ) { busy = 0; } else { ++: ++: busy = 0; }                                                // PROVIDE WAIT STATES
            }
        }
    }

    always_after {
        { productsign = ( df ? fp64( a ).sign : fp32( a ).sign ) ^ ( df ? fp64( b ).sign : fp32( b ).sign ); }                  // GENERATE PRODUCT SIGN
        { productexp = ( df ? fp64( a ).exponent : fp32( a ).exponent ) + ( df ? fp64( b ).exponent : fp32( b ).exponent )      // ADD EXPONENTS FOR RESULT EXPONENT
                       - ( df ? ( product[105,1] ? 2045 : 2046 ) : ( product[105,1] ? 253 : 254 ) ); }                          //      ( +1 if overflow )
        { normalfraction = product[ product[105,1] ? 52 : 51, 53 ]; }                                                           // EXTRACT 53 BITS ( 1 extra for rounding )
        {
            switch( ACTION ) {
                case 2b00: { result = combined; }                                                                               // MULTIPLICATION IS VALID
                case 2b01: { result = xZERO; }                                                                                  // ZERO INPUT RETURN ZERO
                default: {
                    switch( { IF, ZERO } ) {
                        case 2b11: { result = qNAN; }                                                                           // INFINITY x ZERO RETURN qNAN
                        case 2b10: { result = NN ? qNAN : xINF; }                                                               // NAN OR INFITITY RETURN qNAN OR INFINITY
                        default: { result = qNAN; }                                                                             // NAN OR ZERO RETURN qNAN
                    }
                }
            }
        }
        {  flags = { NV, 1b0, ~|ACTION & OF, ~|ACTION & UF, 1b0 }; }                                                            // RETURN FLAGS
    }
}

// DIVIDE TWO FLOATING POINT NUMBERS
unit prepfdiv(
    input   uint1   df,                                                                                                         // DOUBLE OR FLOAT
    input   uint64  a,                                                                                                          // A INPUT FOR A/B
    input   uint64  b,                                                                                                          // B INPUT FOR A/B
    output  uint1   powTWO,
    output  uint1   quotientsign,                                                                                               // RESULT SIGN
    output  int13   quotientexp,                                                                                                // RESULT EXPONENT
    output  uint108 sigA,                                                                                                       // DIVIDEND LEFT ALIGNED
    output  uint106 sigB                                                                                                        // DIVISOR RIGHT ALIGNED
) <reginputs> {
    always_after {
        { quotientsign = ( df ? fp64( a ).sign : fp32( a ).sign ) ^ ( df ? fp64( b ).sign : fp32( b ).sign ); }                 // GENERATE QUOTIENT SIGN
        { quotientexp = ( df ? fp64( a ).exponent : fp32( a ).exponent ) - ( df ? fp64( b ).exponent : fp32( b ).exponent )     // SUBTRACT EXPONENTS FOR RESULT EXPONENT
                      - ( ( df ? fp64(b).fraction : fp32(b).fraction ) > ( df ? fp64(a).fraction : fp32(a).fraction ) ); }      //      ( -1 if b fraction > a fraction )
        { sigA = df ? { 1b1, fp64(a).fraction, 55b0 } : { 1b1, fp32(a).fraction, 26b0 }; }                                      // DIVIDEND LEFT ALIGNED
        { sigB = df ? { 1b1, fp64(b).fraction } : { 1b1, fp32(b).fraction }; }                                                  // DIVISOR RIGHT ALIGNED

       { powTWO = ~|( df ? fp64(b).fraction : fp32(b).fraction ); }                                                             // DETECT FRACTION OF B IS 0 ( B is power of 2, no division required )
    }
}
unit dofloatdivide(
    input   uint1   df,
    input   uint1   start,
    output  uint1   busy(0),
    input   uint108 sigA,
    input   uint108 sigB,
    input   uint1   powTWO,
    output  uint108 quotient(0)
) <reginputs> {
    uint7   bit(127);
    uint108 remainder = uninitialised;
    uint108 temporary <:: df ? { remainder[0,107], sigA[bit,1] } : { remainder[0,49], sigA[bit,1] };
    uint1   bitresult <:: __unsigned(temporary) >= __unsigned(sigB);
    uint108 remainderNEXT <:: __unsigned(temporary) - ( bitresult ? __unsigned(sigB) : 0 );
    uint2   normalshift <:: quotient[ 107, 1 ] ? 2 : quotient[ 106, 1 ];

    always_after {
        // FIND QUOTIENT AND ENSURE 48 BIT FRACTION ( ie BITS 48 and 49 clear )
        if( &bit ) {
            if( start ) {
                busy = 1;
                if( powTWO ) {                                                                                                  // DETECT DIVISION BY POWER OF 2
                    quotient = sigA;                                                                                            //      RETURN DIVIDEND
                } else {
                    bit = df ? 107 : 49; quotient = 0; remainder = 0;                                                           // ZERO quotient and remainder SELECT STARTING BIT
                }
            } else {
                quotient = quotient[ normalshift, 106 ]; busy = 0;                                                              // ADJUST QUOTIENT IF 1 IN BITS 107/106
            }
        } else {
            remainder = remainderNEXT;                                                                                          // PERFORM BIT BY BIT LONG DIVISION
            quotient[ bit, 1 ] = bitresult;                                                                                     // UPDATE THE QUOTIENT
            bit = bit - 1;                                                                                                      // MOVE TO THE NEXT BIT
        }
    }
}
unit floatdivide(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint1   df,                                                                                                         // DOUBLE OR FLOAT
    input   uint64  a,                                                                                                          // A INPUT FOR A/B
    input   uint64  b,                                                                                                          // B INPUT FOR A/B
    input   uint4   typeAF,                                                                                                     // { INF sNAN qNAN ZERO } FOR A
    input   uint4   typeBF,                                                                                                     // { INF sNAN qNAN ZERO } FOR B
    output  uint1   quotientsign,                                                                                               // RESULT SIGN
    output  int13   quotientexp,                                                                                                // RESULT EXPONENT
    output  uint53  normalfraction,                                                                                             // NORMALISED RESULT FRACTION
    input   uint1   OF,                                                                                                         // OVERFLOW FLAG
    input   uint1   UF,                                                                                                         // UNDERFLOW FLAG
    input   uint64  combined,                                                                                                   // DOUBLE OR FLOAT RESULT ROUNDED AND COMBINED
    output  uint4   flags,                                                                                                      // OPERATION FLAGS
    output  uint64  result                                                                                                      // RESULT OF CALCULATION
) <reginputs> {
    uint1   IF <:: ( typeAF[3,1] | typeBF[3,1] );                                                                               // DETECT INFINITY
    uint1   NN <:: |typeAF[1,2] | |typeBF[1,2];                                                                                 // DETECT NAN
    uint2   ACTION <:: { IF | NN, typeAF[0,1] | typeBF[0,1] };                                                                  // DO DIVISION IF NOT INFINITY, NAN OR ZERO

    uint64  qNAN <:: df ? 64h7FF8000000000000 : 64hffffffff7fc00000;                                                            // RETURN qNAN FOR 32/64 bit
    uint64  xINF <:: df ? { quotientsign, 63h7FF0000000000000 } : { 32hffffffff, quotientsign, 31h7f800000 };                   // RETURN SIGNED INFINITY FOR 32/64 bit
    uint64  xZERO <:: df ? { quotientsign, 63h0 } : { 32hffffffff, quotientsign, 31h0 };                                        // RETURN SIGNED ZERO FOR 32/64 bit

    prepfdiv PREP( df <: df, a <: a, b <: b, quotientsign :> quotientsign, quotientexp :> quotientexp );                        // // PREPARE THE DIVISION INPUTS
    dofloatdivide DODIVIDE(                                                                                                     // DO THE DIVISION PASS QUOTIENT FOR NORMALISATION
        df <: df,
        sigA <: PREP.sigA,
        sigB <: PREP.sigB,
        powTWO <: PREP.powTWO,
    );
    donormal NORMAL(
        bitstream <: DODIVIDE.quotient,
        normalfraction :> normalfraction
    );
    DODIVIDE.start := start & ~|ACTION; busy := start | DODIVIDE.busy;                                                          // START AND BUSY FLAGS

    always_after {
        {
            switch( ACTION ) {
                case 2b00: { result = combined; }                                                                               // DIVISION IS VALID
                case 2b01: { result = ( typeAF[0,1] & typeBF[0,1] ) ? qNAN : typeBF[0,1] ? xINF : xZERO; }                      // ZERO INPUT, NAN IF BOTH ZERO, INF IF B ZERO, ZERO IF A ZERO
                default: { result = ( typeAF[3,1] & typeBF[3,1] ) | NN | typeBF[0,1] ? qNAN :                                   // qNAN IF INVALID,
                                    ( typeAF[0,1] | typeBF[3,1] ) ? xZERO : xINF; }                                             // ZERO IF A IS ZERO OR B IS INF, INF IF INF / OTHER
            }
        }
        { flags = { typeBF[0,1], ~|ACTION & OF, ~|ACTION & UF, 1b0}; }                                                          // RETURN FLAGS
    }
}

// ADAPTED FROM https://projectf.io/posts/square-root-in-verilog/
//
// MIT License
//
// Copyright (c) 2021 Will Green, Project F
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
unit prepfsqrt(
    input   uint1   df,                                                                                                         // DOUBLE OR FLOAT
    input   uint64  a,                                                                                                          // A INPUT FOR SQRT(A)
    output  uint1   powTWO,
    output  uint1   expODD,
    output  int13   squarerootexp,
    output  uint108 start_ac,
    output  uint106 start_x
) <reginputs> {
    int13   expA  <:: ( df ? fp64( a ).exponent : fp32( a ).exponent ) - ( df ? 1023 : 127 );                                   // EXTRACT EXPONENT AND REMOVE BIAS

    always_after {
        { squarerootexp = expA >>> 1; }                                                                                         // RESULT EXPONENT IS HALF OF INPUT EXPONENT
        { start_ac = expA[0,1] ? { 106b0, 1b1, a[ df ? 51 : 22, 1 ] } : 1; }                                                    // STARTING ACCUMULATOR ( depends if exp is odd / even )
        { start_x = expA[0,1] ? df ? { a[0,51], 55b0 } : { a[0,22], 84b0 } :                                                    // STARTING FRACTION ( depends if exp is odd / even )
                                df ? { fp64( a ).fraction, 54b0 } : { fp32( a ).fraction, 83b0 }; }
        { powTWO = ~|( df ? fp64(a).fraction : fp32(a).fraction ); }                                                            // DETECT FRACTION OF A IS 0 ( A is power of 2, no squareroot required )
        { expODD = expA[0,1]; }                                                                                                 // IS EXP ODD, RETURN SQRT(2) OR 1 FOR POWER OF 2 SQUAREROOTS
    }
}
unit dofloatsqrt(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint1   df,
    input   uint1   powTWO,
    input   uint1   expODD,
    input   uint108 start_ac,
    input   uint106 start_x,
    output  uint54  squareroot
) <reginputs> {
    uint108 test_res <:: ac - { squareroot, 2b01 };
    uint108 ac = uninitialised;
    uint106 x = uninitialised;
    uint6   i(63);

    busy := start | ~&i;

    always_after {
        if( &i ) {
            if( start ) {
                if( powTWO ) {
                    squareroot = expODD ? 54h2D413CCCFE7799 : 1;                                                                // DETECT POWER OF 2 SQUARE ROOT, RETURN ROOT 2 OR 1 IF EXP ODD / EVEN
                } else {
                    i = df ? 53 : 24; squareroot = 0; ac = start_ac; x = start_x;                                               // SELECT STARTING BIT ( counter for number of bits to process )
                }
            }
        } else {
            ac = { test_res[107,1] ? ac[0,105] : test_res[0,105], x[104,2] };                                                   // FIND NEW ACCUMULATOR
            squareroot = { squareroot[0,53], ~test_res[107,1] };                                                                // ADD NEXT BIT TO SQUAREROOT ( shift in from right )
            x = { x[0,104], 2b00 };                                                                                             // MOVE 2 PLACES ALONG REMAINING FRACTION
            i = i - 1;                                                                                                          // MOVE TO NEXT BIT
        }
    }
}
unit floatsqrt(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint1   df,                                                                                                         // DOUBLE OR FLOAT
    input   uint64  a,                                                                                                          // A INPUT FOR SQRT(A)
    input   uint4   typeAF,                                                                                                     // { INF sNAN qNAN ZERO } FOR A
    output  int13   squarerootexp,                                                                                              // RESULT EXPONENT
    output  uint53  normalfraction,                                                                                             // NORMALISED RESULT FRACTION
    input   uint1   OF,                                                                                                         // OVERFLOW FLAG
    input   uint1   UF,                                                                                                         // UNDERFLOW FLAG
    input   uint64  combined,                                                                                                   // DOUBLE OR FLOAT RESULT ROUNDED AND COMBINED
    output  uint5   flags,                                                                                                      // OPERATION FLAGS
    output  uint64  result                                                                                                      // RESULT OF CALCULATION
) <reginputs> {
    uint1   signA <:: df ? fp64( a ).sign : fp32( a ).sign;                                                                     // EXTRACT SIGN
    uint1   NN <:: |typeAF[1,2];                                                                                                // DETECT NAN INPUT
    uint1   NV <:: typeAF[3,1] | NN | signA;                                                                                    // INVALID IF INFINITY, NAN OR NEGATIVE
    uint1   ACTION <:: ~|{ typeAF[3,1] | NN, typeAF[0,1] | signA };                                                             // CALCULATION VALID IF NORMAL POSITIVE NUMBER ( ZERO IS SPECIAL )
    uint64  qNAN <:: df ? 64h7FF8000000000000 : 64hffffffff7fc00000;                                                            // RETURN qNAN FOR 32/64 bit

    prepfsqrt PREP( df <: df, a <: a, squarerootexp :> squarerootexp );                                                         // PREPARE THE SQUAREROOT INPUTS
    dofloatsqrt DOSQRT(                                                                                                         // CALCULATE SQUARE ROOT
        df <: df,
        powTWO <: PREP.powTWO,
        expODD <: PREP.expODD,
        start_ac <: PREP.start_ac,
        start_x <: PREP.start_x
    );
    donormal NORMAL( bitstream <: DOSQRT.squareroot, normalfraction :> normalfraction );                                        // NORMALISE THE SQUARE ROOT
    DOSQRT.start := start & ACTION; busy := start | DOSQRT.busy;                                                                // START AND BUSY FLAGS

    always_after {
        {
            if( ACTION ) {
                result = combined;                                                                                              // CALCULATION VALID
            } else {
                result = signA ? qNAN : a;                                                                                      // CALCULATION INVALID RETURN qNAN IF NEGATIVE ELSE INPUT ( INF OR ZERO )
            }
        }
        { flags = { NV, 1b0, ACTION & OF, ACTION & UF, 1b0 }; }                                                                 // RETURN FLAGS
    }
}

// FLOATING POINT COMPARISONS - ADAPTED FROM SOFT-FLOAT

/*============================================================================

License for Berkeley SoftFloat Release 3e

John R. Hauser
2018 January 20

The following applies to the whole of SoftFloat Release 3e as well as to
each source file individually.

Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018 The Regents of the
University of California.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions, and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors
    may be used to endorse or promote products derived from this software
    without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS resultERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

unit floatcompare(
    input   uint1   df,
    input   uint64  a,
    input   uint64  b,
    input   uint4   typeAF,
    input   uint4   typeBF,
    output  uint1   less,
    output  uint1   equal
) <reginputs> {
    uint1   NAN <:: |typeAF[1,2] | |typeBF[1,2];                                                                                // DETECT NAN
    uint1   aequalb <:: a == b;                                                                                                 // A==B
    uint1   aorbleft1equal0 <:: typeAF[0,1] & typeBF[0,1];                                                                      // ( A<<1 ) | ( B<<1) == 0 ( DETECTS BOTH 0 )
                                                                                                                                // WAS ~|( ( df ? a[0,63] : a[0,31] ) | ( df ? b[0,63] : b[0,31] ) )
    uint1   signA <:: df ? fp64( a ).sign : fp32( a ).sign;                                                                     // SIGN OF A
    uint1   signB <:: df ? fp64( b ).sign : fp32( b ).sign;                                                                     // SIGN OF B

    // RETURN 0 IF NAN, OTHERWISE RESULT OF COMPARISONS
    always_after {
        { less = ~NAN & ( ( signA ^ signB ) ? signA & ~aorbleft1equal0 : ~aequalb & ( signA ^ ( ( df ? a : a[0,32] ) < ( df ? b : b[0,32] ) ) ) ); }
        { equal = ~NAN & ( aequalb | aorbleft1equal0 ); }
    }
}
