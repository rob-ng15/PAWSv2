// Rob Shelton ( @robng15 Twitter, @rob-ng15 GitHub )
// Simple 16/32/64 bit FPU calculation/conversion routines
// Designed for as small as FPGA usage as possible,
// not for speed.
//
// Copyright (c) 2021 Rob Shelton
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// Donated to Silice by @sylefeb
// MIT license, see LICENSE_MIT in Silice repo root
//
// NB: dsh represents the precision of the flaoting-point inputs single == 00, double == 01, half == 10
//     as per the Risc-V function7[0,2] bits
// NB: All calculations and conversions expect to receive repackaged floating-point inputs.
//     Half and Single precision floating-point numbers are expanded to fit into the bitfields
//     of double precision numbers. Repackers are provided to expand/truncate inputs/results
//     with nan-boxing of half and single precision numbers.
// NB: All calculations return their results in the bitfields of double precision numbers.
//     These are repackaged in the CPU floating-point controller to their actual format.
// NB: The floating-point exponent bias is generated in the CPU floating-point controller
//     and passed to those operations which require it.
// NB: rm represents the rounding mode, only RTE (000) and RTZ(001) are supported.
// NB: The typeAF/typeBF/typeCF inputs detect exception inputs for each of the input registers,
//     and are 4 bits each for { infinity, signalling NAN, quiet NAN, ZERO } and will signal a
//     NAN if a half or single precision input is not nan-boxed.
// NB: subnormal inputs are presently detected and treated as zero.
// NB: Error states are those required by Risc-V floating point

// FMIN FMAX FSGNJ FSGNJN FSGNJX FEQ FLT FLE FCLASS FMV
unit floatclass(                                                                                                                // CLASSIFY FLOATING POINT INPUT ( FCLASS.S FCLASS.D )
    input   uint2   dsh,                                                                                                        // DOUBLE/SINGLE/HALF FLAG
    input   uint1   sign1F,                                                                                                     // SIGN OF FLOATING-POINT REGISTER
    input   uint1   aZEROFRACTION,                                                                                              // A FRACTION PART 0, TRUE ZERO OR SUBNORMAL
    input   uint4   typeAF,                                                                                                     // { INF sNAN qNAN ZERO } OF REGISTER INPUT
    output  uint10  FCLASS                                                                                                      // 10 bit INTEGER CLASSIFICATION OF REGISTER INPUT
) <reginputs> {
    FCLASS := {  typeAF[1,1],                                                                                                   // 512  qNAN
                 typeAF[2,1],                                                                                                    // 256  sNAN
                 typeAF[3,1] & ~sign1F,                                                                                         // 128  +INF
                 ~|typeAF & ~sign1F,                                                                                            // 64   +NORMAL
                 typeAF[0,1] & ~sign1F & ~aZEROFRACTION,                                                                        // 32   +SUBNORMAL
                 typeAF[0,1] & ~sign1F & aZEROFRACTION,                                                                         // 16   +0
                 typeAF[0,1] & sign1F & aZEROFRACTION,                                                                          // 8    -0
                 typeAF[0,1] & sign1F & ~aZEROFRACTION,                                                                         // 4    -SUBNORMAL
                 ~|typeAF & sign1F,                                                                                             // 2    -NORMAL
                 typeAF[3,1] & sign1F                                                                                           // 1    -INF
    };
}

unit floateqltle(                                                                                                               // FLOATING POINT COMPARISONS ( uses base comparison less/equal generator )
    input   uint2   function3,                                                                                                  // COMPARISON TYPE SWITCH
    input   uint1   EQUAL,                                                                                                      // IS EQUAL FLAG A == B
    input   uint1   LESS,                                                                                                       // IS LESS FLAG A < B
    input   uint1   sNANa,                                                                                                      // A is sNAN?
    input   uint1   sNANb,                                                                                                      // B is sNAN?
    input   uint1   aObNAN,                                                                                                     // EITHER A OR B NAN?
    output  uint1   COMPARE,                                                                                                    // RESULT OF COMPARISON
    output  uint5   flags                                                                                                       // FLOATING POINT FLAGS FOR COMPARISON
) <reginputs> {
    uint3   LTEQ <: { EQUAL, LESS, LESS | EQUAL };                                                                              // BIT ARRAY FOR COMPARISON FLAGS

    COMPARE := ~aObNAN & LTEQ[ function3, 1 ];                                                                                  // 0 IF NAN ELSE COMPARISON FLAG
    flags := { function3[1,1] ? ( sNANa | sNANb ) : aObNAN, 4b0000 };                                                           // RETURN NV FLAG IF FLT OR FLE AND NAN IS AN INPUT
}

unit floatminmax(                                                                                                               // FLOATING POINT MIN / MAX
    input   uint2   dsh,                                                                                                        // DOUBLE/SINGLE/HALF FLAG
    input   uint1   function3,                                                                                                  // MIN == 0, MAX == 1
    input   uint64  sourceReg1F,                                                                                                // REGISTER INPUT A
    input   uint64  sourceReg2F,                                                                                                // REGISTER INPUT B
    input   uint1   aObNAN,                                                                                                     // EITHER A OR B NAN?
    input   uint1   LESS,                                                                                                       // IS LESS FLAG A < B
    output  uint64  MINMAX,                                                                                                     // RESULT OF MIN/MAX(a,b)
    output  uint5   flags                                                                                                       // FLOATING POINT FLAGS FOR MIN/MAX
) <reginputs> {
    actual_qNAN qNAN( dsh <: dsh );                                                                                             // GENERATE qNAN FOR USE IF ERROR

    MINMAX := aObNAN ? qNAN.value : ( function3[0,1] ^ LESS ) ? sourceReg1F : sourceReg2F;                                      // EITHER INPUT NAN RETURN qNAN ELSE DO MIN MAX AND SELECT REGISTER
    flags := { aObNAN, 4b0000 };                                                                                                // FLAGS SIGNALLING NAN INPUT
}

unit floatsign(                                                                                                                 // FLOATING POINT FSGNJ FSGNJN FSGNJX SIGN INJECTION
    input   uint2   dsh,                                                                                                        // DOUBLE/SINGLE/HALF FLAG
    input   uint2   function3,                                                                                                  // SWITCH FSGNJ == 00, FSGNJN == 01, FSGNJX == 10
    input   uint63  sourceReg1F,                                                                                                // REGISTER INPUT 1, EXCEPT 64 BIT SIGN, AS ALREADY PASSED
    input   uint1   sign1F,                                                                                                     // SIGN OF REGISTER INPUT 1
    input   uint1   sign2F,                                                                                                     // SIGN OF REGISTER INPUT 2
    output  uint64  SIGN                                                                                                        // RESULT OF SIGN INJECTION
) <reginputs> {
    uint1   SIGNBIT <: function3[1,1] ? sign1F ^ sign2F : function3[0,1] ^ sign2F;                                              // DETERMINE SIGN FOR INJECTION XOR FOR JX OPPOSITE FOR JN COPY FOR J

    SIGN := dsh[0,1] ? { SIGNBIT, sourceReg1F } :                                                                               // INJECT SIGN DOUBLE
            dsh[1,1] ? { 48hffffffffffff, SIGNBIT, sourceReg1F[0,15] } :                                                        //             HALF ( NAN boxed )
                       { 32hffffffff, SIGNBIT, sourceReg1F[0,31] };                                                             //             SINGLE ( NAN boxed )
}

unit fpuSINGLECYCLE(
    input   uint2   dsh,                                                                                                        // DOUBLE/SINGLE/HALF FLAG
    input   uint2   function3,                                                                                                  // SWITCH FOR COMPARE MINMAX AND SIGN OPERATIONS
    input   uint5   function7,                                                                                                  // SWITCH TO DETERMINE WHICH OPERATIONS
    input   uint64  sourceReg1,                                                                                                 // INTEGER REGISTER FOR FMV
    input   uint64  sourceReg1F,                                                                                                // INPUT FLOAT REGISTER 1
    input   uint1   sign1F,                                                                                                     // SIGN OF FLOAT REGISTYER 1
    input   uint64  sourceReg2F,                                                                                                // INPUT FLOAT REGISTER 2
    input   uint1   sign2F,                                                                                                     // SIGN OF FLOAT REGISTYER 2
    input   uint4   typeAF,                                                                                                     // { INF sNAN qNAN ZERO } OF INPUT FLOAT REGISTER 1
    input   uint4   typeBF,                                                                                                     // { INF sNAN qNAN ZERO } OF INPUT FLOAT REGISTER 2
    input   uint1   aObNAN,                                                                                                     // EITHER A OR B NAN?
    input   uint1   aZEROFRACTION,                                                                                              // A FRACTION PART 0
    input   uint1   FLT,                                                                                                        // sourceReg1F < sourceReg2F
    input   uint1   FEQ,                                                                                                        // sourceReg1F == sourceReg2F
    input   uint5   FPUflags,                                                                                                   // PRESENT FPU FLAGS
    output  uint5   FPUnewflags,                                                                                                // NEW FPU FLAGS
    output  uint64  result,                                                                                                     // RESULT ( NAN boxed if single/half, sign extended if int )
    output  uint1   frd                                                                                                         // IS RESULT FLOAT/DOUBLE OR INT/LONG
) <reginputs> {
    floatclass FPUclass(                                                                                                        // GENERATE FCLASS
        dsh <: dsh,                                                                                                             // DOUBLE/SINGLE/HALF FLAG
        sign1F <: sign1F, typeAF <: typeAF, aZEROFRACTION <: aZEROFRACTION                                                      // SIGN, { INF sNAN qNAN ZERO } FLAG TO CLASSIFY, IS FRACTION PART 0?
    );
    floateqltle FPUeqltle(                                                                                                      // GENERATE FEQ FLT FLE
        function3 <: function3,                                                                                                 // COMPARISON SWITCH
        EQUAL <: FEQ, LESS <: FLT,                                                                                              // COMPARISON FLAGS
        sNANa <: typeAF[2,1], sNANb <: typeBF[2,1],                                                                             // sNAN? A B
        aObNAN <: aObNAN                                                                                                        // A OR B NAN?
    );
    floatminmax FPUminmax(                                                                                                      // GENERATE FMIN FMAX
        dsh <: dsh,                                                                                                             // DOUBLE/SINGLE/HALF FLAG
        function3 <: function3[0,1],                                                                                            // MIN/MAX SWITCH
        LESS <: FLT,                                                                                                            // COMPARISON FLAGS
        sourceReg1F <: sourceReg1F,                                                                                             // INPUT FLOAT REGISTER 1
        sourceReg2F <: sourceReg2F,                                                                                             // INPUT FLOAT REGISTER 2
        aObNAN <: aObNAN                                                                                                        // A OR B NAN?
    );
    floatsign FPUsign(                                                                                                          // GENERATE FSGNJ FSGNJN FSGNJX
        dsh <: dsh,                                                                                                             // DOUBLE/SINGLE/HALF FLAG
        function3 <: function3,                                                                                                 // SIGN INJECTION TYPE SWITCH
        sourceReg1F <: sourceReg1F,                                                                                             // INPUT FLOAT REGISTER 1
        sign1F <: sign1F,                                                                                                       // SIGN OF FLOAT REGISTER 1
        sign2F <: sign2F                                                                                                        // SIGN OF FLOAT REGISTER 2
    );

    frd := function7[3,1] ? function7[1,1] : ~|function7[3,2];                                                                  // FRD for FMIN FMAX FSGNJ FSGNJN FSGNJX AND FMV.W.X

    algorithm <autorun> { while(1) {
        switch( function7[3,2] ) {                                                                                              // RESULT
            case 2b00: {
                result = function7[0,1] ? FPUminmax.MINMAX : FPUsign.SIGN;                                                      // FMIN FMAX FSGNJ FSGNJN FSGNJX
                FPUnewflags = FPUflags | ( function7[0,1] ? FPUminmax.flags : 0 );
            }
            case 2b10: {
                result = FPUeqltle.COMPARE;                                                                                     // FEQ FLT FLE
                FPUnewflags = FPUflags | FPUeqltle.flags;
            }
            default: {
                result = function7[1,1] ? dsh[0,1] ? sourceReg1 :                                                               // FMV.D.W
                                          dsh[1,1] ? { 48hffffffffffff, sourceReg1[0,16] } :                                    // FMV.H.W
                                                        { 32hffffffff, sourceReg1[0,32] } :                                     // FMV.S.W
                         function3[0,1] ? FPUclass.FCLASS :                                                                     // FCLASS
                                          dsh[0,1] ? sourceReg1F :                                                              // FMV.W.D
                                          dsh[1,1] ? { {48{sourceReg1F[15,1]}}, sourceReg1F[0,16] } :                           // FMV.W.H
                                                     { {32{sourceReg1F[31,1]}}, sourceReg1F[0,32] };                            // FMV.W.S
                FPUnewflags = FPUflags;
            }
        }
    } }
}

// FPU CALCULATION CONTROLLER FOR FUSED ADD SUB MUL DIV SQRT - ALL CALCULATION UNITS USE AS INPUTS SINGLES, HALVES AND DOUBLES PACKED INTO DOUBLE BITFIELDS
// ALL CALCULATION UNITS RETURN SINGLES, HALVES, DOUBLES PACKED INTO DOUBLE BITFIELDS. CONVERTED TO ACTUAL REGISTER FORMAT BY THE CPU FLOATING POINT CONTROLLER
unit do_float_multiply(
    input   uint10  BIAS,                                                                                                       // FLOATING POINT BIAS
    input   uint64  sourceReg1Fx,                                                                                               // sourceReg1F ( repacked in double bitfields )
    input   uint64  sourceReg2Fx,                                                                                               // sourceReg2F ( repacked in double bitfields )
    output  uint1   sign,                                                                                                       // SIGN sourceReg1F x sourceReg2F
    output  uint106 fraction,                                                                                                   // PRODUCT sourceReg1F x sourceReg2F
    output  int13   exp,                                                                                                        // EXPONENT sourceReg1F x sourceReg2F
    output  uint53  normal                                                                                                      // NORMALISED FRACTION OF sourceReg1F x sourceReg2F
) <reginputs> {
    fraction := { 1b1, fp64( sourceReg1Fx ).fraction } * { 1b1, fp64( sourceReg2Fx ).fraction };                                // CALCULATE THE PRODUCT BY MUTLIPLYING LEFT ALIGNED FRACTIONS
    normal := fraction[ { 3b110, fraction[105,1], {2{~fraction[105,1]}} }, 53 ];                                                // NORMALISED PRODUCT RESULT FOR 0 ADDITION
    exp := ( fp64( sourceReg1Fx ).exponent + fp64( sourceReg2Fx ).exponent ) -                                                  // ADD EXPONENTS FOR RESULT EXPONENT
            ( { BIAS, 1b0 } ) + fraction[105,1];                                                                                //  REMOVE BIAS(2*) AND ( +1 if overflow )
    sign := fp64( sourceReg1Fx ).sign ^ fp64( sourceReg2Fx ).sign;                                                              // SIGN FOR PRODUCT (USED FOR QUOTIENT TOO)
}
unit floatcalc(
    input   uint1   start,                                                                                                      // START FLAG
    output  uint1   busy,                                                                                                       // BUSY FLAG
    input   uint1   rm,                                                                                                         // ROUND UP ALLOWED
    input   uint2   dsh,                                                                                                        // DOUBLE/SINGLE/HALF FLAG ( to determine start bit for diviade and squareroot )
    input   uint10  BIAS,                                                                                                       // FLOATING POINT BIAS
    input   uint5   opCode,                                                                                                     // OPCODE, SINGLE OR FUSED OPERATIONS
    input   uint3   function3,                                                                                                  // ROUNDING MODE FLAG
    input   uint5   function7,                                                                                                  // DETERMINE SINGLE OPERATION
    input   uint64  sourceReg1Fx,                                                                                               // sourceReg1F ( repacked in double bitfields )
    input   uint4   typeAF,                                                                                                     // { INF sNAN qNAN ZERO } OF INPUT sourceReg1F
    input   uint64  sourceReg2Fx,                                                                                               // sourceReg2F ( repacked in double bitfields )
    input   uint4   typeBF,                                                                                                     // { INF sNAN qNAN ZERO } OF INPUT sourceReg2F
    input   uint64  sourceReg3Fx,                                                                                               // sourceReg3F ( repacked in double bitfields )
    input   uint4   typeCF,                                                                                                     // { INF sNAN qNAN ZERO } OF INPUT sourceReg3F
    input   uint1   aObINF,                                                                                                     // EITHER A OR B INF?
    input   uint1   aAbINF,                                                                                                     // BOTH A AND B INF?
    input   uint1   aObNAN,                                                                                                     // EITHER A OR B NAN?
    input   uint1   aObZERO,                                                                                                    // EITHER A OR B ZERO?
    input   uint1   aAbZERO,                                                                                                    // BOTH A AND B ZERO?
    input   uint1   aZEROFRACTION,                                                                                              // A FRACTION PART 0, POWER OF 2 DETECTION
    input   uint1   bZEROFRACTION,                                                                                              // B FRACTION PART 0, POWER OF 2 DETECTION
    input   uint8   FPUflags,                                                                                                   // PRESENT FPUFLAGS
    output  uint5   FPUnewflags,                                                                                                // NEW FPUFLAGS
    output  uint64  result                                                                                                      // CALCULATION RESULT
) <reginputs> {
    uint64 b <: { function7[0,1] ^ fp64( sourceReg2Fx ).sign, sourceReg2Fx[0,63] };                                             // SWITCH SIGN OF B INPUT IF SUBTRACTION
    floataddsub FPUaddsub(                                                                                                      // FLOAT ADDITION ( SUBTRACTION SIGN SWAPPED BY CONTROL UNIT )
        dsh <: dsh, BIAS <: BIAS, rm <: rm,                                                                                     // DOUBLE/SINGLE/HALF FLAG, BIAS, ROUNDING MODE FLAG
        a <: sourceReg1Fx, aINF <: typeAF[3,1],                                                                                 // A OPERAND FOR A+B, A IS INF?
        b <: b, bZERO <: typeBF[0,1],                                                                                           // B OPERAND FOR A+B ( sign switched if subtraction ), B IS ZERO?
        aObINF <: aObINF, aAbINF <: aAbINF, aObNAN <: aObNAN, aObZERO <: aObZERO, aAbZERO <: aAbZERO                            // A AND/OR B INF NAN ZERO
    );

    do_float_multiply MULT( BIAS <: BIAS, sourceReg1Fx <: sourceReg1Fx, sourceReg2Fx <: sourceReg2Fx );                         // GENERATE PRODUCT SIGN, FRACTION AND EXPONENT FOR MULTIPLY AND FUSED
    floatmultiply FPUmultiply(                                                                                                  // FLOAT MULTIPLICATION
        dsh <: dsh, BIAS <: BIAS, rm <: rm,                                                                                     // DOUBLE/SINGLE/HALF FLAG, BIAS, ROUNDING MODE FLAG
        aObINF <: aObINF, aObNAN <: aObNAN, aObZERO <: aObZERO,                                                                 // A AND/OR B INF NAN ZERO
        productsign <: MULT.sign, productexp <: MULT.exp, productnormal <: MULT.normal,                                         // MULTIPLICATION RESULTS
    );

    uint1   fusedsign <: opCode[1,1] ^ MULT.sign;                                                                               // SWITCH PRODUCT SIGN IF NEGATE FLAG
    uint64  c <: { opCode[0,1] ^ fp64( sourceReg3Fx ).sign, sourceReg3Fx[0,63] };                                               // SWITCH SIGN OF C INPUT IF SUBTRACTION REQUIRED, FUSED
    floatfused FPUfused(                                                                                                        // FLOAT FUSED-MULTIPLY-ADD
        dsh <: dsh, BIAS <: BIAS, rm <: rm,                                                                                     // DOUBLE/SINGLE/HALF FLAG, BIAS, ROUNDING MODE FLAG
        opCode <: opCode[0,2],                                                                                                  // SIGN SWITCHES
        c <: c, typeCF <: typeCF,                                                                                               // THIRD OPERAND FOR ADDITION/SIBTRATION, SIGN SWAPPED FOR SUBTRACTION
        aObINF <: aObINF, aAbINF <: aAbINF, aObNAN <: aObNAN, aObZERO <: aObZERO, aAbZERO <: aAbZERO,                           // A AND/OR B INF NAN ZERO
        productsign <: fusedsign, productfraction <: MULT.fraction, productexp <: MULT.exp, productnormal <: MULT.normal        // MULTIPLICATION RESULTS
    );

    uint7   startbit <: dsh[0,1] ? 107 : dsh[1,1] ? 23 : 49;                                                                    // DETERMINE STARTING BIT FOR THE LONG DIVISION ( HALVED FOR SQUAREROOT )
    floatdivide FPUdivide(                                                                                                      // FLOAT DIVISION
        dsh <: dsh, BIAS <: BIAS, rm <: rm,                                                                                     // DOUBLE/SINGLE/HALF FLAG, BIAS, ROUNDING MODE FLAG
        a <: sourceReg1Fx, aZERO <: typeAF[0,1],                                                                                // A OPERAND FOR A/B, ZERO FLAG
        b <: sourceReg2Fx, bINF <: typeBF[3,1], bZERO <: typeBF[0,1],                                                           // B OPERAND FOR A/B, INF AND ZERO FLAGS
        quotientsign <: MULT.sign,                                                                                              // QUOTIENT SIGN
        aObINF <: aObINF, aAbINF <: aAbINF, aObNAN <: aObNAN, aObZERO <: aObZERO, aAbZERO <: aAbZERO,                           // A AND/OR B INF NAN ZERO
        bZEROFRACTION <: bZEROFRACTION,                                                                                         // DIVISION BY POWER OF TWO, 0 FRACTION B
        startbit <: startbit                                                                                                    // PASS STARTING BIT
    );

    floatsqrt FPUsqrt(                                                                                                          // FLOAT SQUARE ROOT https://projectf.io/posts/square-root-in-verilog/
        dsh <: dsh, BIAS <: BIAS, rm <: rm,                                                                                     // DOUBLE/SINGLE/HALF FLAG, BIAS, ROUNDING MODE FLAG
        a <: sourceReg1Fx, typeAF <: typeAF,                                                                                    // A OPERAND FOR SQRT(A) AND { INF sNAN qNAN ZERO }
        aZEROFRACTION <: aZEROFRACTION,                                                                                         // SQUAREROOT OF A POWER OF TWO, 0 FRACTION A
        startbit <: startbit[1,6]                                                                                               // PASS STARTING BIT ( HALF OF DIVISION )
    );

    uint5   flags = uninitialised;                                                                                              // UNIT RESULT FLAGS, RETURN NEW FLAGS
    FPUaddsub.start := 0; FPUmultiply.start := 0; FPUdivide.start := 0; FPUsqrt.start := 0; FPUfused.start := 0;                // HOLD START FLAGS AT ZERO

    FPUnewflags := FPUflags[0,5] | flags;                                                                                       // RETURN FLAGS
    busy := start | FPUfused.busy | FPUsqrt.busy | FPUdivide.busy | FPUmultiply.busy | FPUaddsub.busy;                          // BUSY IF START OR A UNIT IS BUSY

    algorithm <autorun> { while(1) {
        if( opCode[2,1] ) {
            switch( function7[0,2] ) {                                                                                          // START UNIT, COLLECT RESULTS AND FLAGS
                default: {                                                                                                      //  FADD FSUB
                    FPUaddsub.start = start; result = FPUaddsub.result; flags = FPUaddsub.flags & 5b00110;
                }
                case 2b10: {                                                                                                    //  FMUL
                    FPUmultiply.start = start;result = FPUmultiply.result; flags = FPUmultiply.flags & 5b00110;
                }
                case 2b11: {
                    if( function7[3,1] ) {                                                                                      //  FSQRT
                        FPUsqrt.start = start; result = FPUsqrt.result; flags = FPUsqrt.flags & 5b01110;
                    } else {                                                                                                    // FDIV
                        FPUdivide.start = start; result = FPUdivide.result; flags = FPUdivide.flags & 5b00110;
                    }
                }
            }
        } else {                                                                                                                //  FUSED
            FPUfused.start = start; result = FPUfused.result; flags = FPUfused.flags & 5b10110;
        }
    } }
}

// IDENTIFY { infinity, signalling NAN, quiet NAN, ZERO } CHECKS FOR NAN-BOXING OF FLOAT
unit typeF(
    input   uint2   dsh,                                                                                                        // DOUBLE/SINGLE/HALF
    input   uint64  a,                                                                                                          // REGISTER VALUE TO CHECK
    output  uint1   zeroFRACTION,                                                                                               // FRACTION PART 0?
    output  uint4   type                                                                                                        // { INF sNAN qNAN ZERO } OF INPUT REGISTER
) <reginputs> {
    uint1   expFF <: ( dsh[0,1] ? &fp64(a).exponent : dsh[1,1] ? &fp16(a).exponent : &fp32(a).exponent );                       // CHECK FOR EXP == ALL 1s ( signals INF/NAN )
    uint1   exp00 <: ~|( dsh[0,1] ? fp64(a).exponent : dsh[1,1] ? fp16(a).exponent : fp32(a).exponent );                        // CHECK FOR EXP == ALL 0s ( signals ZERO/SUBNORMAL )
    uint1   NANboxed <: ~dsh[0,1] & ( dsh[1,1] ? &a[16,48] : &a[32,32] );                                                       // CHECK SINGLE/HALF IS NAN BOXED
    uint6   MSB <: dsh[0,1] ? 51 : dsh[1,1] ? 9 : 22;                                                                           // IDENTIFY MOST SIGNIFICANT BIT TO ALLOW CHECKING BETWEEN sNAN AND qNAN

    zeroFRACTION := ( dsh[0,1] ? ~|fp64(a).fraction : dsh[1,1] ? ~|fp16(a).fraction : ~|fp32(a).fraction );                     // FRACTION == 0

            type := dsh[0,1] | NANboxed ? {
                                        expFF & zeroFRACTION,                                                                   // INF
                                        expFF & ~fp64(a).fraction[MSB,1] & ~zeroFRACTION,                                       // sNAN
                                        expFF & fp64(a).fraction[MSB,1],                                                        // qNAN
                                        exp00                                                                                   // ZERO / SUBNORMAL
                                    } : 4b0010;                                                                                 // SINGLE/HALF NOT BOXED, ISSUE qNAN
}

// EXECPTION RETURN VALUES signed infinity, signalling NAN, quiet NAN, signed zero
// RETURN VALUES IN _wide repacked format
unit wide_special(
    input   uint1   sign,
    output  uint64  xINF,
    output  uint64  sNAN,
    output  uint64  qNAN,
    output  uint64  xZERO
) <reginputs> {
    xINF := { sign, 63h7FF0000000000000 };
    sNAN := 64h7FF4000000000000;
    qNAN := 64h7FF8000000000000;
    xZERO := { sign, 63h0 };
}
unit wide_xINF(
    input   uint1   sign,
    output  uint64  value
) <reginputs> {
    value := { sign, 63h7FF0000000000000 };
}
unit wide_xZERO(
    input   uint1   sign,
    output  uint64  value
) <reginputs> {
    value := { sign, 63h0 };
}

// EXECPTION RETURN VALUES signed infinity, signalling NAN, quiet NAN, signed zero
// RETURN VALUES IN _actual format
unit actual_special(
    input   uint2   dsh,
    input   uint1   sign,
    output  uint64  xINF,
    output  uint64  sNAN,
    output  uint64  qNAN,
    output  uint64  xZERO
) <reginputs> {
    xINF := dsh[0,1] ? { sign, 63h7FF0000000000000 } : dsh[1,1] ? { 48hffffffffffff, sign, 15h7C00 } : { 32hffffffff, sign, 31h7f800000 };
    sNAN := dsh[0,1] ? 64h7FF4000000000000 : dsh[1,1] ? 64hffffffffffff7d00 : 64hffffffff7fa00000;
    qNAN := dsh[0,1] ? 64h7FF8000000000000 : dsh[1,1] ? 64hffffffffffff7e00 : 64hffffffff7fc00000;
    xZERO := dsh[0,1] ? { sign, 63h0 } : dsh[1,1] ? { 48hffffffffffff, sign, 15b0 } : { 32hffffffff, sign, 31h0 };
}
unit actual_qNAN(
    input   uint2   dsh,
    output  uint64  value
) <reginputs> {
    value := dsh[0,1] ? 64h7FF8000000000000 : dsh[1,1] ? 64hffffffffffff7e00 : 64hffffffff7fc00000;
}
unit actual_xZERO(
    input   uint2   dsh,
    input   uint1   sign,
    output  uint64  value
) <reginputs> {
    value := dsh[0,1] ? { sign, 63h0 } : dsh[1,1] ? { 48hffffffffffff, sign, 15b0 } : { 32hffffffff, sign, 31h0 };
}


// REPACKERS, ALL FLOATING POINT NUMBERS ARE PASSED TO CALCULATIONS IN THE BITFIELD OF A DOUBLE TO ALLOW EASIER EXTRACTION OF THE SIGN, EXPONENT AND FRACTIONS
// _WIDE, copies double to double, single/half to the bitfields of a double
// _ACTUAL, copies double to double, a repacked wide single/half to the bitfields of a single/half
unit repackage_actual(                                                                                                          // REPACKAGE A DOUBLE/SINGLE/HALF FROM THE BITFIELDS OF A DOUBLE
    input   uint2   dsh,                                                                                                        // DOUBLE/SINGLE/HALF FLAG
    input   uint64  a,                                                                                                          // FLOATING POINT SOURCE REGISTER
    output  uint64  repack                                                                                                      // REPACKED FLOATING POINT REGISTER
) <reginputs> {
    repack := dsh[0,1] ? a :                                                                                                    // RETURN DOUBLE UNCHANGED
              dsh[1,1] ? { 48hffffffffffff, fp64( a ).sign, fp64( a ).exponent[0,5], fp64( a ).fraction[42,10] } :              // RETURN HALF REPACKED ( NANboxed )
                         { 32hffffffff, fp64( a ).sign, fp64( a ).exponent[0,8], fp64( a ).fraction[29,23] };                   // RETURN SINGLE REPACKED ( NANboxed )
}
unit repackage_wide(                                                                                                            // REPACKAGE A DOUBLE/SINGLE/HALF INTO THE BITFIELDS OF A DOUBLE
    input   uint2   dsh,                                                                                                        // DOUBLE/SINGLE/HALF FLAG
    input   uint64  a,                                                                                                          // FLOATING POINT SOURCE REGISTER
    output  uint64  repack                                                                                                      // REPACKED FLOATING POINT REGISTER
) <reginputs> {
    repack := dsh[0,1] ? a :                                                                                                    // RETURN DOUBLE UNCHANGED
              dsh[1,1] ? { fp16( a ).sign, 6b0, fp16( a ).exponent, fp16( a ).fraction, 42b0 } :                                // RETURN HALF REPACKED
                         { fp32( a ).sign, 3b0, fp32( a ).exponent, fp32( a ).fraction, 29b0 };                                 // RETURN SINGLE REPACKED
}

// MAKE A DOUBLE FLOATING-POINT NUMBER FROM SIGN, EXPONENT AND FRACTION
unit make_wide(
    input   uint1   sign,                                                                                                       // SIGN
    input   uint11  exp,                                                                                                        // EXPONENT
    input   uint52  fraction,                                                                                                   // FRACTION
    output  uint64  wide                                                                                                        // PACKED INTO DOUBLE BITFIELDS
) <reginputs> {
    wide := { sign, exp, fraction };                                                                                            // PACK SIGN, EXPONENT AND FRACTION INTO DOUBLE BITFIELDS
}

// MAKE ACTUAL DOUBLE/SINGLE/HALF FROM SIGN, EXPONENT AND FRACTION
unit make_actual(                                                                                                               // REPACKAGE A DOUBLE/SINGLE/HALF FROM THE BITFIELDS OF A DOUBLE
    input   uint2   dsh,                                                                                                        // DOUBLE/SINGLE/HALF FLAG
    input   uint1   sign,                                                                                                       // SIGN
    input   uint11  exp,                                                                                                        // EXPONENT
    input   uint52  fraction,                                                                                                   // FRACTION
    output  uint64  repack                                                                                                      // REPACKED FLOATING POINT REGISTER
) <reginputs> {
    repack := dsh[0,1] ? { sign, exp, fraction } :                                                                              // RETURN DOUBLE UNCHANGED
              dsh[1,1] ? { 48hffffffffffff, sign, exp[0,5], fraction[42,10] } :                                                 // RETURN HALF REPACKED ( NANboxed )
                         { 32hffffffff, sign, exp[0,8], fraction[29,23] };                                                      // RETURN SINGLE REPACKED ( NANboxed )
}

// NORMALISE A 106 BIT MANTISSA SO THAT THE MSB IS ONE, FOR ADDSUB ALSO DECREMENT THE EXPONENT FOR EACH SHIFT LEFT
// EXTRACT THE 53 BITS FOLLOWING THE MSB (1.xxxx) FOR ROUNDING
unit donormal(
    input   uint106 bitstream,                                                                                                  // RESULT FROM CALCULATION
    output  uint53  normalfraction                                                                                              // NORMALISED FRACTION 1.xxx
) <reginputs> {
    uint106 temporary <: ( bitstream << CLZ.count );                                                                            // SHIFT FRACTION LEFT SO 1.xxxx
    clz106 CLZ( bitstream <: bitstream );                                                                                       // COUNT LEADING ZEROS

    normalfraction := temporary[ 52, 53 ];                                                                                      // EXTRACT 53 BITS ( 1 extra for rounding )
}
unit donormalexp(
    input   int13   exp,                                                                                                        // EXPONENT FROM ADDITION / SUBTRACTION
    input   uint106 bitstream,                                                                                                  // RESULT FROM CALCULATION
    output  int13   newexponent,                                                                                                // ADJUSTED EXPONENT FOR ADDITION / SUBTRACTION
    output  uint53  normalfraction                                                                                              // NORMALISED FRACTION 1.xxx
) <reginputs> {
    uint106 temporary <: ( bitstream << CLZ.count );                                                                            // SHIFT FRACTION LEFT SO 1.xxxx
    clz106 CLZ( bitstream <: bitstream );                                                                                       // COUNT LEADING ZEROS

    normalfraction := temporary[ 52, 53 ];                                                                                      // EXTRACT 53 BITS ( 1 extra for rounding )
    newexponent := exp - CLZ.count;                                                                                             // ADDSUB EXPONENT ADJUSTMENT
}

// ROUND 52 ( double ) 23 ( single ) 11 ( galf ) BIT FRACTION FROM NORMALISED FRACTION USING NEXT TRAILING BIT
// ADD BIAS TO EXPONENT AND ADJUST EXPONENT IF ROUNDING FORCES
// COMBINE COMPONENTS TO FLOATING POINT NUMBER IN DOUBLE BITFIELDS  - USED BY CALCULATIONS
// UNDERFLOW return 0, OVERFLOW return infinity
unit make_roundmask(
    input   uint1   roundbit,
    input   uint2   dsh,
    output  uint43  mask
) <reginputs> {
    mask := ( dsh[0,1] ? roundbit : dsh[1,1] ? { roundbit, 42b0 } : { roundbit, 29b0 } );                                       // CORRECTLY ALIGN ROUNDING BIT
}

unit doroundcombine(
    input   uint1   rm,                                                                                                         // ROUNDING MODE ( RNE OR RTZ SUPPORTED )
    input   uint2   dsh,                                                                                                        // DOUBLE/SINGLE/HALF FLAG
    input   uint10  BIAS,                                                                                                       // FLOATING POINT BIAS FOR DESTINATION DOUBLE/SINGLE/HALF
    input   uint1   sign,                                                                                                       // RESULT SIGN
    input   uint53  bitstream,                                                                                                  // NORMALISED BITSTREAM 1.xxxx
    input   int13   exponent,                                                                                                   // EXPONENT ( no bias )
    output  uint1   OF,                                                                                                         // OVERFLOW FLAG
    output  uint1   UF,                                                                                                         // UNDERFLOW FLAG
    output  uint64  combined                                                                                                    // COMBIUNED DOUBLE/SINGLE/HALF ROUNDED AND COMBINED
) <reginputs> {
    make_roundmask MASK( dsh <: dsh );                                                                                          // MAKE ROUNDING MASK
    uint53  roundedfraction <: bitstream[1,52] + MASK.mask;                                                                     // EXTRACT 52 BITS AND ADD ON ROUNDING MASK ( 53 bits to detect overflow )
    int13   newexponent <: BIAS + exponent + roundedfraction[52,1];                                                             // CREATE EXPONENT BY ADDING BIAS AND OVERFLOW
    make_wide COMBINED( sign <: sign, exp <: newexponent[0,11], fraction <: roundedfraction );                                  // MAKE COMBINED RESULT IN DOUBLE BITFIELDS

    wide_xINF xINF( sign <: sign );                                                                                             // SIGNED INFINITY RETURN VALUE
    wide_xZERO xZERO( sign <: sign );                                                                                           // SIGNED ZERO RETURN VALUE

    MASK.roundbit := ( dsh[0,1] ? bitstream[0,1] : dsh[1,1] ? bitstream[42,1] : bitstream[29,1] ) & rm;                         // EXTRACT ROUNDING BIT AND SET IF ROUNDING MODE
    OF := __signed(newexponent) > __signed( { 1b0, BIAS, 1b0 } );                                                               // OVERFLOW IF EXPONENT IS GREATER THAN ( 2 * BIAS )
    UF := newexponent[12,1];                                                                                                    // UNDERFLOW IF EXPONENT IS STILL NEGATIVE AFTER BIAS ADDED
    combined := newexponent[12,1] ? xZERO.value : OF ? xINF.value : COMBINED.wide;                                              // UNDERFLOW RETURN SIGNED ZERO, OVERFLOW RETTURN SIGNED INFINITY, ELSE COMBINED
}

// CONVERSIONS TO HANDLE FCVT.dest.source
unit intlong2float(                                                                                                             // 32/64 BIT INTEGER TO 16/32/64 BIT FLOATING POINT
    input   uint1   rm,                                                                                                         // ROUDNING MODE
    input   uint1   dounsigned,                                                                                                 // UNSIGNED CONVERSION FLAG
    input   uint1   il,                                                                                                         // FROM INTEGER == 0 OR LONG == 1
    input   uint2   dsh,                                                                                                        // TO DOUBLE == 01 SINGLE == 00 HALF == 10
    input   uint10  BIAS,                                                                                                       // BIAS FOR DOUBLE/SINGLE/HALF
    input   uint64  sourceReg1,                                                                                                 // REGISTER VALUE TO CONVERT
    input   uint32  S1_abs32,                                                                                                   // 32 bit ABSOLUTE VALUE
    input   uint64  S1_abs64,                                                                                                   // 64 bit ABSOLUTE VALUE
    output  uint64  result,                                                                                                     // RESULTING DOUBLE/SINGLE/HALF
    output  uint1   FPUflags                                                                                                    // FPU FLAGS
) <reginputs> {
    uint1   sign <: ~dounsigned & sourceReg1[ { il, 5b11111 }, 1 ];                                                             // EXTRACT SIGN IF SIGNED CONVERSION
    uint64  number <: il ? sign ? S1_abs64 : sourceReg1 : sign ? S1_abs32 : sourceReg1[0,32];                                   // EXTRACT ABSOLUTE VALUE
    clz64 CLZ( number <: number );                                                                                              // COUNT LEADING ZEROS

    uint64  fraction <: number << CLZ.zeros;                                                                                    // GENERATE FRACTION BY SHIFTING TO THE LEFT
    make_roundmask MASK( dsh <: dsh );                                                                                          // MAKE ROUNDING MASK
    uint53  roundedfraction <: fraction[11,52] + MASK.mask;                                                                     // GENERATE ROUNDED FRACTION BY EXTRACTING 52 BITS AND ADD ON ROUNDING MASK
    uint11  exponent <: 63 + BIAS - CLZ.zeros + roundedfraction[52,1];                                                          // GENERATE EXPONENT AND ADD BIAS + 63 - CLZ + OVERFLOW
    make_actual TOFLOAT( dsh <: dsh, sign <: sign, exp <: exponent, fraction <: roundedfraction );                              // PACKAGE COMPONENTS INTO FLOATING-POINT BITFIELDS ( NANboxed for single/half )

    actual_xZERO ZERO ( dsh <: dsh );                                                                                           // ZERO RETURN VALUE FOR DOUBLE/SINGLE/HALF

    uint1   zlt <: ( __unsigned( CLZ.zeros )  < __unsigned( dsh[0,1] ? 11 : dsh[1,1] ? 53 : 40 ) );                             // CHECK IF INEXACT, TOO MANY BITS

    MASK.roundbit := ( dsh[0,1] ? fraction[10,1] : dsh[1,1] ? fraction[52,1] : fraction[39,1] ) & rm;                           // EXTRACT ROUNDING BIT AND SET IF ROUNDING MODE
    result :=  ~|( il ? sourceReg1 : sourceReg1[0,32] ) ? ZERO.value : TOFLOAT.repack;                                          // RETURN ZERO OR FLOATING-POINT CONVERSION
    FPUflags := dsh[0,1] ? ( il ? zlt : 0 ) : zlt;                                                                              // FLAGS NOT EXACT, TOO MANY BITS
}

unit float2intlong(                                                                                                             // 16/32/64 BIT FLOATING POINT TO 32/64 BIT INTEGER
    input   uint1   rm,                                                                                                         // ROUDNING MODE
    input   uint1   dounsigned,                                                                                                 // UNSIGNED CONVERSION FLAG
    input   uint1   il,                                                                                                         // TO INTEGER == 0 OR LONG == 1
    input   uint10  BIAS,                                                                                                       // BIAS FOR DOUBLE/SINGLE/HALF
    input   uint64  sourceReg1Fx,                                                                                               // REGISTER VALUE TO CONVERT ( repacke into double bitfields )
    input   uint4   typeAF,                                                                                                     // { INF sNAN qNAN ZERO } OF INPUT REGISTER
    output  uint64  result,                                                                                                     // RESULTING LONG OR INTEGER
    output  uint5   FPUflags                                                                                                    // FPU FLAGS
) <reginputs> {
    int13   exp <: fp64( sourceReg1Fx ).exponent - BIAS;                                                                        // EXTRACT EXPONENT AND REMOVE BIAS
    uint1   NV <: ( __signed(exp) > __signed( ( il ? 62 : 30 ) | dounsigned ) ) | ( dounsigned & fp64( sourceReg1Fx ).sign );   // INVALID IF TOO LARGE, UNSIGNED AND NEGATIVE
    uint65  fraction <: { 1b1, fp64( sourceReg1Fx ).fraction, 12b0 } >> ( 63 - exp );                                           // EXTRACT FRACTION AND EXTEND TO 65 BITS, SHIFT INTO POSITION

    FPUflags := { NV, 4b0000 };                                                                                                 // RETURN FLAGS

    algorithm <autorun> {
        uint64  unsignedfraction <: ( il ? fraction[1,64] : fraction[1,32] ) + ( fraction[0,1] & rm );                          // GENERATE ROUNDED 32/64 bit ABSOLUTE INTEGER
        uint64  min <: il ? dounsigned ? 0 : 64h8000000000000000 : 64hffffffff80000000;                                         // MINIMUM NEGATIVE INTEGER OR 0 FOR UNSIGNED
        uint64  max <: il ? dounsigned ? 64hffffffffffffffff : 64h7fffffffffffffff : 64h000000007fffffff;                       // MAXIMUM POSITIVE INTEGER

        while(1) {
            if( |typeAF ) {
                onehot( typeAF ) {
                    case 0: { result = 0; }
                    default: { result = max; }
                    case 3: { result = fp64( sourceReg1Fx ).sign ? min : max; }
                }
            } else {
                if( ~|( il ? unsignedfraction : unsignedfraction[0,32] ) ) {
                    result = 0;
                } else {
                    if( dounsigned ) {
                        result = NV ? { {64{~fp64( sourceReg1Fx ).sign}} } : unsignedfraction;                                  // 0 OR MAX IF NV ELSE RETURN UNSIGNED FRACTION
                    } else {
                        result = NV ? fp64( sourceReg1Fx ).sign ? min : max :                                                   // MIN/MAX FOR SIGNED OUT OF RANGE
                                 il ? fp64( sourceReg1Fx ).sign ? -unsignedfraction : unsignedfraction :                        // RETURN CORRECTLY SIGNED RESULT
                                      fp64( sourceReg1Fx ).sign ? { 32hffffffff, -unsignedfraction[0,32] } :                    // IF SIGN, SIGN EXTEND 32 BIT INTEGER
                                                                    { 32h00000000,  unsignedfraction[0,32] };
                    }
                }
            }
        }
    }
}

unit changeprecision(                                                                                                           // DOUBLE/SINGLE/HALF <-> DOUBLE/SINGLE/HALF ( EXTEND OR TRUNCATE )
    input   uint1   rm,                                                                                                         // ROUDNING MODE
    input   uint2   dest,                                                                                                       // TO DOUBLE(01)/SINGLE(00)/HALF(10)
    input   uint10  DBIAS,                                                                                                      // BIAS FOR DOUBLE/SINGLE/HALF DESTINATION
    input   uint2   source,                                                                                                     // FROM DOUBLE(01)/SINGLE(00)/HALF(10)
    input   uint10  SBIAS,                                                                                                      // BIAS FOR DOUBLE/SINGLE/HALF SOURCE
    input   uint64  sourceReg1Fx,                                                                                               // REGISTER VALUE TO EXTEND / TRUNCATE ( in double bitfields )
    input   uint4   typeAF,                                                                                                     // { INF sNAN qNAN ZERO }
    output  uint64  result,                                                                                                     // EXTENDED OR TRUNCATED RESULT
    output  uint3   FPUflags                                                                                                    // FPU FLAGS
) <reginputs> {
    make_roundmask MASK( dsh <: dest );                                                                                         // MAKE ROUNDING MASK
    uint53  roundedfraction <: fp64( sourceReg1Fx ).fraction + MASK.mask;                                                       // EXTRACT FRACTION AND ADD ON ROUNDING MASK, 53 BITS TO DETECT OVERFLOW
    int13   exp <: fp64( sourceReg1Fx ).exponent - SBIAS + DBIAS + roundedfraction[52,1];                                       // SELECT EXPONENT AND SUBTRACT SOURCE BIAS, ADD DESTINATION BIAS AND OVERFLOW

    make_actual REPACK( dsh <: dest, sign <:  fp64( sourceReg1Fx ).sign, exp <: exp[0,11], fraction <: roundedfraction );       // PACKAGE COMPONENTS INTO FLOATING-POINT BITFIELDS WITH NAN-BOXING

    actual_special SPECIAL( dsh <: dest[0,2], sign <: fp64( sourceReg1Fx ).sign );                                              // GENERATE xINF, sNAN, qNAN, xZERO FOR DESTINATION FORMAT

    uint1   truncateOF <: __signed(exp) > __signed( { 1b0, DBIAS, 1b0 });                                                       // CHECK IF NEW EXPONENT IS TOO LARGE ( > 2*BIAS for single/half)
    uint1   truncateUF <: exp[12,1];                                                                                            // CHECK IF NEW EXPONENT IS TOO SMALL ( negative for single/half )
    uint1   NX <:: source[0,1] | ( ~|source & dest[1,1] );                                                                      // NOT EXACT IF DOUBLE -> SINGLE/HALF OR SINGLE -> HALF (need to check dropped bits)

    MASK.roundbit := ( dest[0,1] ? 0 :                                                                                          // EXTRACT ROUNDING BIT AND SET IF ROUNDING MODE
                       dest[1,1] ? fp64( sourceReg1Fx ).fraction[41,1] :
                                   fp64( sourceReg1Fx ).fraction[28,1] ) & rm;

    FPUflags := |typeAF ? 0 : { truncateOF, truncateUF, NX };

    algorithm <autorun> { while(1) {
        if( |typeAF ) {                                                                                                         // INPUT IS INF, SNAN, QNAN, ZERO
            onehot( typeAF ) {
                case 3: { result = SPECIAL.xINF; }                                                                              // REPACKAGED INFINITY
                case 2: { result = SPECIAL.sNAN; }                                                                              // REPACKAGED sNAN
                case 1: { result = SPECIAL.qNAN; }                                                                              // REPACKAGED qNAN
                case 0: { result = SPECIAL.xZERO; }                                                                             // REPACKAGED ZERO
            }
        } else {
            result = truncateOF ? SPECIAL.xINF : truncateUF ? SPECIAL.xZERO : REPACK.repack;                                    // OVERFLOW -> INF, UNDERFLOW -> ZERO, REPACKAGED RESULT
        }
    } }
}

// ADDSUB ADD/SUBTRACT TWO FLOATING POINT NUMBERS ( SUBTRACT ACHIEVED BY ALTERING SIGN OF SECOND INPUT BY CALCULATION CONTROL UNIT ABOVE )
unit do_addsub_align(                                                                                                           // ALIGN FRACTIONS BASED UPON EXPONENTS
    input   uint10  BIAS,                                                                                                       // BIAS FOR DOUBLE/SINGLE/HALF
    input   uint11  expA,                                                                                                       // EXPONENT OF A INCLUDING BIAS
    input   uint52  fractionA,                                                                                                  // FRACTION OF A ( no leading 1 bit )
    input   uint11  expB,                                                                                                       // EXPONENT OF B INCLUDING BIAS
    input   uint52  fractionB,                                                                                                  // FRACTION OF B ( no leading 1 bit )
    output  uint106 sigA,                                                                                                       // ALIGNED FRACTION OF A ( including leading 1 bit )
    output  uint106 sigB,                                                                                                       // ALIGNED FRACTION OF B ( including leading 1 bit )
    output  int13   resultexp                                                                                                   // PROVISIONAL EXPONENT OF RESULT ( largest input exponent, bias removed )
) <reginputs> {
    uint1   expAvexpB <: ( expA < expB );                                                                                       // FIND SMALLEST EXPONENT
    uint11  shift <: ( expAvexpB ? expB : expA ) - ( expAvexpB ? expA :expB );                                                  // FIND THE AMOUNT SMALLER NUMBER NEEDS TO BE SHIFTED FOR ALIGNMENT

    sigA := { 2b01, fractionA, 52b0 } >> ( expAvexpB ? shift : 0 );                                                             // GENERATE A FROM FRACTION, ALIGN IF SMALLER
    sigB := { 2b01, fractionB, 52b0 } >> ( expAvexpB ? 0 : shift );                                                             // GENERATE B FROM FRACTION, ALIGN IF SMALLER
    resultexp := ( expAvexpB ? expB : expA ) - ( { BIAS[1,9], 1b0 } );                                                          // RESULT EXPONENT IS LARGEST EXPONENT, remove ( bias - 1 ) FOR OVERFLOW
}
unit do_float_addsub(
    input   uint1   signA,
    input   uint106 sigA,
    input   uint1   signB,
    input   uint106 sigB,
    output  uint1   resultsign,
    output  uint106 resultfraction
) <reginputs> {
    uint1   AvB <: ( __unsigned( sigA ) > __unsigned( sigB ) );                                                                 // FIND LARGEST FRACTION ( when exponents are equal )
    uint1   sign <: ( signA ^ signB ) ? ( signA ? AvB : ~AvB ) : signA;                                                         // DETERMINE RESULT SIGN

    resultsign := sign;                                                                                                         // RETURN RESULT SIGN
    resultfraction := ( signA ^ signB ) ? ( ( signA ^ sign ? sigB : sigA ) - ( signA ^ sign ? sigA : sigB ) ) :                 // DIFFERING SIGNS, SUBTRACTION
                                            ( sigA + sigB );                                                                    // SAME SIGNS ADDITION
}
unit floataddsub(
    input   uint1   start,
    output  uint1   busy,
    input   uint2   dsh,                                                                                                        // DOUBLE/SINGLE/HALF FLAG
    input   uint10  BIAS,                                                                                                       // BIAS FOR DOUBLE/SINGLE/HALF
    input   uint3   rm,                                                                                                         // ROUNDING MODE FLAG
    input   uint64  a,                                                                                                          // A INPUT FOR A+B OR A-B
    input   uint64  b,                                                                                                          // B INPUT FOR A+B OR A-B
    input   uint1   abSIGN,
    input   uint1   aINF,                                                                                                       // A is INF?
    input   uint1   bZERO,                                                                                                      // B is ZERO?
    input   uint1   aObINF,                                                                                                     // EITHER A OR B INF?
    input   uint1   aAbINF,                                                                                                     // BOTH A AND B INF?
    input   uint1   aObNAN,                                                                                                     // EITHER A OR B NAN?
    input   uint1   aObZERO,                                                                                                    // EITHER A OR B ZERO?
    input   uint1   aAbZERO,                                                                                                    // BOTH A AND B ZERO?
    output  uint5   flags,                                                                                                      // OPERATION FLAGS
    output  uint64  result                                                                                                      // RESULT OF CALCULATION
) <reginputs> {
    uint1   NV <: aAbINF & ( fp64( a ).sign ^ fp64( b ).sign );                                                                 // INVALID IF BOTH INFINITY WITH DIFFERING SIGNS
    uint2   ACTION <: { aObINF | aObNAN, aObZERO };                                                                             // DO ADDITION IF NOT INFINITY, NAN OR ZERO

    do_addsub_align ALIGN(                                                                                                      // ALIGN THE FRACTIONS
        BIAS <: BIAS,                                                                                                           // MOVE THE FRACTION WITH THE SMALLEST EXPONENT RIGHT
        expA <: fp64( a ).exponent, fractionA <: fp64( a ).fraction,
        expB <: fp64( b ).exponent, fractionB <: fp64( b ).fraction
    );
    do_float_addsub ADDSUB(                                                                                                     // PERFORM THE ADDITION/SUBTRACTION, ACCOUNTING FOR SIGNS
        signA <: fp64( a ).sign, sigA <: ALIGN.sigA,                                                                            // SPECIAL CASE FOR SUBTRACTION WHEN EQUAL EXPONENTS
        signB <: fp64( b ).sign, sigB <: ALIGN.sigB,                                                                            // AND SECOND FRACTION IS LARGER THAN THE FIRST
    );
    donormalexp NORMAL(                                                                                                         // NORMALISE THE RESULT
        exp <: ALIGN.resultexp,                                                                                                 // 1 IS ADDED TO THE EXPONENT IN CASE OF OVERFLOW,
        bitstream <: ADDSUB.resultfraction                                                                                      // NORMALISING WILL ADJUST
    );
    doroundcombine MAKERESULT(
        dsh <: dsh, BIAS <: BIAS, rm <: rm,                                                                                     // DO ROUNDING AND COMBINING ( leave in double bitfields )
        sign <: ADDSUB.resultsign, exponent <: NORMAL.newexponent, bitstream <: NORMAL.normalfraction
    );

    uint1   wait = uninitialised; busy:= start | wait; wait := start;                                                           // PROVIDE WAIT STATES

    flags := { NV, 1b0, ~|ACTION & MAKERESULT.OF, ~|ACTION & MAKERESULT.UF, 1b0 };                                              // RETURN FLAGS

    algorithm <autorun> { while(1) {
        switch( ACTION ) {
            case 2b00: { result = |ADDSUB.resultfraction ? MAKERESULT.combined : 0; }                                           // CALCULATION IS VALID, CHECK FOR ZERO RESULT
            case 2b01: { result = aAbZERO ? 0 : ( bZERO ? a : b ); }                                                            // BOTH ZERO, RETURN ZERO.  ONE ZERO, RETURN OTHER
            default: {
                switch( { aObINF, aObNAN } ) {
                    case 2b10: { result = NV ? 64h7FF8000000000000 : ( aINF ? a : b ); }                                        // INFINITY RETURN NAN IF OPPOSITE SIGNS ELSE RETURN INFINITY
                    default: { result = 64h7FF8000000000000; }                                                                  // NAN RETURN NAN
                }
            }
        }
    } }
}

// MULTIPLY TWO FLOATING POINT NUMBERS
unit floatmultiply(
    input   uint1   start,
    output  uint1   busy,
    input   uint2   dsh,                                                                                                        // DOUBLE/SINGLE/HALF FLAG
    input   uint10  BIAS,                                                                                                       // BIAS FOR DOUBLE/SINGLE/HALF
    input   uint3   rm,                                                                                                         // ROUNDING MODE FLAG
    input   uint1   productsign,                                                                                                // PRODUCT SIGN
    input   int13   productexp,                                                                                                 // PRODUCT EXPONENT
    input   uint53  productnormal,                                                                                              // PRODUCT FRACTION NORMALISED
    input   uint1   aObINF,                                                                                                     // EITHER A OR B INF?
    input   uint1   aObNAN,                                                                                                     // EITHER A OR B NAN?
    input   uint1   aObZERO,                                                                                                    // EITHER A OR B ZERO?
    output  uint5   flags,                                                                                                      // OPERATION FLAGS
    output  uint64  result                                                                                                      // RESULT OF CALCULATION
) <reginputs> {
    uint1   NV <: aObINF & aObZERO;                                                                                             // INVALID IF INFINITY x ZERO
    uint2   ACTION <: { aObINF | aObNAN, aObZERO };

    doroundcombine MAKERESULT(
        dsh <: dsh, BIAS <: BIAS, rm <: rm,                                                                                     // DO ROUNDING AND COMBINING ( leave in double bitfields )
        sign <: productsign, exponent <: productexp, bitstream <: productnormal
    );

    wide_xINF xINF( sign <: productsign );
    wide_xZERO xZERO( sign <: productsign );

    busy := start;                                                                                                              // PROVIDE BUSY FLAG

    flags := { NV, 1b0, ~|ACTION & MAKERESULT.OF, ~|ACTION & MAKERESULT.UF, 1b0 };                                              // RETURN FLAGS

    algorithm <autorun> { while(1) {
        switch( ACTION ) {
            case 2b00: { result = MAKERESULT.combined; }                                                                        // MULTIPLICATION IS VALID
            case 2b01: { result = xZERO.value; }                                                                                // ZERO INPUT RETURN ZERO
            default: {
                switch( { aObINF, aObZERO } ) {
                    case 2b11: { result = 64h7FF8000000000000; }                                                                // INFINITY x ZERO RETURN qNAN
                    case 2b10: { result = aObNAN ? 64h7FF8000000000000 : xINF.value; }                                          // NAN OR INFITITY RETURN qNAN OR INFINITY
                    default: { result = 64h7FF8000000000000; }                                                                  // NAN OR ZERO RETURN qNAN
                }
            }
        }
    } }
}

// FUSED MULTIPLY AND ADD ( A*B+C A*B-C -A*B+C -A*B-C )
unit do_addsub_align_fused(                                                                                                     // ALIGN FRACTIONS BASED UPON EXPONENTS ( exponents passed with no bias )
    input   int13   expA,                                                                                                       // EXPONENT OF MULTIPLICATION RESULT ( may be out of normal range )
    input   uint106 fractionA,                                                                                                  // RESULT OF MULTIPLICATION ( including leading 1 bit )
    input   int13   expB,                                                                                                       // EXPONENT OF INPUT C ( bias removed )
    input   uint52  fractionB,                                                                                                  // FRACTION OF INPUT C ( no leading 1 bit )
    output  uint106 sigA,                                                                                                       // ALIGNED FRACTION OF MULTIPLICATION ( including leading 1 bit )
    output  uint106 sigB,                                                                                                       // ALIGNED FRACTION OF INPUT C ( including leading 1 bit )
    output  int13   fusedexp                                                                                                    // LARGEST EXPONENT OF MULTIPLICATION RESULT AND INPUT C
) <reginputs> {
    uint1   expAvexpB <: ( __signed(expA) < __signed(expB) );                                                                   // FIND SMALLEST EXPONENT
    int13   shift <: ( expAvexpB ? expB : expA ) - ( expAvexpB ? expA :expB );                                                  // FIND THE AMOUNT SMALLER NUMBER NEEDS TO BE SHIFTED FOR ALIGNMENT

    sigA := ( fractionA[105,1] ? { 1b0, fractionA[1,105] } : fractionA ) >> ( expAvexpB ? shift : 0 );                          // ALIGN A IF SMALLER
    sigB := { 2b01, fractionB, 52b0 } >> ( expAvexpB ? 0 : shift );                                                             // GENERATE B FROM FRACTION, ALIGN IF SMALLER
    fusedexp := ( expAvexpB ? expB : expA ) + 1;                                                                                // RESULT EXPONENT IS LARGEST EXPONENT ( +1 FOR OVERFLOW ) ( remove bias )
}
unit floatfused(
    input   uint1   start,
    output  uint1   busy,
    input   uint2   opCode,
    input   uint2   dsh,                                                                                                        // DOUBLE/SINGLE/HALF FLAG
    input   uint10  BIAS,                                                                                                       // BIAS FOR DOUBLE/SINGLE/HALF
    input   uint3   rm,                                                                                                         // ROUNDING MODE FLAG
    input   uint64  c,                                                                                                          // B INPUT FOR A*B+C and - variations
    input   uint4   typeCF,                                                                                                     // { INF sNAN qNAN ZERO } FOR C
    input   uint1   aObINF,                                                                                                     // EITHER A OR B INF?
    input   uint1   aAbINF,                                                                                                     // BOTH A AND B INF?
    input   uint1   aObNAN,                                                                                                     // EITHER A OR B NAN?
    input   uint1   aObZERO,                                                                                                    // EITHER A OR B ZERO?
    input   uint1   aAbZERO,                                                                                                    // BOTH A AND B ZERO?
    input   uint1   productsign,                                                                                                // MULTIPLICATION SIGN IN FOR ADD/SUB
    input   uint106 productfraction,                                                                                            // MULTIPLICATION RESULT IN FOR ADD/SUB
    input   int13   productexp,                                                                                                 // MULTIPLICATION EXPONENT FOR ADD/SUB
    input   uint53  productnormal,                                                                                              // NORMALISED MULTIPLICATION RESULT IN CASE OF +/-0
    output  uint5   flags,                                                                                                      // OPERATION FLAGS
    output  uint64  result                                                                                                      // RESULT OF CALCULATION
) <reginputs> {
    int13   expC <: fp64( c ).exponent - BIAS;                                                                                  // REMOVE BIAS FROM C INPUT

    uint1   ZERO <: aObZERO | typeCF[0,1];                                                                                      // DETECT ZERO
    uint1   IF <: aObINF | typeCF[3,1];                                                                                         // DETECT INFINITY
    uint1   NN <: aObNAN | |typeCF[1,2];                                                                                        // DETECT NAN
    uint1   NV <: ( aObINF & aObZERO ) |                                                                                        // INF * 0 INVALID
                  ( aObINF & ( typeCF[3,1] & ( productsign ^ fp64( c ).sign ) ) );                                              // x == INF AND +/- INF WITH DIFFERING SIGNS INVALID
    uint2   ACTION <: { IF | NN, ZERO };                                                                                        // DO FUSED IF NOT INFINITY, NAN OR ZERO

    wide_xINF xINF( sign <: productsign ); wide_xINF pINF( sign <: fp64( c ).sign );

    do_addsub_align_fused ALIGN(                                                                                                // ALIGN THE FRACTIONS
        expA <: productexp, fractionA <: productfraction,                                                                       // MOVE THE FRACTION WITH THE SMALLEST EXPONENT RIGHT
        expB <: expC, fractionB <: fp64( c ).fraction
    );
    do_float_addsub ADDSUB(                                                                                                     // PERFORM THE ADDITION/SUBTRACTION, ACCOUNTING FOR SIGNS
        signA <: productsign, sigA <: ALIGN.sigA,                                                                               // SPECIAL CASE FOR SUBTRACTION WHEN EQUAL EXPONENTS
        signB <: fp64( c ).sign, sigB <: ALIGN.sigB,                                                                            // AND SECOND FRACTION IS LARGER THAN THE FIRST
    );
    donormalexp NORMAL(                                                                                                         // NORMALISE THE RESULT
        exp <: ALIGN.fusedexp,                                                                                                  // 1 IS ADDED TO THE EXPONENT IN CASE OF OVERFLOW
        bitstream <: ADDSUB.resultfraction                                                                                      // NORMALISING WILL ADJUST
    );
    doroundcombine MULTRESULT(                                                                                                  // DO ROUNDING AND COMBINING IN CASE OF 0 ADDITION / SUBTRACTION
        dsh <: dsh, BIAS <: BIAS,                                                                                               // REPLACES ARET IN SINGLE ADDITION OPERATION
        rm <: rm,                                                                                                               // TO RETURN MULTIPLCATION RESULT
        sign <: productsign, bitstream <: productnormal, exponent <: productexp
    );
    doroundcombine ADDRESULT(                                                                                                   // DO ROUNDING AND COMBINING ( leave in double bitfields ) FOR FULL FUSED OPERATION
        dsh <: dsh, BIAS <: BIAS, rm <: rm,
        sign <: ADDSUB.resultsign, exponent <: NORMAL.newexponent, bitstream <: NORMAL.normalfraction
    );

    make_wide CRET( sign <: fp64( c ).sign, exp <: fp64( c ).exponent, fraction <: fp64( c ).fraction );                        // REPACK C WITH ADJUSTED SIGN IN CASE OF 0 FROM MULTIPLICATION

    uint2   wait = uninitialised; busy := start | wait[0,1]; wait := { start, start | wait[1,1] };                              // PROVIDE WAIT STATES

    flags := { NV, 1b0,                                                                                                         // RETURN FLAGS
               ~|ACTION & ( ACTION == 2b01 ? MULTRESULT.OF : ADDRESULT.OF ),
               ~|ACTION & ( ACTION == 2b01 ? MULTRESULT.UF : ADDRESULT.UF ),
               1b0 };

    algorithm <autorun> { while(1) {
        switch( ACTION ) {
            case 2b00: { result = |ADDSUB.resultfraction ? ADDRESULT.combined : 0; }                                            // FUSED IS VALID, CHECK 0 FROM ADDSUB
            case 2b01: {                                                                                                        // ZERO INPUT
                result = ( aObZERO & typeCF[0,1] ) ? 0 :                                                                        // MULTIPLY RESULT 0 AND C == 0, RETURN 0
                            aObZERO ? CRET.wide :                                                                               // MULTIPLICATION INPUTS 0, RETURN C
                            MULTRESULT.combined;                                                                                // ADDITION/SUBTRACTION INPUT 0, RETURN MULTIPLICATION RESULT
            }
            default: {
                switch( { IF, ZERO } ) {
                    default: { result = 64h7FF8000000000000; }                                                                  // NAN INPUT
                    case 2b10: {                                                                                                // NAN OR INFITITY RETURN qNAN OR INFINITY
                        switch( { aObINF, typeCF[3,1] } ) {
                            case 2b01: { result = pINF.value; }                                                                 // C INPUT IS INFINITY
                            default: { result = NV ? 64h7FF8000000000000 : xINF.value; }                                        // INVALID MIXED SIGN INFINITY, OR MULTIPLICATION IS INFINITY
                        }
                    }
                    case 2b11: {                                                                                                // INFINITY AND ZERO INPUTS
                        switch( { aObINF, typeCF[3,1] } ) {
                            case 2b01: { result = pINF.value; }                                                                 // MULTIPLICATION IS 0 AND C INPUT IS INFINITY
                            case 2b10: { result = xINF.value; }                                                                 // MULTIPLICATION IS INFINITY, C INPUT IS 0
                            default: { result = 64h7FF8000000000000; }                                                          // INFINITY x ZERO, INVALID qNAN
                        }

                    }
                }
            }
        }
    } }
}

// DIVIDE TWO FLOATING POINT NUMBERS
unit prep_float_divide(
    input   uint2   dsh,                                                                                                        // DOUBLE/SINGLE/HALF FLAG
    input   uint64  a,                                                                                                          // A INPUT FOR A/B
    input   uint64  b,                                                                                                          // B INPUT FOR A/B
    output  int13   quotientexp,                                                                                                // RESULT EXPONENT
    output  uint108 sigA,                                                                                                       // DIVIDEND LEFT ALIGNED
    output  uint106 sigB                                                                                                        // DIVISOR RIGHT ALIGNED
) <reginputs> {
    quotientexp := ( fp64( a ).exponent - fp64( b ).exponent ) - ( fp64(b).fraction > fp64(a).fraction );                       // SUBTRACT EXPONENTS FOR RESULT ( -1 if b fraction > a fraction )
    sigA := dsh[0,1] ? { 1b1, fp64(a).fraction, 55b0 } :                                                                        // DIVIDEND LEFT ALIGNED
            dsh[1,1] ? { 1b1, fp64(a).fraction[42,10], 13b0 } :
                       { 1b1, fp64(a).fraction[29,23], 26b0 };
    sigB := dsh[0,1] ? { 1b1, fp64(b).fraction } :                                                                              // DIVISOR RIGHT ALIGNED
            dsh[1,1] ? { 1b1, fp64(b).fraction[42,10] } :
                       { 1b1, fp64(b).fraction[29,23] };
}
unit do_float_divide(
    input   uint1   start,
    output  uint1   busy,
    input   uint7   startbit,
    input   uint108 sigA,
    input   uint108 sigB,
    input   uint1   powTWO,
    output  uint108 quotient(0)
) <reginputs> {
    algorithm <autorun> {
        uint7   bit = uninitialised;
        uint7   bitNEXT <:: bit - 1;
        uint108 remainder = uninitialised;
        uint108 temporary <:: { remainder[0,107], sigA[bit,1] };
        uint1   bitresult <:: __unsigned(temporary) >= __unsigned(sigB);
        uint108 remainderNEXT <:: __unsigned(temporary) - ( bitresult ? __unsigned(sigB) : 0 );

        busy = 0; while(1) {
            if( start ) {
                busy = 1;
                if( powTWO ) {                                                                                                  // DETECT DIVISION BY POWER OF 2
                    quotient = sigA;                                                                                            //      RETURN DIVIDEND
                } else {
                    bit = startbit; quotient = 0; remainder = 0;                                                                // ZERO quotient and remainder SELECT STARTING BIT
                    while( ~&bit ) {
                        remainder = remainderNEXT;                                                                              // PERFORM BIT BY BIT LONG DIVISION
                        quotient[ bit, 1 ] = bitresult;                                                                         // UPDATE THE QUOTIENT
                        bit = bitNEXT;                                                                                          // MOVE TO THE NEXT BIT
                    }
                }
                busy = 0;
            }
        }
    }
}
unit floatdivide(
    input   uint1   start,
    output  uint1   busy,
    input   uint2   dsh,                                                                                                        // DOUBLE/SINGLE/HALF FLAG
    input   uint10  BIAS,                                                                                                       // BIAS FOR DOUBLE/SINGLE/HALF
    input   uint3   rm,                                                                                                         // ROUNDING MODE FLAG
    input   uint64  a,                                                                                                          // A INPUT FOR A/B
    input   uint64  b,                                                                                                          // B INPUT FOR A/B
    input   uint1   quotientsign,                                                                                               // SIGN FOR QUOTIENT
    input   uint1   aZERO,                                                                                                      // A IS ZERO?
    input   uint1   bINF,                                                                                                       // B IS INF?
    input   uint1   bZERO,                                                                                                      // { INF sNAN qNAN ZERO } FOR B
    input   uint1   aObINF,                                                                                                     // EITHER A OR B INF?
    input   uint1   aAbINF,                                                                                                     // BOTH A AND B INF?
    input   uint1   aObNAN,                                                                                                     // EITHER A OR B NAN?
    input   uint1   aObZERO,                                                                                                    // EITHER A OR B ZERO?
    input   uint1   aAbZERO,                                                                                                    // BOTH A AND B ZERO?
    input   uint1   bZEROFRACTION,                                                                                              // B FRACTION PART B, DIVIDE BY POWER OF 2
    input   uint7   startbit,                                                                                                   // POINT TO START DIVISION AT 107/49/23 FOR DOUBLE/SINGLE?HALF
    output  uint4   flags,                                                                                                      // OPERATION FLAGS
    output  uint64  result                                                                                                      // RESULT OF CALCULATION
) <reginputs> {
    uint1   NV <: aAbINF | aObNAN | bZERO;                                                                                      // NOT VALID IF INF, NAN OR B == 0
    uint2   ACTION <: { aObINF | aObNAN, aObZERO };                                                                             // DO DIVISION IF NOT INFINITY, NAN OR ZERO

    wide_xINF xINF( sign <: quotientsign );
    wide_xZERO xZERO(  sign <: quotientsign );

    prep_float_divide PREP(                                                                                                     // PREPARE THE DIVISION INPUTS
        dsh <: dsh,
        a <: a,
        b <: b,
    );
    do_float_divide DODIVIDE(                                                                                                   // DO THE DIVISION PASS QUOTIENT FOR NORMALISATION
        startbit <: startbit,
        sigA <: PREP.sigA,
        sigB <: PREP.sigB,
        powTWO <: bZEROFRACTION,
    );
    donormal NORMAL(                                                                                                            // NORMALISE THE RESULT
        bitstream <: DODIVIDE.quotient
    );
    doroundcombine MAKERESULT(
        dsh <: dsh, BIAS <: BIAS, rm <: rm,                                                                                     // DO ROUNDING AND COMBINING ( leave in double bitfields )
        sign <: quotientsign, exponent <: PREP.quotientexp, bitstream <: NORMAL.normalfraction
    );

    DODIVIDE.start := start & ~|ACTION; busy := start | DODIVIDE.busy;                                                          // START AND BUSY FLAGS

    flags := { bZERO, ~|ACTION & MAKERESULT.OF, ~|ACTION & MAKERESULT.UF, 1b0};                                                 // RETURN FLAGS

    algorithm <autorun> { while(1) {
        switch( ACTION ) {
            case 2b00: { result = MAKERESULT.combined; }                                                                        // DIVISION IS VALID
            case 2b01: { result = aAbZERO ? 64h7FF8000000000000 : bZERO ? xINF.value : xZERO.value; }                           // ZERO INPUT, NAN IF BOTH ZERO, INF IF B ZERO, ZERO IF A ZERO
            default: { result = NV ? 64h7FF8000000000000 :                                                                      // qNAN IF INVALID,
                                        ( aZERO | bINF ) ? xZERO.value : xINF.value; }                                         // ZERO IF A IS ZERO OR B IS INF, INF IF INF / OTHER
        }
    } }
}

// ADAPTED FROM https://projectf.io/posts/square-root-in-verilog/
//
// MIT License
//
// Copyright (c) 2021 Will Green, Project F
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
unit prep_float_sqrt(
    input   uint10  BIAS,                                                                                                       // BIAS FOR DOUBLE/SINGLE/HALF
    input   uint64  a,                                                                                                          // A INPUT FOR SQRT(A)
    output  uint1   expODD,
    output  int13   squarerootexp,
    output  uint108 start_ac,
    output  uint106 start_x
) <reginputs> {
    int13   expA <: fp64( a ).exponent - BIAS;                                                                                  // EXTRACT EXPONENT AND REMOVE BIAS

    squarerootexp := expA >>> 1;                                                                                                // RESULT EXPONENT IS HALF OF INPUT EXPONENT
    start_ac := expA[0,1] ? { 106b0, 1b1, a[ 51, 1 ] } : 1;                                                                     // STARTING ACCUMULATOR ( depends if exp is odd / even )
    start_x := expA[0,1] ? { a[0,51], 55b0 } : { fp64( a ).fraction, 54b0 };                                                    // STARTING FRACTION ( depends if exp is odd / even )
    expODD := expA[0,1];                                                                                                        // IS EXP ODD, RETURN SQRT(2) OR 1 FOR POWER OF 2 SQUAREROOTS
}
unit do_float_sqrt(
    input   uint1   start,
    output  uint1   busy,
    input   uint6   startbit,
    input   uint1   powTWO,
    input   uint1   expODD,
    input   uint108 start_ac,
    input   uint106 start_x,
    output  uint54  squareroot
) <reginputs> {
    algorithm <autorun> {
        uint108 ac = uninitialised;
        uint106 x = uninitialised;
        uint108 test_res <:: ac - { squareroot, 2b01 };
        uint6   i = uninitialised;
        uint6   iNEXT <:: i - 1;

        busy = 0; while(1) {
            if( start ) {
                busy = 1;
                if( powTWO ) {
                    squareroot = expODD ? 54h2D413CCCFE7799 : 1;                                                                // DETECT POWER OF 2 SQUARE ROOT, RETURN ROOT 2 / 1 IF EXP ODD / EVEN
                } else {
                    i = startbit; squareroot = 0; ac = start_ac; x = start_x;                                                   // SELECT STARTING BIT ( counter for number of bits to process )
                    while( ~&i ) {                                                                                              // GO THROUGH ALL BITS FOR PRECISION SELECTED
                        ac = { test_res[107,1] ? ac[0,105] : test_res[0,105], x[104,2] };                                       // FIND NEW ACCUMULATOR
                        squareroot = { squareroot[0,53], ~test_res[107,1] };                                                    // ADD NEXT BIT TO SQUAREROOT ( shift in from right )
                        x = { x[0,104], 2b00 };                                                                                 // MOVE 2 PLACES ALONG REMAINING FRACTION
                        i = iNEXT;                                                                                              // MOVE TO NEXT BIT
                    }
                }
                busy = 0;
            }
    }
    }
}
unit floatsqrt(
    input   uint1   start,
    output  uint1   busy,
    input   uint2   dsh,                                                                                                        // DOUBLE/SINGLE/HALF FLAG
    input   uint10  BIAS,                                                                                                       // BIAS FOR DOUBLE/SINGLE/HALF
    input   uint3   rm,                                                                                                         // ROUNDING MODE FLAG
    input   uint64  a,                                                                                                          // A INPUT FOR SQRT(A)
    input   uint4   typeAF,                                                                                                     // { INF sNAN qNAN ZERO } FOR A
    input   uint1   aZEROFRACTION,                                                                                              // 0 FRACTION PART A, A IS POWER OF TWO?
    input   uint6   startbit,                                                                                                   // POINT TO START SQUAREROOT AT 53/24/11 FOR DOUBLE/SINGLE/HALF
    output  uint5   flags,                                                                                                      // OPERATION FLAGS
    output  uint64  result                                                                                                      // RESULT OF CALCULATION
) <reginputs> {
    uint1   NV <: |typeAF[1,3] | fp64( a ).sign;                                                                                // INVALID IF INFINITY, NAN OR NEGATIVE
    uint1   ACTION <: ~( |typeAF | fp64( a ).sign );                                                                            // CALCULATION VALID IF NORMAL POSITIVE NUMBER ( ZERO IS SPECIAL )

    prep_float_sqrt PREP( BIAS <: BIAS, a <: a );                                                                               // PREPARE THE SQUAREROOT INPUTS
    do_float_sqrt DOSQRT(                                                                                                       // CALCULATE SQUARE ROOT
        startbit <: startbit,
        powTWO <: aZEROFRACTION,
        expODD <: PREP.expODD,
        start_ac <: PREP.start_ac,
        start_x <: PREP.start_x
    );
    donormal NORMAL( bitstream <: DOSQRT.squareroot );                                                                          // NORMALISE THE RESULT
    doroundcombine MAKERESULT(
        dsh <: dsh, BIAS <: BIAS, rm <: rm,                                                                                     // DO ROUNDING AND COMBINING ( leave in double bitfields )
        exponent <: PREP.squarerootexp, bitstream <: NORMAL.normalfraction
    );

    DOSQRT.start := start & ACTION; busy := start | DOSQRT.busy;                                                                // START AND BUSY FLAGS
    result := ACTION ? MAKERESULT.combined : fp64( a ).sign ? 64h7FF8000000000000 : a;                                          // VALID = RESULT, INVALID = qNAN IF NEGATIVE ELSE INPUT ( INF OR ZERO )
    flags := { NV, 1b0, ACTION & MAKERESULT.OF, ACTION & MAKERESULT.UF, 1b0 };                                                  // RETURN FLAGS
}

// FLOATING POINT COMPARISONS - ADAPTED FROM SOFT-FLOAT

/*============================================================================

License for Berkeley SoftFloat Release 3e

John R. Hauser
2018 January 20

The following applies to the whole of SoftFloat Release 3e as well as to
each source file individually.

Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018 The Regents of the
University of California.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions, and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors
    may be used to endorse or promote products derived from this software
    without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS resultERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

unit floatcompare(
    input   uint64  a,                                                                                                          // A INPUT FOR A<B OR A==B ( repacked into double bitfields )
    input   uint64  b,                                                                                                          // B INPUT FOR A<B OR A==B ( repacked into double bitfields )
    input   uint1   aObNAN,                                                                                                     // { INF sNAN qNAN ZERO } FOR A
    input   uint1   aAbZERO,                                                                                                    // A == 0 AND B == 0?
    input   uint1   aZEROFRACTION,                                                                                              // A FRACTION == 0?
    input   uint1   bZEROFRACTION,                                                                                              // B FRACTION == 0?
    output  uint1   less,                                                                                                       // A < B FLAG
    output  uint1   equal                                                                                                       // A == B FLAG
) <reginputs> {
    uint1   aequalb <: ( a == b );                                                                                              // A==B
    uint1   abTRUEZERO <: aAbZERO & aZEROFRACTION & bZEROFRACTION;                                                              // A == 0 & B == 0 ( NOT SUBNORMAL )

    less := ~aObNAN & ( ( fp64( a ).sign ^ fp64( b ).sign ) ? fp64( a ).sign & ~abTRUEZERO : ~aequalb & ( fp64( a ).sign ^ ( __unsigned( a ) < __unsigned( b ) ) ) );
    equal := ~aObNAN & ( aequalb | abTRUEZERO );
}
