unit background_display(
    input   uint10  pix_x,
    input   uint9   pix_y,
    input   uint1   pix_end,
    output! uint8   pixel,

    input   uint2  staticGenerator,

    input   uint8   b_colour,
    input   uint8   b_alt,
    input   uint4   b_mode,
    input   uint1   colourmode
) <reginputs> {
    brom uint8 rainbow[8] = { 8h80, 8hc1, 8he1, 8hf9, 8h38, 8h0f, 8h45, 8ha7 };                                                 // 8 COLOUR RAINBOW DKRED RED ORANGE YELLOW GREEN BLUE DKPURPLE VIOLET
    uint2   condition = uninitialised;                                                                                          // CONDITION FLAG, == 0 alt, == 1 colour, == 2 rainbow, == 3 static
    uint1   tophalf <:: ( pix_y < 240 );                                                                                        // TOP HALF OF SCREEN
    uint1   lefthalf <:: ( pix_x < 320 );                                                                                       // LEFT HALF OF THE SCREEN
    uint2   checkmode <:: b_mode - 7;                                                                                           // SIZE OF CHECKERBOARD

    starfield STARS( pix_x <: pix_x, pix_y <: pix_y, pix_end <: pix_end );                                                      // STARFIELD GENERATOR

    rainbow.addr := pix_y[6,3];
    always_after {
        switch( b_mode ) {                                                                                                      // DETERMINE BACKGROUND PATTERN
            case 0: { condition = 1; }                                                                                          //  SOLID
            case 1: { condition = tophalf; }                                                                                    //  50:50 HORIZONTAL SPLIT
            case 2: { condition = ( lefthalf ); }                                                                               //  50:50 VERTICAL SPLIT
            case 3: { condition = ( lefthalf ^ tophalf ); }                                                                     //  QUARTERS
            case 5: { condition  = STARS.star; }                                                                                //  SNOW (from @sylefeb)
            case 11: { condition = ( pix_x[0,1] | pix_y[0,1] ); }                                                               //  CROSSHATCH
            case 12: { condition = ( pix_x[0,2] == pix_y[0,2] ); }                                                              //  LSLOPE
            case 13: { condition = ( pix_x[0,2] == ~pix_y[0,2] ); }                                                             //  RSLOPE
            case 14: { condition = pix_x[0,1]; }                                                                                //  VSTRIPES
            case 15: { condition = pix_y[0,1]; }                                                                                //  HSTRIPES
            case 4: { condition = 2; } case 6: { condition = 3; }                                                               //  STATIC AND RAINBOW
            default: { condition = ( pix_x[checkmode,1] ^ pix_y[checkmode,1] ); }                                               //  CHECKERBOARDS (7,8,9,10)
        }


        switch( condition ) {                                                                                                   // SWITCH TO THE APPROPRIATE COLOUR
            case 0: { pixel = b_alt; }                                                                                          //  ALT
            case 1: { pixel = b_colour; }                                                                                       //  COLOUR
            case 2: { pixel = rainbow.rdata; }                                                                                  //  RAINBOW
            case 3: { pixel = {4{staticGenerator}}; }                                                                           //  STATIC
        }
    }
}
unit background_writer(
    input   uint8   backgroundcolour,
    input   uint8   backgroundcolour_alt,
    input   uint4   backgroundcolour_mode,
    input   uint2   background_update,

    input   uint1   copper_program,
    input   uint$NUCUaddr$   copper_address,
    input   uint4   copper_op,
    input   uint3   copper_opd,
    input   uint1   copper_opf,
    input   uint10  copper_opl,

    output  uint8   BACKGROUNDcolour,
    output  uint8   BACKGROUNDalt,
    output  uint4   BACKGROUNDmode,

    simple_dualport_bram_port1  OP,                                                                                             // OPCODE
    simple_dualport_bram_port1  OPD,                                                                                            // DEST REG NUMBER
    simple_dualport_bram_port1  OPF,                                                                                            // LITERAL/REGISTER FLAG
    simple_dualport_bram_port1  OPL,                                                                                            // 2ND REG NUMBER OR LITERAL
) <reginputs> {
    OP.wenable1 := 1;                  OPD.wenable1 := 1;                    OPF.wenable1 := 1;
    OPL.wenable1 := 1;

    always_after {
        switch( background_update ) {
            case 2b00: {                                                                                                        // CHANGE A PROGRAM LINE IN THE COPPER MEMORY
                if( copper_program ) {
                    OP.addr1 = copper_address; OP.wdata1 = copper_op;
                    OPD.addr1 = copper_address; OPD.wdata1 = copper_opd;
                    OPF.addr1 = copper_address; OPF.wdata1 = copper_opf;
                    OPL.addr1 = copper_address; OPL.wdata1 = copper_opl;
                }
            }
            case 2b01: { BACKGROUNDcolour = backgroundcolour; }                                                                 // UPDATE THE BACKGROUND FROM RISC-V
            case 2b10: { BACKGROUNDalt = backgroundcolour_alt; }
            case 2b11: { BACKGROUNDmode = backgroundcolour_mode; }
        }
    }
}
unit nucu(
    input   uint10  pix_x,
    input   uint9   pix_y,
    input   uint1   pix_vblank,

    input   uint4   backgroundcolour_mode,                                                                                      // FROM CPU BACKGROUND MODE
    input   uint8   backgroundcolour,                                                                                           // FROM CPU BACKGROUND COLOUR
    input   uint8   backgroundcolour_alt,                                                                                       // FROM CPU BACKGROUND COLOUR ALT

    input   uint1   copper_status,                                                                                              // START COPPER EXECUTING
    input   uint10  copper_cpu_input,                                                                                           // FROM CPU VALUE
    output  uint10  copper_cpu_output,                                                                                          // TO CPU VALUE
    input   uint10  staticGenerator,                                                                                            // RANDOM NUMBER GENERATOR

    output! uint4   BACKGROUNDmode,                                                                                             // COPPER/CPU BACKGROUND MODE TO GENERATOR
    output! uint8   BACKGROUNDcolour,                                                                                           // COPPER/CPU BACKGROUND COLOUR TO GENERATOR
    output! uint8   BACKGROUNDalt,                                                                                              // COPPER/CPU BACKGROUND COLOUR ALT TO GENERATOR

    simple_dualport_bram_port0  OP,                                                                                             // OPCODE
    simple_dualport_bram_port0  OPD,                                                                                            // DEST REG NUMBER
    simple_dualport_bram_port0  OPF,                                                                                            // LITERAL/REGISTER FLAG
    simple_dualport_bram_port0  OPL,                                                                                            // 2ND REG NUMBER OR LITERAL
    input   uint80  memoryinit                                                                                                  // INITIAL SETTINGS OF THE MEMORY
) <reginputs> {
    uint$NUCUaddr$   PC = 0;                                                                                                    // PROGRAM COUNTER
    uint2   PCinc = uninitialised;                                                                                              // PC ACTION FLAG == 0 PCnext, == 1 PCskip, == 2 RL value
    uint$NUCUaddr$   PCnext <:: PC + 1;                                                                                         // NEXT INSTRUCTION
    uint$NUCUaddr$   PCskip <:: PC + 2;                                                                                         // NEXT INSTRUCTION IF SKIP
    uint1   WR = uninitialised;                                                                                                 // WRITE TO REGISTERS FLAG
    uint1   WM = uninitialised;                                                                                                 // WRITE TO MEMORY FLAG

    bram uint10 dstack[$NUCUstack$] = uninitialised;                                                                            // DATA STACK
    bram uint$NUCUaddr$ rstack[$NUCUstack$] = uninitialised;                                                                    // RETURN STACK
    uint$NUCUstackaddr$ rstack_p1 <:: rstack.addr + 1;
    uint$NUCUstackaddr$ rstack_n1 <:: rstack.addr - 1;
    uint$NUCUstackaddr$ dstack_p1 <:: dstack.addr + 1;
    uint$NUCUstackaddr$ dstack_n1 <:: dstack.addr - 1;

    PCinc := 0; WR := 1; WM := 0; dstack.wenable := 0; rstack.wenable := 0;

    always_after {
        uint10  MEM[$NUCUmem$] = uninitialised;                                                                                 // STORAGE FOR 8 MEMORY LOCATIONS
        uint10  reg1 = uninitialised;                                                                                           // CONTENTS OF REG 1
        uint10  reg2 = uninitialised;                                                                                           // CONTENTS OF REG 2 OR LITERAL VALUE
        uint10  result = uninitialised;                                                                                         // RESULT OF OP
        uint10  REGS[4] = uninitialised;                                                                                        // STORAGE FOR 4 REGISTERS

        switch( OPD.rdata0 ) {                                                                                                  // EXTRACT REG1
            case 0: { reg1 = pix_vblank; }                                                                                      // VBLANK
            case 1: { reg1 = pix_x; }                                                                                           // X COORD
            case 2: { reg1 = pix_y; }                                                                                           // Y COORD
            case 3: { reg1 = copper_cpu_input; }                                                                                // CPU TO COPPER
            default: { reg1 = REGS[ OPD.rdata0[0,2] ]; }                                                                        // COPPER REGISTER
        }

        if( OPF.rdata0 ) {                                                                                                      // EXTRACT REG2
            reg2 = OPL.rdata0;                                                                                                  // LITERAL VALUE
        } else {
            switch( OPL.rdata0[0,3] ) {
                case 0: { reg2 = pix_vblank; }                                                                                  // VBLANK
                case 1: { reg2 = pix_x; }                                                                                       // X COORD
                case 2: { reg2 = pix_y; }                                                                                       // Y COORD
                case 3: { reg2 = copper_cpu_input; }                                                                            // CPU TO COPPER
                default: { reg2 = REGS[ OPL.rdata0[0,2] ]; }                                                                    // COPPER REGISTER
            }
        }

        if( copper_status ) {
            switch( OP.rdata0 ) {
                case 4h0: {                                                                                                     // JMP JSR RET SLI SRx LRx
                    WR = OPD.rdata0[2,1]; result = dstack.rdata;                                                                // WRITE TO REGISTER IF LRx, RESULT IS TOP OF DSTACK
                    switch( OPD.rdata0 ) {                                                                                      // reg1 acts as switch
                        case 0: { PCinc = 2; }                                                                                  // Jump to: JPL literal, JPR register value
                        case 1: { rstack.addr = rstack_p1; rstack.wdata = PCnext; rstack.wenable = 1; PCinc = 2; }              // Jump to subroutine SAVE NEXT ADDRESS TO RSTACK: JSL to literal, JSR to register value
                        case 2: { rstack.addr = rstack_n1 ; reg2 = rstack.rdata; PCinc = 2; }                                   // RET ( pop address from rstack )
                        case 3: { dstack.addr = dstack_p1; dstack.wdata = reg2; dstack.wenable = 1; }                           // SLI and SRx ( push literal or register value on dstack )
                        default: { dstack.addr = dstack_n1; }                                                                   // LRx ( pop value from dstack, write to reg1 )
                    }
                }
                case 4h1: { result = reg2; }                                                                                    // SET
                case 4h2: { result = reg1 + reg2; }                                                                             // ADD
                case 4h3: { result = reg1 - reg2; }                                                                             // SUB
                case 4h4: { result = reg1 & reg2; }                                                                             // AND
                case 4h5: { result = reg1 | reg2; }                                                                             // OR
                case 4h6: { result = reg1 ^ reg2; }                                                                             // XOR
                case 4h7: { result = reg1 << reg2; }                                                                            // SHL
                case 4h8: { result = reg1 >> reg2; }                                                                            // SHR
                case 4h9: { WR = 0; PCinc = ( reg1 == reg2 ); }                                                                 // SKIP =
                case 4ha: { WR = 0; PCinc = ( reg1 != reg2 ); }                                                                 // SKIP !=
                case 4hb: { WR = 0; PCinc = ( reg1 < reg2 ); }                                                                  // SKIP <
                case 4hc: { WR = 0; PCinc = ( reg1 <= reg2 ); }                                                                 // SKIP <=
                case 4hd: { result = staticGenerator & reg2; }                                                                  // RANDOM
                case 4he: { result = MEM[ reg2[0,$NUCUmemaddr$] ]; }                                                            // LOAD FROM MEMORY
                case 4hf: { WR = 0; WM = 1; }                                                                                   // STORE TO MEMORY
            }

            if( WR ) {                                                                                                          // WRITE TO REGISTERS?
                switch( OPD.rdata0 ) {
                    case 0: { BACKGROUNDmode = result; }                                                                        // BACKGROUND MODE
                    case 1: { BACKGROUNDcolour = result; }                                                                      // BACKGROUND COLOUR
                    case 2: { BACKGROUNDalt = result; }                                                                         // BACKGROUND COLOUR ALT
                    case 3: { copper_cpu_output = result; }                                                                     // COPPER TO CPU
                    default: { REGS[ OPD.rdata0[0,2] ] = result; }                                                              // COPPER REGISTER
                }
            }

            if( WM ) { MEM[ reg2[0,$NUCUmemaddr$] ] = reg1; }                                                                   // WRITE TO MEMORY

            PC = PCinc[1,1] ? reg2 : PCinc[0,1] ? PCskip : PCnext;                                                              // UPDATE PC, PCinc == 2 JUMP,  ==1 SKIP, == 0 NEXT
        } else {
            PC = 0;                                                                                                             // set PC to 0
            $$for i=0,7 do
                MEM[$i$] = memoryinit[ $i*10$, 10 ];                                                                            // COPY CPU MEMORY INITIALISATION VALUES
            $$end
            BACKGROUNDmode = backgroundcolour_mode;                                                                             // UPDATE THE BACKGROUND GENERATOR FROM THE CPU
            BACKGROUNDcolour = backgroundcolour;
            BACKGROUNDalt = backgroundcolour_alt;

            dstack.addr = -1; rstack.addr = -1;
        }

        OP.addr0 = PC; OPD.addr0 = PC; OPF.addr0 = PC; OPL.addr0 = PC;                                                          // MOVE TO THE NEXT INSTRUCTION
    }
}

// By @sylefeb
unit starfield(
    input   uint10  pix_x,
    input   uint9   pix_y,
    input   uint1   pix_end,
    output! uint1   star
) <reginputs> {
    uint32  frame = 0;                                                                                                          // FRAME COUNTER
    uint12  rand_x = 0;                                                                                                         // PSEUDO RANDOM NUMBER GENERATOR
    uint10  dotpos <:: ( frame >> rand_x[10,2] ) + rand_x;

    always_after {
        frame = frame + pix_end;                                                                                                // INCREMENT AT END OF FRAME
        rand_x = |pix_x ? rand_x * 31421 + 6927 : 1;
        star = ( pix_y == dotpos );
    }
}

