unit background_display(
    input   uint10  pix_x,
    input   uint9   pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint8   pixel,

    input   uint2  staticGenerator,

    input   uint8   b_colour,
    input   uint8   b_alt,
    input   uint4   b_mode,
    input   uint1   colourmode
) <reginputs> {
    uint2   condition = uninitialised;

    uint1   tophalf <:: ( pix_y < 240 );            uint1   lefthalf <:: ( pix_x < 320 );               uint2   checkmode <:: b_mode - 7;

    starfield STARS( pix_x <: pix_x, pix_y <: pix_y );

    always_after {
        {
            // DETERMINE BACKGROUND PATTERN
            switch( b_mode ) {
                case 0: { condition = 1; }                                              // SOLID
                case 1: { condition = tophalf; }                                        // 50:50 HORIZONTAL SPLIT
                case 2: { condition = ( lefthalf ); }                                   // 50:50 VERTICAL SPLIT
                case 3: { condition = ( lefthalf ^ tophalf ); }                         // QUARTERS
                case 5: { condition  = STARS.star; }                                    // SNOW (from @sylefeb)
                case 11: { condition = ( pix_x[0,1] | pix_y[0,1] ); }                   // CROSSHATCH
                case 12: { condition = ( pix_x[0,2] == pix_y[0,2] ); }                  // LSLOPE
                case 13: { condition = ( pix_x[0,2] == ~pix_y[0,2] ); }                 // RSLOPE
                case 14: { condition = pix_x[0,1]; }                                    // VSTRIPES
                case 15: { condition = pix_y[0,1]; }                                    // HSTRIPES
                case 4: { condition = 2; } case 6: { condition = 3; }                   // STATIC AND RAINBOW (placeholder, done in main)
                default: { condition = ( pix_x[checkmode,1] ^ pix_y[checkmode,1] ); }   // CHECKERBOARDS (7,8,9,10)
            }
        }
        {
            // 8 COLOUR RAINDOW IN DIFFERENT SCREEN COLOUR MODES
            // DKRED RED ORANGE YELLOW GREEN BLUE DKPURPLE VIOLET
            uint8   rainbow[] = { 8h80, 8hc1, 8he1, 8hf9, 8h38, 8h0f, 8h45, 8ha7 };

            // SWITCH TO THE APPROPRIATE COLOUR
            switch( condition ) {
                case 0: { pixel = b_alt; }                                                                  // EVERYTHING ELSE
                case 1: { pixel = b_colour; }
                case 2: { pixel = colourmode ? { pix_y[7,2], {2{pix_y[6,3]}} } : rainbow[ pix_y[6,3] ]; }   // RAINBOW
                case 3: { pixel = {4{staticGenerator}}; }                                                   // STATIC
            }
        }
    }
}

unit starfield(
    input   uint10  pix_x,
    input   uint9   pix_y,
    output! uint1   star
) <reginputs> {
    // Variables for SNOW (from @sylefeb)
    int32   frame = 0;
    int12   rand_x = 0;
    uint10 dotpos <:: ( frame >> rand_x[10,2] ) + rand_x;

    always_after {
        // Increment frame number for the snow/star field
        { frame = frame + ( ( pix_x == 639 ) & ( pix_y == 479 ) ); }
        { rand_x = |pix_x ?  rand_x * 31421 + 6927 : 1; }
        { star = ( pix_y == dotpos ); }
    }
}

unit new_background_writer(
    input   uint10  pix_x,
    input   uint9   pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,

    input   uint8   backgroundcolour,
    input   uint8   backgroundcolour_alt,
    input   uint4   backgroundcolour_mode,
    input   uint2   background_update,

    input   uint1   copper_program,
    input   uint7   copper_address,
    input   uint4   copper_op,
    input   uint3   copper_opd,
    input   uint1   copper_opf,
    input   uint10  copper_opl,

    output  uint8   BACKGROUNDcolour,
    output  uint8   BACKGROUNDalt,
    output  uint4   BACKGROUNDmode,

    simple_dualport_bram_port1  OP,                                                                                             // OPCODE
    simple_dualport_bram_port1  OPD,                                                                                            // DEST REG NUMBER
    simple_dualport_bram_port1  OPF,                                                                                            // LITERAL/REGISTER FLAG
    simple_dualport_bram_port1  OPL,                                                                                            // 2ND REG NUMBER OR LITERAL
) <reginputs> {
    OP.wenable1 := 1;                  OPD.wenable1 := 1;                    OPF.wenable1 := 1;
    OPL.wenable1 := 1;

    always_after {
        switch( background_update ) {
            case 2b00: {                                                                                            // CHANGE A PROGRAM LINE IN THE COPPER MEMORY
                if( copper_program ) {
                    OP.addr1 = copper_address; OP.wdata1 = copper_op;
                    OPD.addr1 = copper_address; OPD.wdata1 = copper_opd;
                    OPF.addr1 = copper_address; OPF.wdata1 = copper_opf;
                    OPL.addr1 = copper_address; OPL.wdata1 = copper_opl;
                }
            }
            case 2b01: { BACKGROUNDcolour = backgroundcolour; }                                                     // UPDATE THE BACKGROUND FROM RISC-V
            case 2b10: { BACKGROUNDalt = backgroundcolour_alt; }
            case 2b11: { BACKGROUNDmode = backgroundcolour_mode; }
        }
    }
}
unit new_copper(
    input   uint10  pix_x,
    input   uint9   pix_y,
    input   uint1   pix_vblank,

    input   uint4   backgroundcolour_mode,                                                                                      // FROM CPU BACKGROUND MODE
    input   uint8   backgroundcolour,                                                                                           // FROM CPU BACKGROUND COLOUR
    input   uint8   backgroundcolour_alt,                                                                                       // FROM CPU BACKGROUND COLOUR ALT

    input   uint1   copper_status,                                                                                              // START COPPER EXECUTING
    input   uint10  copper_cpu_input,                                                                                           // FROM CPU VALUE
    output  uint10  copper_cpu_output,                                                                                          // TO CPU VALUE
    input   uint10  staticGenerator,                                                                                            // RANDOM NUMBER GENERATOR

    output! uint4   BACKGROUNDmode,                                                                                             // COPPER/CPU BACKGROUND MODE TO GENERATOR
    output! uint8   BACKGROUNDcolour,                                                                                           // COPPER/CPU BACKGROUND COLOUR TO GENERATOR
    output! uint8   BACKGROUNDalt,                                                                                              // COPPER/CPU BACKGROUND COLOUR ALT TO GENERATOR

    simple_dualport_bram_port0  OP,                                                                                             // OPCODE
    simple_dualport_bram_port0  OPD,                                                                                            // DEST REG NUMBER
    simple_dualport_bram_port0  OPF,                                                                                            // LITERAL/REGISTER FLAG
    simple_dualport_bram_port0  OPL,                                                                                            // 2ND REG NUMBER OR LITERAL
    input   uint80  memoryinit                                                                                                  // INITIAL SETTINGS OF THE MEMORY
) <reginputs> {
    uint7   PC = 0;                                                                                                             // PROGRAM COUNTER
    uint7   PCnext <:: PC + 1;                                                                                                  // NEXT INSTRUCTION
    uint7   PCskip <:: PC + 2;                                                                                                  // NEXT INSTRUCTION IF SKIP

    uint2   PCinc = uninitialised;                                                                                              // PC ACTION FLAG == 0 PCnext, == 1 PCskip, == 2 RL value
    uint1   WR = uninitialised;                                                                                                 // WRITE TO REGISTERS FLAG
    uint1   WM = uninitialised;                                                                                                 // WRITE TO MEMORY FLAG

    uint10  MEM[8] = uninitialised;                                                                                             // STORAGE FOR 8 MEMORY LOCATIONS
    uint10  REGS[4] = uninitialised;                                                                                            // STORAGE FOR 4 REGISTERS
    uint10  reg1 = uninitialised;                                                                                               // CONTENTS OF REG 1
    uint10  reg2 = uninitialised;                                                                                               // CONTENTS OF REG 2 OR LITERAL VALUE
    uint10  result = uninitialised;                                                                                             // RESULT OF OP

    PCinc := 0; WR := 1; WM := 0;

    always_after {
        switch( OPD.rdata0 ) {                                                                                                  // EXTRACT REG1
            case 0: { reg1 = pix_vblank; }                                                                                      // VBLANK
            case 1: { reg1 = pix_x; }                                                                                           // X COORD
            case 2: { reg1 = pix_y; }                                                                                           // Y COORD
            case 3: { reg1 = copper_cpu_input; }                                                                                // CPU TO COPPER
            default: { reg1 = REGS[ OPD.rdata0[0,2] ]; }                                                                        // COPPER REGISTER
        }

        if( OPF.rdata0 ) {                                                                                                      // EXTRACT REG2
            reg2 = OPL.rdata0;                                                                                                  // LITERAL VALUE
        } else {
            switch( OPL.rdata0[0,3] ) {
                case 0: { reg2 = pix_vblank; }                                                                                  // VBLANK
                case 1: { reg2 = pix_x; }                                                                                       // X COORD
                case 2: { reg2 = pix_y; }                                                                                       // Y COORD
                case 3: { reg2 = copper_cpu_input; }                                                                            // CPU TO COPPER
                default: { reg2 = REGS[ OPL.rdata0[0,2] ]; }                                                                    // COPPER REGISTER
            }
        }

        if( copper_status ) {
            switch( OP.rdata0 ) {
                case 4h0: { WR = 0; PCinc = 2; }                                                                                // JUMP
                case 4h1: { result = reg2; }                                                                                    // SET
                case 4h2: { result = reg1 + reg2; }                                                                             // ADD
                case 4h3: { result = reg1 - reg2; }                                                                             // SUB
                case 4h4: { result = reg1 & reg2; }                                                                             // AND
                case 4h5: { result = reg1 | reg2; }                                                                             // OR
                case 4h6: { result = reg1 ^ reg2; }                                                                             // XOR
                case 4h7: { result = reg1 << reg2; }                                                                            // SHL
                case 4h8: { result = reg1 >> reg2; }                                                                            // SHR
                case 4h9: { WR = 0; PCinc = ( reg1 == reg2 ); }                                                                 // SKIP =
                case 4ha: { WR = 0; PCinc = ( reg1 != reg2 ); }                                                                 // SKIP !=
                case 4hb: { WR = 0; PCinc = ( reg1 < reg2 ); }                                                                  // SKIP <
                case 4hc: { WR = 0; PCinc = ( reg1 <= reg2 ); }                                                                 // SKIP <=
                case 4hd: { result = staticGenerator & reg2; }                                                                  // RANDOM
                case 4he: { result = MEM[ reg2[0,3] ]; }                                                                        // LOAD FROM MEMORY
                case 4hf: { WR = 0; WM = 1; result = reg2; }                                                                    // STORE TO MEMORY
            }

            if( WR ) {                                                                                                          // WRITE TO REGISTERS?
                switch( OPD.rdata0 ) {
                    case 0: { BACKGROUNDmode = result; }                                                                        // BACKGROUND MODE
                    case 1: { BACKGROUNDcolour = result; }                                                                      // BACKGROUND COLOUR
                    case 2: { BACKGROUNDalt = result; }                                                                         // BACKGROUND COLOUR ALT
                    case 3: { copper_cpu_output = result; }                                                                     // COPPER TO CPU
                    default: { REGS[ OPD.rdata0[0,2] ] = result; }                                                              // COPPER REGISTER
                }
            }

            if( WM ) {                                                                                                          // WRITE TO MEMORY
                MEM[ reg1[0,3] ] = result;
            }

            switch( PCinc ) {                                                                                                   // UPDATE PC
                default: { PC = PCnext; }                                                                                       // NEXT INSTRUCTION
                case 1: { PC = PCskip; }                                                                                        // SKIP TRUE
                case 2: { PC = reg2; }                                                                                          // JUMP
            }
        } else {
            PC = 0;                                                                                                             // set PC to 0
            $$for i=0,7 do
                MEM[$i$] = memoryinit[ $i*10$, 10 ];                                                                            // COPY CPU MEMORY INITIALISATION VALUES
            $$end
            BACKGROUNDmode = backgroundcolour_mode;                                                                             // UPDATE THE BACKGROUND GENERATOR FROM THE CPU
            BACKGROUNDcolour = backgroundcolour;
            BACKGROUNDalt = backgroundcolour_alt;
        }

        OP.addr0 = PC; OPD.addr0 = PC; OPF.addr0 = PC; OPL.addr0 = PC;                                                          // MOVE TO THE NEXT INSTRUCTION
    }
}
