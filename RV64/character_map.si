bitfield  cmentry{
    uint8   background,
    uint8   foreground,
    uint9   character
}

unit character_map(
    input   uint1   clockCG,
    dualport_bram_port0 charactermap,

    input   uint10  pix_x,
    input   uint10  pix_x1,
    input   uint9   pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint8   pixel,
    output! uint1   character_map_display,

    input   uint1   blink,
    input   uint7   cursor_x,
    input   uint6   cursor_y,
    input   uint8   tpu_foreground,
    input   uint8   tpu_background,
    input   uint1   tpu_showcursor
) <reginputs> {
    characterrom512 CGROM <@clockCG> ( tile <: cmentry(charactermap.rdata0).character, y <: pix_y[0,3] );                       // Character ROM 8x8 512 characters, 256 normal, 256 bold

    uint1   characterpixel <:: CGROM.line[ ~pix_x[0,3], 1 ];                                                                    // Present pixel
    uint1   is_cursor <:: tpu_showcursor & blink & ( cursor_x == ( pix_x[3,7] ) ) & ( cursor_y == pix_y[3,6] );                 // Is current coordinate the cursor coordinate, cursor visible?

    charactermap.addr0 := pix_x1[3,7] + 80 * pix_y[3,6];
    character_map_display := pix_active & ( characterpixel | ( cmentry(charactermap.rdata0).background != 64 ) | is_cursor );
    pixel := is_cursor ? characterpixel ? tpu_background : tpu_foreground :                                                     // IF CURSOR, INVERT PIXEL
                         characterpixel ? cmentry(charactermap.rdata0).foreground :                                             // IF PIXEL, FOREGROUND
                                          cmentry(charactermap.rdata0).background;                                              // ELSE BACKGROUND
}

unit cmcursorx(
    input   uint7   tpu_active_x,
    output  uint7   NEXT,
    output  uint1   ATLAST
) <reginputs> {
    ATLAST := ( tpu_active_x == 79 );
    NEXT := tpu_active_x + 1;
}
unit cmcursory(
    input   uint6   tpu_active_y,
    output  uint6   NEXT,
) <reginputs> {
        NEXT := ( tpu_active_y == 59 ) ? 0 : tpu_active_y + 1;
}
unit cmaddresses(
    input   uint7   tpu_active_x,
    input   uint6   tpu_active_y,
    input   uint6   tpu_y,
    output  uint13  WRITEADDR,
    output  uint13  YSTARTADDR,
    output  uint13  YENDADDR
) <reginputs> {
    WRITEADDR := tpu_active_x + tpu_active_y * 80;
    YSTARTADDR := tpu_y * 80;
    YENDADDR := YSTARTADDR + 80;
}

unit character_map_writer(
    dualport_bram_port1 charactermap,

    input   uint13  memoryAddressDirect,                                                                                        // CPU MEMORY ADDRESS
    input   uint1   memoryWriteDirect,                                                                                          // CPU WRITE FLAG
    input   uint25  writeDataDirect,                                                                                            // CPU WRITE DATA
    output! uint25  readDataDirect,                                                                                             // CPU READ DATA

    // TPU to SET characters, background, foreground
    input   uint7   tpu_x,
    input   uint6   tpu_y,
    input   uint9   tpu_character,
    input   uint8   tpu_foreground,
    input   uint8   tpu_background,
    input   uint2   tpu_write,

    output  uint7   cursor_x,
    output  uint6   cursor_y
) <reginputs> {
    cmcursorx TPUX( tpu_active_x <: cursor_x );     cmcursory TPUY( tpu_active_y <: cursor_y );                                 // TPU character position
    cmaddresses TPUA( tpu_active_x <: cursor_x, tpu_active_y <: cursor_y, tpu_y <: tpu_y );                                     // ADDRESS CALCULATIONS AND BRAM write access for the TPU

    charactermap.addr1 := memoryWriteDirect ? memoryAddressDirect : TPUA.WRITEADDR;                                             // SET ADDRESS AS TPU ADDRESS FOR WRITE OR CPU ADDRESS
    charactermap.wdata1 := memoryWriteDirect ? writeDataDirect :                                                                // WRITE CPU INPUT DIRECT
                            { tpu_background, tpu_foreground, tpu_character };                                                  // VIA TPU OUTPUT
    charactermap.wenable1 := memoryWriteDirect | tpu_write[1,1];

    algorithm <autorun> { while(1) {
        switch( tpu_write ) {
            default: {}
            case 1: { ( cursor_x, cursor_y ) = copycoordinates( tpu_x, tpu_y ); }                                               // Set cursor position
            case 2: {                                                                                                           // Write character,foreground, background and move
                if( TPUX.ATLAST ) {
                    cursor_x = 0; cursor_y = TPUY.NEXT;
                } else {
                    cursor_x = TPUX.NEXT;
                }
            }
        }
    } }
}
