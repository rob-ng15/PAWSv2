bitfield  cmentry{
    uint5   attributes,
    uint8   background,
    uint8   foreground,
    uint8   character
}

unit characterrom512(
    input   uint1   cursor_blink,
    input   uint8   character,
    input   uint3   x,
    input   uint3   y,
    input   uint5   attribute,
    input   uint1   double_right,
    input   uint1   double_bottom,
    output! uint1   pixel
) <reginputs> {
    brom uint8 characterGenerator8x8[4096] =  {
        $include('ROM/FONTS/CODE437-THINBOLD.inc')
        ,pad(uninitialized)
    };

    // Setup the reading of the characterGenerator8x8 ROM
    characterGenerator8x8.addr := { attribute[0,1], character, attribute[2,1] ? { double_bottom, y[1,2] } : y };
    pixel := attribute[3,1] & ~cursor_blink ? 0 :
             attribute[4,1] & |character & ( ( attribute[2,1] ? { double_bottom, y[1,2] } : y ) == 7 ) ? 1 :
             characterGenerator8x8.rdata[ attribute[1,1] ? ~{ double_right, x[1,2] } : ~x, 1 ];
}

unit character_map(
    input   uint1   clockCG,
    dualport_bram_port0 charactermap,

    input   uint10  pix_x,
    input   uint10  pix_x1,
    input   uint9   pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint8   pixel,
    output! uint1   character_map_display,

    input   uint1   blink,
    input   uint7   cursor_x,
    input   uint6   cursor_y,
    input   uint8   tpu_foreground,
    input   uint8   tpu_background,
    input   uint1   tpu_showcursor
) <reginputs> {
    characterrom512 CGROM <@clockCG> (                                                                                          // Character ROM 8x8 512 characters, 256 normal, 256 bold
        cursor_blink <: blink,
        character <: cmentry(charactermap.rdata0).character,
        attribute <: cmentry(charactermap.rdata0).attributes,
        x <: pix_x[0,3],
        y <: pix_y[0,3],
        double_right <: pix_x1[3,1],
        double_bottom <: pix_y[3,1]
    );

    uint1   is_cursor <:: tpu_showcursor & blink & ( cursor_x == ( pix_x[3,7] ) ) & ( cursor_y == pix_y[3,6] );                 // Is current coordinate the cursor coordinate, cursor visible?

    charactermap.addr0 := pix_x1[3,7] + 80 * pix_y[3,6];
    character_map_display := pix_active & ( CGROM.pixel | ( cmentry(charactermap.rdata0).background != 64 ) | is_cursor );
    pixel := is_cursor ? CGROM.pixel ? tpu_background : tpu_foreground :                                                     // IF CURSOR, INVERT PIXEL
                         CGROM.pixel ? cmentry(charactermap.rdata0).foreground :                                             // IF PIXEL, FOREGROUND
                                       cmentry(charactermap.rdata0).background;                                              // ELSE BACKGROUND
}

unit cmcursorx(
    input   uint7   tpu_active_x,
    output  uint7   NEXT,
    output  uint1   ATLAST
) <reginputs> {
    ATLAST := ( tpu_active_x == 79 );
    NEXT := tpu_active_x + 1;
}
unit cmcursory(
    input   uint6   tpu_active_y,
    output  uint6   NEXT,
) <reginputs> {
        NEXT := ( tpu_active_y == 59 ) ? 0 : tpu_active_y + 1;
}
unit cmaddresses(
    input   uint7   tpu_active_x,
    input   uint6   tpu_active_y,
    input   uint6   tpu_y,
    output  uint13  WRITEADDR,
    output  uint13  YSTARTADDR,
    output  uint13  YENDADDR
) <reginputs> {
    WRITEADDR := tpu_active_x + tpu_active_y * 80;
    YSTARTADDR := tpu_y * 80;
    YENDADDR := YSTARTADDR + 80;
}

unit character_map_writer(
    dualport_bram_port1 charactermap,

    input   uint13  memoryAddressDirect,                                                                                        // CPU MEMORY ADDRESS
    input   uint1   memoryWriteDirect,                                                                                          // CPU WRITE FLAG
    input   uint29  writeDataDirect,                                                                                            // CPU WRITE DATA
    output! uint29  readDataDirect,                                                                                             // CPU READ DATA

    // TPU to SET characters, background, foreground
    input   uint7   tpu_x,
    input   uint6   tpu_y,
    input   uint8   tpu_character,
    input   uint8   tpu_foreground,
    input   uint8   tpu_background,
    input   uint5   tpu_attributes,
    input   uint2   tpu_write,

    output  uint7   cursor_x,
    output  uint6   cursor_y
) <reginputs> {
    cmcursorx TPUX( tpu_active_x <: cursor_x );     cmcursory TPUY( tpu_active_y <: cursor_y );                                 // TPU character position
    cmaddresses TPUA( tpu_active_x <: cursor_x, tpu_active_y <: cursor_y, tpu_y <: tpu_y );                                     // ADDRESS CALCULATIONS AND BRAM write access for the TPU

    charactermap.addr1 := memoryWriteDirect ? memoryAddressDirect : TPUA.WRITEADDR;                                             // SET ADDRESS AS TPU ADDRESS FOR WRITE OR CPU ADDRESS
    charactermap.wdata1 := memoryWriteDirect ? writeDataDirect :                                                                // WRITE CPU INPUT DIRECT
                            { tpu_attributes, tpu_background, tpu_foreground, tpu_character };                                  // VIA TPU OUTPUT
    charactermap.wenable1 := memoryWriteDirect | tpu_write[1,1];

    algorithm <autorun> { while(1) {
        switch( tpu_write ) {
            default: {}
            case 1: { ( cursor_x, cursor_y ) = copycoordinates( tpu_x, tpu_y ); }                                               // Set cursor position
            case 2: {                                                                                                           // Write character,foreground, background and move
                if( TPUX.ATLAST ) {
                    cursor_x = 0; cursor_y = TPUY.NEXT;
                } else {
                    cursor_x = TPUX.NEXT;
                }
            }
        }
    } }
}
