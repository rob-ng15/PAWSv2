unit passthrough(input uint1 i,output! uint1 o)
{
  always { o=i; }
}

// CHARACTER GENERATOR ROMS FOR TERMINAL AND CHARACTERMAP
unit characterrom256(
    input   uint8   tile,
    input   uint3   y,
    output! uint8   line
) {
    brom uint8 characterGenerator8x8[2048] =  {
        $include('ROM/FONTS/CODE437-THIN.inc')
    };

    // Setup the reading of the characterGenerator8x8 ROM
    characterGenerator8x8.addr := { tile, y };
    line := characterGenerator8x8.rdata;
}

unit characterrom512(
    input   uint9   tile,
    input   uint3   y,
    output! uint8   line
) {
    brom uint8 characterGenerator8x8[4096] =  {
        $include('ROM/FONTS/CODE437-THINBOLD.inc')
    };

    // Setup the reading of the characterGenerator8x8 ROM
    characterGenerator8x8.addr := { tile, y };
    line := characterGenerator8x8.rdata;
}

unit statusdisplay(
    input   uint9   pix_x,
    input   uint8   pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint8   pixel,
    output! uint1   pixel_display,

    input   uint1   display,
    input   uint8   background(64),
    input   uint2   sdcardlightcolour,
    input   uint1   sdcarderror,
    input   uint1   JOYSTICK,
    input   uint1   CAPSLOCK,
    input   uint1   NUMLOCK,
    input   uint1   RESETSTATUS
) <reginputs> {
    // 4 ICONS, SDCARD, JOYSTICK MODE, CAPS LOCK STATUS, NUM LOCK STATUS
    brom uint16 sdcard[16] = { 16h0000, 16h3ff8, 16h3ffc, 16h3ffc, 16h3ffc, 16h3ff8, 16h1ffc, 16h1ffc, 16h3ffc, 16h3ffc, 16h3ffc, 16h3ffc, 16h3ffc, 16h3ffc, 16h3ffc, 16h0000 };
    brom uint16 joystick[16] = { 16h0000, 16h0180, 16h03c0, 16h07e0, 16h0180, 16h1188, 16h318c, 16h7ffe, 16h7ffe, 16h318c, 16h1188, 16h0180, 16h07e0, 16h03c0, 16h0180, 16h0000 };
    brom uint16 capslock[16] = { 16h0000, 16h03c0, 16h0e70, 16h381c, 16h700e, 16h6006, 16h6006, 16h7ffe, 16h7ffe, 16h6006, 16h6006, 16h6006, 16h6006, 16h6006, 16h6006, 16h0000 };
    brom uint16 numlock[16] = { 16h0000, 16h0780, 16h0d80, 16h0980, 16h0180, 16h0180, 16h0180, 16h0180, 16h0180, 16h0180, 16h0180, 16h0180, 16h0180, 16h0180, 16h0ff0, 16h0000 };

    pulse1khz COUNTER();                                                                                                        // TIMER, 1 SECOND = 1000 milliseconds

    uint8   y <:: pix_y - 1;                                                                                                    // MOVE 1 pixel in from top right
    sdcard.addr := y[0,4]; joystick.addr := y[0,4]; capslock.addr := y[0,4]; numlock.addr := y[0,4];
    pixel_display := 0; COUNTER.resetCounter := 0;

    algorithm <autorun> { while(1) {
        if( RESETSTATUS ) { COUNTER.resetCounter = 1000; }                                                                      // REQUEST TO DISPLAY STATUS LIGHTS

        if( |COUNTER.counter1khz & display & pix_x[8,1] & ~|y[4,4] ) {                                                          // CHECK IF IN RANGE
            switch( pix_x[4,2] ) {
                // SELECT PIXEL COLOUR ACCORDING TO EACH STATUS LIGHT
                case 2b00: {
                    pixel = sdcard.rdata[~pix_x[0,4],1] ? sdcarderror            ? 8h86 :                                       //        SILENT ERROR ( MAGENTA )
                                                          &sdcardlightcolour     ? 8hc1 :                                       // SDCARD   == 3 ERROR ( RED )
                                                          sdcardlightcolour[1,1] ? 8hf9 :                                       //          == 2 WRITE ( YELLOW )
                                                          sdcardlightcolour[0,1] ? 8h1f :                                       //          == 1 READ  ( BLUE )
                                                                                   8h38 :                                       //          == 0 IDLE  ( GREEN )
                                                          background;
                }
                case 2b01: { pixel = joystick.rdata[~pix_x[0,4],1] ? JOYSTICK ? 8h38 : 8h5b : background; }                     // JOYSTICK
                case 2b10: { pixel = capslock.rdata[~pix_x[0,4],1] ? CAPSLOCK ? 8h38 : 8h5b : background; }                     // CAPSLOCK
                case 2b11: { pixel = numlock.rdata[~pix_x[0,4],1] ? NUMLOCK ? 8h38 : 8h5b : background; }                       // NUMLOCK
            }
            pixel_display = ( pixel != 8h40 );                                                                                  // CHECK NOT TRANSPARENT
        }
    } }
}

unit video_memmap(
    // CLOCKS
    input   uint1   palette_clock,                                                                                              // 50MHz (double) clock
    input   uint1   video_clock,                                                                                                // 25MHz VGA (640x480@60Hz) clock
    input   uint1   gpu_clock,                                                                                                  // 25MHz (video) clock

    // Memory access via normal I/O registers
    input   uint12  memoryAddress,
    input   uint2   accesssize,
    input   uint1   memoryWrite,
    input   uint32  writeData,
    output  uint32  readData,

    // Memory access direct to bitmap / character map
    input   uint18  memoryAddressDirect,
    input   uint18  memoryAddressDirect0,
    input   uint1   BITMAPWriteDirect,
    output! uint32  BITMAPreadDataDirect,
    input   uint1   CMAPWriteDirect,
    output! uint32  CMAPreadDataDirect,

$$if HDMI then
    // HDMI OUTPUT
    output! uint4   gpdi_dp,
$$end
$$if VGA then
    // VGA OUTPUT
    output! uint$color_depth$ video_r,
    output! uint$color_depth$ video_g,
    output! uint$color_depth$ video_b,
    output  uint1 video_hs,
    output  uint1 video_vs,
$$end

    // RNG + CURSOR
    input   uint10  staticGenerator,
    input   uint1   blink,

    // STATUSLIGHTS
    input   uint2   sdcardlightcolour,
    input   uint1   sdcarderror,
    input   uint1   JOYSTICK,
    input   uint1   CAPSLOCK,
    input   uint1   NUMLOCK,
    input   uint1   RESETSTATUS
) <reginputs> {
    // Video Reset
    uint1   video_reset = uninitialised; clean_reset video_rstcond<@video_clock,!reset> ( out :> video_reset );

    // HDMI driver
    // Status of the screen, if in range, if in vblank, actual pixel x and y
    uint1   vblank = uninitialized;
    uint1   pix_active = uninitialized;
    uint10  pix_x  = uninitialized;
    uint9   pix_y  = uninitialized;
    uint1   pix_end <:: ( pix_x == 639 ) & ( pix_y == 479 );
$$if VGA then
  vga vga_driver<@video_clock,!video_reset>(
    vga_hs :> video_hs,
    vga_vs :> video_vs,
    vga_x  :> pix_x,
    vga_y  :> pix_y,
    vblank :> vblank,
    active :> pix_active
  );
$$end
$$if HDMI then
    hdmi video <@video_clock,!video_reset> (
        vblank  :> vblank,
        active  :> pix_active,
        x       :> pix_x,
        y       :> pix_y,
        gpdi_dp :> gpdi_dp
    );
$$end
    // CREATE DISPLAY LAYERS
    // PREPARE COORDINATES FOR PRE-FETCHERS, ALL LAYERS BUT BACKGROUND
    // HDMI IMAGE STARTS IMMEDIATELY AFTER VBLANK, VGA HAS A "PORCH" FOR EACH LINE, PART OF HBLANK
    // (xscreen,yscreen) is the screen coordinate that is next to be rendered.
$$if HDMI then
    uint10  xscreen <:: pix_active ? pix_x : 0;
    uint10  xscreenp1 <:: pix_active ? ( pix_x + 1 ) : 0;
    uint9   yscreen <:: vblank ? 0 : pix_active ? pix_y : ( pix_y + 1 );
$$else
    uint10  xscreen <:: pix_active ? pix_x : 0;
    uint10  xscreenp1 <:: pix_active ? ( pix_x + 1 ) : 0;
    uint9   yscreen <:: vblank ? 0 : pix_y;
$$end
    uint3   hilorez = uninitialised;                                                                                            // FLAG FOR hi or lo  SWITCH FOR TILEMAPS, CHARACTERMAP { cm, tm_u, tm_l }

    // BACKGROUND
    background_memmap BACKGROUND(
        video_clock <: video_clock,
        video_reset <: video_reset,
        colourmode <: display.colour,
        pix_x      <: xscreen,
        pix_y      <: yscreen,
        pix_vblank <: vblank,
        pix_end <: pix_end,
        memoryAddress <: memoryAddress,
        writeData <: writeData,
        staticGenerator <: staticGenerator[0,10]
    );

    uint2   writeDirectBITMAP = uninitialised;                                                                                  // I/O TO VIDEO CLOCK WRITE 2 CYCLE FLAG
    bitmap_memmap BITMAP(
        video_clock <: video_clock,
        video_reset <: video_reset,
        gpu_clock <: gpu_clock,
        dither_clock <: palette_clock,
        pix_x      <: xscreen,
        pix_y      <: yscreen,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        memoryAddress <: memoryAddress,
        writeData <: writeData,
        memoryAddressDirect <: memoryAddressDirect,
        memoryAddressDirect0 <: memoryAddressDirect0,
        memoryWriteDirect <: writeDirectBITMAP[0,1],
        readDataDirect :> BITMAPreadDataDirect,
        accesssize <: accesssize,
        static8bit <: staticGenerator[0,8]
    );

    // Character Map Window
    charactermap_memmap CHARACTER_MAP(
        video_clock <: video_clock,
        video_reset <: video_reset,
        clockCG <: palette_clock,
        lorez <: hilorez[2,1],
        pix_x      <: xscreen,
        pix_x1     <: xscreenp1,
        pix_y      <: yscreen,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        blink <: blink,
        memoryAddress <: memoryAddress,
        writeData <: writeData,
        memoryAddressDirect <: memoryAddressDirect,
        memoryWriteDirect <: CMAPWriteDirect,
        readDataDirect :> CMAPreadDataDirect

    );

    // Sprite Layers - Lower and Upper
    sprite_memmap LOWER_SPRITE(
        video_clock <: video_clock,
        video_reset <: video_reset,
        pix_x      <: xscreen,
        pix_x1     <: xscreenp1,
        pix_y      <: yscreen,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_end <: pix_end,
        memoryAddress <: memoryAddress,
        writeData <: writeData,
        collision_layer_1 <: BITMAP.pixel_display,
        collision_layer_2 <: LOWER_TILE.pixel_display,
        collision_layer_3 <: UPPER_TILE.pixel_display,
        collision_layer_4 <: UPPER_SPRITE.pixel_display
    );
    sprite_memmap UPPER_SPRITE(
        video_clock <: video_clock,
        video_reset <: video_reset,
        pix_x      <: xscreen,
        pix_x1     <: xscreenp1,
        pix_y      <: yscreen,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_end <: pix_end,
        memoryAddress <: memoryAddress,
        writeData <: writeData,
        collision_layer_1 <: BITMAP.pixel_display,
        collision_layer_2 <: LOWER_TILE.pixel_display,
        collision_layer_3 <: UPPER_TILE.pixel_display,
        collision_layer_4 <: LOWER_SPRITE.pixel_display
    );

    // Tilemaps - Lower and Upper
    tilemap_memmap LOWER_TILE(
        video_clock <: video_clock,
        video_reset <: video_reset,
        clockTG <: palette_clock,
        lorez <: hilorez[0,1],
        pix_x      <: xscreen,
        pix_x1     <: xscreenp1,
        pix_y      <: yscreen,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        memoryAddress <: memoryAddress,
        writeData <: writeData
    );
    tilemap_memmap UPPER_TILE(
        video_clock <: video_clock,
        video_reset <: video_reset,
        clockTG <: palette_clock,
        lorez <: hilorez[1,1],
        pix_x      <: xscreen,
        pix_x1     <: xscreenp1,
        pix_y      <: yscreen,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        memoryAddress <: memoryAddress,
        writeData <: writeData
    );

    // STATUS LIGHTS
    statusdisplay STATUS <@video_clock,!video_reset> (
        pix_x      <: xscreenp1[1,9],
        pix_y      <: yscreen[1,8],
        pix_active <: pix_active,
        sdcardlightcolour <: sdcardlightcolour,
        sdcarderror <: sdcarderror,
        JOYSTICK <: JOYSTICK,
        CAPSLOCK <: CAPSLOCK,
        NUMLOCK <: NUMLOCK,
        RESETSTATUS <: RESETSTATUS
    );

    // Combine the display layers for display, output the select RGBM/palette/grey pixel
    simple_dualport_bram uint24 palette <@palette_clock,@clock> [256] = uninitialized;
    multiplex_display display <@video_clock,!video_reset> (
        palette_clock <: palette_clock,
        palette <:> palette,
        background_p <: BACKGROUND.pixel,
        lower_tilemap_p <: LOWER_TILE.pixel,
        lower_tilemap_display <: LOWER_TILE.pixel_display,
        upper_tilemap_p <: UPPER_TILE.pixel,
        upper_tilemap_display <: UPPER_TILE.pixel_display,
        lower_sprites_p <: LOWER_SPRITE.pixel,
        lower_sprites_display <: LOWER_SPRITE.pixel_display,
        upper_sprites_p <: UPPER_SPRITE.pixel,
        upper_sprites_display <: UPPER_SPRITE.pixel_display,
        bitmap_p <: BITMAP.pixel,
        bitmap_display <: BITMAP.pixel_display,
        character_map_p <: CHARACTER_MAP.pixel,
        character_map_display <: CHARACTER_MAP.pixel_display,
        status_p <: STATUS.pixel,
        status_display <: STATUS.pixel_display
    );

    uint4   dimmer = 0;

    BACKGROUND.memoryWrite := 0; BITMAP.memoryWrite := 0; CHARACTER_MAP.memoryWrite := 0; LOWER_SPRITE.memoryWrite := 0; UPPER_SPRITE.memoryWrite := 0;
    LOWER_TILE.memoryWrite := 0; UPPER_TILE.memoryWrite := 0; palette.wenable1 := 0; palette.wdata1 := writeData;

    $$if VGA then
        video_r := display.pix_red[2,6] >> dimmer; video_g := display.pix_green[2,6] >> dimmer; video_b := display.pix_blue[2,6] >> dimmer;
    $$end
    $$if HDMI then
        video.red := display.pix_red >> dimmer; video.green := display.pix_green >> dimmer; video.blue := display.pix_blue >> dimmer;
    $$end

    algorithm <autorun> {
        // SET DEFAULT DISPLAY ORDER, COLOUR MODE AND DIMMER
        STATUS.display = 1; STATUS.background = 64; display.display_order = 0; display.colour = 0; display.usepalette = 0;hilorez = 0;

        while(1) {
            // READ IO Memory
            switch( memoryAddress[8,4] ) {
                case 4h0: { readData = BACKGROUND.readData; }
                case 4h1: { readData = memoryAddress[1,1] ? LOWER_TILE.tm_lastaction : memoryAddress[2,1] ? LOWER_TILE.tm_read : LOWER_TILE.tm_active; }
                case 4h2: { readData = memoryAddress[1,1] ? UPPER_TILE.tm_lastaction : memoryAddress[2,1] ? UPPER_TILE.tm_read : UPPER_TILE.tm_active; }
                case 4h3: {
                    switch( memoryAddress[1,7] ) {
                        $$for i=0,15 do
                            case $0x00 + i$: { readData = LOWER_SPRITE.sprite_read_active_$i$; }
                            case $0x10 + i$: { readData = LOWER_SPRITE.sprite_read_actions_$i$; }
                            case $0x30 + i$: { readData = {{5{LOWER_SPRITE.sprite_read_x_$i$[10,1]}}, LOWER_SPRITE.sprite_read_x_$i$}; }
                            case $0x40 + i$: { readData = {{6{LOWER_SPRITE.sprite_read_y_$i$[9,1]}}, LOWER_SPRITE.sprite_read_y_$i$}; }
                            case $0x50 + i$: { readData = LOWER_SPRITE.sprite_read_tile_$i$; }
                            case $0x60 + i$: { readData = LOWER_SPRITE.collision_$i$; }
                            case $0x70 + i$: { readData = LOWER_SPRITE.layer_collision_$i$; }
                        $$end
                        default: {}
                    }
                }
                case 4h4: {
                    switch( memoryAddress[1,7] ) {
                        $$for i=0,15 do
                            case $0x00 + i$: { readData = UPPER_SPRITE.sprite_read_active_$i$; }
                            case $0x10 + i$: { readData = UPPER_SPRITE.sprite_read_actions_$i$; }
                            case $0x30 + i$: { readData = {{5{UPPER_SPRITE.sprite_read_x_$i$[10,1]}}, UPPER_SPRITE.sprite_read_x_$i$}; }
                            case $0x40 + i$: { readData = {{6{UPPER_SPRITE.sprite_read_y_$i$[9,1]}}, UPPER_SPRITE.sprite_read_y_$i$}; }
                            case $0x50 + i$: { readData = UPPER_SPRITE.sprite_read_tile_$i$; }
                            case $0x60 + i$: { readData = UPPER_SPRITE.collision_$i$; }
                            case $0x70 + i$: { readData = UPPER_SPRITE.layer_collision_$i$; }
                        $$end
                        default: {}
                    }
                }
                case 4h5: {
                    switch( memoryAddress[1,3] ) {
                        case 3h2: { readData = memoryAddress[4,1] ? CHARACTER_MAP.tpu_cell[0,9] : CHARACTER_MAP.curses_cell[0,9]; }
                        case 3h3: { readData = memoryAddress[4,1] ? CHARACTER_MAP.tpu_cell[17,8] : CHARACTER_MAP.curses_cell[17,8]; }
                        case 3h4: { readData = memoryAddress[4,1] ? CHARACTER_MAP.tpu_cell[9,8] : CHARACTER_MAP.curses_cell[9,8]; }
                        case 3h5: { readData = CHARACTER_MAP.tpu_active; }
                        default: {}
                    }
                }
                case 4h6: { readData = memoryAddress[1,1] ? BITMAP.gpu_queue_full : BITMAP.gpu_queue_complete; }
                case 4hf: { readData = vblank; }
                default: {}
            }

            // WRITE BITMAP MEMORY DIRECTLY, TAKES 2 CYCLES DUE TO THE VIDEO CLOCK BEING 25 MHz
            if( BITMAPWriteDirect ) { writeDirectBITMAP = 2b11; } else { writeDirectBITMAP = writeDirectBITMAP[1,1]; }

            // WRITE IO Memory
            if( memoryWrite ) {
                switch( memoryAddress[8,4] ) {
                    case 4h0: { BACKGROUND.memoryWrite = 1; }
                    case 4h1: { LOWER_TILE.memoryWrite = 1; }
                    case 4h2: { UPPER_TILE.memoryWrite = 1; }
                    case 4h3: { LOWER_SPRITE.memoryWrite = 1; LOWER_SPRITE.bitmapwriter = 0;  }
                    case 4h4: { UPPER_SPRITE.memoryWrite = 1; UPPER_SPRITE.bitmapwriter = 0;  }
                    case 4h5: { CHARACTER_MAP.memoryWrite = 1; }
                    case 4h6: { BITMAP.memoryWrite = 1; }
                    case 4h8: { LOWER_SPRITE.memoryWrite = 1; LOWER_SPRITE.bitmapwriter = 1; }
                    case 4h9: { UPPER_SPRITE.memoryWrite = 1; UPPER_SPRITE.bitmapwriter = 1; }
                    case 4hf: {
                        if( memoryAddress[4,1] ) {
                            if( memoryAddress[2,1] ) {
                                if( memoryAddress[0,1] ) { display.usepalette = writeData; } else { palette.addr1 = writeData; }
                            } else {
                                palette.wenable1 = 1;
                            }
                        } else {
                            switch( memoryAddress[0,3] ) {
                                default: { display.display_order = writeData; }
                                case 1: { display.colour = writeData; }
                                case 2: { hilorez = writeData; }
                                case 3: { dimmer = writeData; }
                                case 4: { STATUS.display = writeData; }
                                case 5: { STATUS.background = writeData; }
                            }
                        }
                    }
                    default: {}
                }
            }
        }
    }
}

// ALL DISPLAY GENERATOR UNITS RUN AT 25MHz, 640 x 480 @ 60fps ( bitmap outputs 320 x 240 double sized pixels )
// DISPLAY CONTROL UNITS RUN AT 50MHz - except GPU which runs at 25MHz
// WRITING TO THE GPU THEREFORE
// LATCHES THE OUTPUT FOR 2 x 50MHz clock cycles
// AND THEN RESETS ANY CONTROLS
//
//         switch( { memoryWrite, LATCHmemoryWrite } ) {
//             case 2b10: { PERFORM THE WRITE }
//             case 2b00: { RESET }
//             default: { HOLD THE OUTPUT }
//         }
//
//         LATCHmemoryWrite = memoryWrite;

unit background_memmap(
    // Clocks
    input   uint1   video_clock,
    input   uint1   video_reset,

    // Pixels
    input   uint10  pix_x,
    input   uint9   pix_y,
    input   uint1   pix_vblank,
    input   uint1   pix_end,
    output! uint8   pixel,

    // Memory access
    input   uint6   memoryAddress,
    input   uint1   memoryWrite,
    input   uint16  writeData,
    output  uint10  readData,

    input   uint2   colourmode,
    input   uint10  staticGenerator
) <reginputs> {
    simple_dualport_bram uint4  OP  <@video_clock,@clock> [ $NUCUblocks$ ] = uninitialised;                                     // BACKGROUND CO-PROCESSOR PROGRAM STORAGE - OPCODE
    simple_dualport_bram uint3  OPD <@video_clock,@clock> [ $NUCUblocks$ ] = uninitialised;                                     //                                           DESTINATION REGISTER ( SOURCE REG1 )
    simple_dualport_bram uint1  OPF <@video_clock,@clock> [ $NUCUblocks$ ] = uninitialised;                                     //                                           REGISTER / LITERAL FLAG
    simple_dualport_bram uint10 OPL <@video_clock,@clock> [ $NUCUblocks$ ] = uninitialised;                                     //                                           RSOURCE REG 2 / LITERAL VALUE
    uint80  memoryinit = uninitialised;                                                                                         // COPPER MEMORY ( 8 x 10 BIT ENTRIES )

    // BACKGROUND GENERATOR
    background_display BACKGROUND <@video_clock,!video_reset> (
        pix_x <: pix_x,
        pix_y <: pix_y,
        pix_end <: pix_end,
        pixel :> pixel,
        staticGenerator <: staticGenerator[0,2],
        b_colour <: BACKGROUND_COPPER.BACKGROUNDcolour,
        b_alt <: BACKGROUND_COPPER.BACKGROUNDalt,
        b_mode <: BACKGROUND_COPPER.BACKGROUNDmode,
        colourmode <: colourmode
    );
    nucu BACKGROUND_COPPER <@video_clock,!video_reset> (
        pix_x <: pix_x,
        pix_y <: pix_y,
        pix_vblank <: pix_vblank,
        staticGenerator <: staticGenerator,
        backgroundcolour <: BACKGROUND_WRITER.BACKGROUNDcolour,
        backgroundcolour_alt <: BACKGROUND_WRITER.BACKGROUNDalt,
        backgroundcolour_mode <: BACKGROUND_WRITER.BACKGROUNDmode,
        OP <:> OP,
        OPD <:> OPD,
        OPF <:> OPF,
        OPL <:> OPL,
        memoryinit <: memoryinit
    );
    background_writer BACKGROUND_WRITER(
        OP <:> OP,
        OPD <:> OPD,
        OPF <:> OPF,
        OPL <:> OPL
    );

    BACKGROUND_WRITER.background_update := 0; BACKGROUND_WRITER.copper_program := 0;

    algorithm <autorun> {
        uint3   mempos = uninitialised;
        uint3   mempos_NEXT <:: mempos + 1;

        while(1) {
            if( memoryWrite ) {
                switch( memoryAddress[1,4] ) {
                    case 4h0: { BACKGROUND_WRITER.backgroundcolour = writeData; BACKGROUND_WRITER.background_update = 1; }
                    case 4h1: { BACKGROUND_WRITER.backgroundcolour_alt = writeData; BACKGROUND_WRITER.background_update = 2; }
                    case 4h2: { BACKGROUND_WRITER.backgroundcolour_mode = writeData; BACKGROUND_WRITER.background_update = 3; }
                    case 4h3: { BACKGROUND_COPPER.copper_status = writeData; }
                    case 4h4: { BACKGROUND_COPPER.copper_cpu_input = writeData; }
                    case 4h5: { BACKGROUND_WRITER.copper_program = 1; }
                    case 4h6: { BACKGROUND_WRITER.copper_address = writeData; }
                    case 4h7: { BACKGROUND_WRITER.copper_op = writeData; }
                    case 4h8: { BACKGROUND_WRITER.copper_opd = writeData; }
                    case 4h9: { BACKGROUND_WRITER.copper_opf = writeData; }
                    case 4ha: { BACKGROUND_WRITER.copper_opl = writeData; }
                    case 4hb: { mempos = 0; }
                    case 4hc: { memoryinit[ mempos * 10, 10 ] = writeData; mempos = mempos_NEXT; }
                    default: {}
                }
            }

            readData = BACKGROUND_COPPER.copper_cpu_output;
        }
    }
}

unit bitmap_memmap(
    // Clocks
    input   uint1   video_clock,
    input   uint1   video_reset,
    input   uint1   gpu_clock,
    input   uint1   dither_clock,

    // Pixels
    input   uint10  pix_x,
    input   uint9   pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint8   pixel,
    output! uint1   pixel_display,

    // Memory access via I/O registers
    input   uint8   memoryAddress,
    input   uint1   memoryWrite,
    input   uint32  writeData,

    // Memory access direct to bitmap
    input   uint18  memoryAddressDirect,
    input   uint18  memoryAddressDirect0,
    input   uint2   accesssize,
    input   uint1   memoryWriteDirect,
    output! uint32  readDataDirect,
    input   uint8   static8bit,

    output  uint1   gpu_active,
    output  uint1   gpu_queue_full,
    output  uint1   gpu_queue_complete,
) <reginputs> {
    // FRAMEBUFFERS - ORGANISED AS 4x8 BIT PIXELS TO ALLOW 8, 16 AND 32 BIT ACCESS FOR 2 FRAMEBUFFERS
    dualport_bram uint8 bitmap_000 <@video_clock,@gpu_clock> [ 19200 ] = uninitialized; dualport_bram uint8 bitmap_001 <@video_clock,@gpu_clock> [ 19200 ] = uninitialized;
    dualport_bram uint8 bitmap_010 <@video_clock,@gpu_clock> [ 19200 ] = uninitialized; dualport_bram uint8 bitmap_011 <@video_clock,@gpu_clock> [ 19200 ] = uninitialized;
    dualport_bram uint8 bitmap_100 <@video_clock,@gpu_clock> [ 19200 ] = uninitialized; dualport_bram uint8 bitmap_101 <@video_clock,@gpu_clock> [ 19200 ] = uninitialized;
    dualport_bram uint8 bitmap_110 <@video_clock,@gpu_clock> [ 19200 ] = uninitialized; dualport_bram uint8 bitmap_111 <@video_clock,@gpu_clock> [ 19200 ] = uninitialized;

    // BITMAP DISPLAY
    framebuffer_read framebuffer_display <@video_clock,!video_reset> (                                                          // READ FROM FRAMEBUFFERS FOR DISPLAY
        bitmap_000 <:> bitmap_000, bitmap_001 <:> bitmap_001, bitmap_010 <:> bitmap_010, bitmap_011 <:> bitmap_011,
        bitmap_100 <:> bitmap_100, bitmap_101 <:> bitmap_101, bitmap_110 <:> bitmap_110, bitmap_111 <:> bitmap_111,

        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: pix_vblank,
        pixel    :> pixel,
        bitmap_display :> pixel_display
    );

    framebuffer_write framebuffer <@gpu_clock,!video_reset> (                                                                   // GPU AND CPU ACCESS TO FRAMEBUFFERS
        dither_clock <: dither_clock,

        memoryAddressDirect <: memoryAddressDirect,                                                                             // GPU HAS PRIORITY
        addressL <: memoryAddressDirect0,
        accesssize <: accesssize,                                                                                               // HANDLES CPU READING AND WRITING
        memoryWriteDirect <: memoryWriteDirect,
        writeDataDirect <: writeData,
        readDataDirect :> readDataDirect,

        bitmap_000 <:> bitmap_000, bitmap_001 <:> bitmap_001, bitmap_010 <:> bitmap_010, bitmap_011 <:> bitmap_011,             // FRAMEBUFFER 0 - REAR FRAMEBUFFER FOR DUAL DISPLAY
        bitmap_100 <:> bitmap_100, bitmap_101 <:> bitmap_101, bitmap_110 <:> bitmap_110, bitmap_111 <:> bitmap_111,             // FRAMEBUFFER 1 - FRONT FRAMEBUFFER FOR DUAL DISPLAY

        bitmap_x_write <: pixel_writer.bitmap_x_write,
        bitmap_y_write <: pixel_writer.bitmap_y_write,
        bitmap_colour_write <: pixel_writer.bitmap_colour_write,
        bitmap_colour_write_alt <: pixel_writer.bitmap_colour_write_alt,
        bitmap_write <: pixel_writer.bitmap_write,
        bitmap_crop_left <: pixel_writer.bitmap_crop_left,
        bitmap_crop_right <: pixel_writer.bitmap_crop_right,
        bitmap_crop_top <: pixel_writer.bitmap_crop_top,
        bitmap_crop_bottom <: pixel_writer.bitmap_crop_bottom,
        gpu_active_dithermode <: pixel_writer.gpu_active_dithermode,
        static8bit <: static8bit
    );

    simple_dualport_bram uint16 blit1tilemap <@video_clock,@clock> [ 1024 ] = uninitialized;                                    // 64 x 16 x 16 1 bit tilemap for blit1tilemap
    simple_dualport_bram uint8 characterGenerator8x8 <@video_clock,@clock> [] = {                                               // Character ROM 8x8 x 512 for character blitter
        $include('ROM/FONTS/CODE437-THINBOLD.inc')
    };
    simple_dualport_bram uint8 colourblittilemap <@video_clock,@clock> [ 16384 ] = uninitialized;                               // 64 x 16 x 16 8 bit tilemap for colourblittilemap
    simple_dualport_bram uint8 pb_colourmap <@video_clock,@clock> [ 256 ] = uninitialized;                                      // 256 colour remapper

    bitmapwriter pixel_writer <@gpu_clock,!video_reset> (                                                                       // WRITE TO FRAMEBUFFER  GPU/CPU
        blit1tilemap <:> blit1tilemap,
        characterGenerator8x8 <:> characterGenerator8x8,
        colourblittilemap <:> colourblittilemap,
        pb_colourmap <:> pb_colourmap,
        gpu_queue_full :> gpu_queue_full,
        gpu_queue_complete :> gpu_queue_complete,
        gpu_active :> gpu_active
    );

    blit1tilemap.wdata1 := writeData; blit1tilemap.wenable1 := 0;
    characterGenerator8x8.wdata1 := writeData; characterGenerator8x8.wenable1 := 0;
    colourblittilemap.wdata1 := writeData; colourblittilemap.wenable1 := 0;
    pb_colourmap.wenable1 := 1;

    algorithm <autorun> {
        int10   minmax <:: ( __signed( writeData ) < __signed( -512 ) ) ? -512 :                                                // ADJUST FOR 10bit underflow/overflow for pixel coordinates
                        ( __signed( writeData ) > __signed( 511 ) ) ? 511 : writeData;
        uint8   RGBM <:: { writeData[22,2], writeData[13,3], writeData[6,2], writeData[21,1] & writeData[5,1] };                // CONVERT RGB COLOUR TO RGBM COLOUR

        // BLITTER TILEBITMAP WRITERS - SETTING THE TILE RESETS THE COUNT, WRITING A PIXEL INCREMENTS THE COUNT
        uint4   BTWline_NEXT <:: blit1tilemap.addr1[0,4] + 1;
        uint3   CTWline_NEXT <:: characterGenerator8x8.addr1[0,3] + 1;
        uint8   CBTWpixel_NEXT <:: colourblittilemap.addr1[0,8] + 1;

        // RESET THE CROPPING RECTANGLE AND DISPLAY256 FLAG
        pixel_writer.pb_mode = 0; pixel_writer.crop_left = 0; pixel_writer.crop_right = 319; pixel_writer.crop_top = 0; pixel_writer.crop_bottom = 239; framebuffer_display.display256 = 0;

        while(1) {
            uint1   LATCHmemoryWrite = uninitialized;                                                                           // LATCH MEMORYWRITE

            switch( { memoryWrite, LATCHmemoryWrite } ) {
                case 2b10: {
                    switch( memoryAddress[4,4] ) {
                        case 4h0: {
                            switch( memoryAddress[1,3] ) {                                                                      // SET GPU COORDINATES - ADJUST INTO RANGE
                                case 3h0: { pixel_writer.gpu_x = minmax; }
                                case 3h1: { pixel_writer.gpu_y = minmax; }
                                case 3h2: { pixel_writer.gpu_param0 = minmax; }
                                case 3h3: { pixel_writer.gpu_param1 = minmax; }
                                case 3h4: { pixel_writer.gpu_param2 = minmax; }
                                case 3h5: { pixel_writer.gpu_param3 = minmax; }
                                case 3h6: { pixel_writer.gpu_param4 = minmax; }
                                case 3h7: { pixel_writer.gpu_param5 = minmax; }
                            }
                        }
                        case 4h1: {
                            switch( memoryAddress[1,2] ) {
                                case 2h0: {                                                                                     // SET GPU COLOUR
                                    if( accesssize[1,1] ) {
                                        pixel_writer.gpu_colour = RGBM;                                                         //  32 BIT RGB -> 8 BIT RGBM
                                    } else {
                                        pixel_writer.gpu_colour = writeData;                                                    //  8 BIT RGBM
                                    }
                                }
                                case 2h1: { pixel_writer.gpu_colour_alt = writeData; }
                                case 2h2: { pixel_writer.gpu_dithermode = writeData; }
                                case 2h3: { pixel_writer.gpu_write = writeData; }
                            }
                        }
                        case 4h4: {
                            switch( memoryAddress[1,1] ) {
                                case 0: { blit1tilemap.addr1 = { writeData[0,6], 4hf }; }
                                case 1: { blit1tilemap.addr1[0,4] = BTWline_NEXT; blit1tilemap.wenable1 = 1; }
                            }
                        }
                        case 4h5: {
                            switch( memoryAddress[1,1] ) {
                                case 0: { characterGenerator8x8.addr1 = { writeData[0,6], 3h7 }; }
                                case 1: { characterGenerator8x8.addr1[0,3] = CTWline_NEXT; characterGenerator8x8.wenable1 = 1; }
                            }
                        }
                        case 4h6: {
                            switch( memoryAddress[1,1] ) {
                                case 0: { colourblittilemap.addr1 = { writeData[0,6], 8hff }; }
                                case 1: { colourblittilemap.addr1[0,8] = CBTWpixel_NEXT; colourblittilemap.wenable1 = 1; }
                            }
                        }
                        case 4h7: {
                            switch( memoryAddress[1,3] ) {
                                case 3h0: { pixel_writer.pb_colour = writeData; pixel_writer.pb_newpixel = 1; }
                                case 3h1: { pixel_writer.pb_colour8r = writeData; }
                                case 3h2: { pixel_writer.pb_colour8g = writeData; }
                                case 3h3: { pixel_writer.pb_colour8b = writeData; pixel_writer.pb_newpixel = 2; }
                                case 3h4: { pixel_writer.pb_newpixel = 3; }
                                case 3h5: { pixel_writer.pb_mode = writeData; }
                                case 3h6: { pb_colourmap.addr1 = writeData; }
                                case 3h7: { pb_colourmap.wdata1 = writeData; }
                            }
                        }
                        case 4h8: {
                            switch( memoryAddress[2,2] ) {                                                                                                                  // PIXELBLOCK ARGB RGBA ABGR BGRA modes
                                case 2b00: {
                                    pixel_writer.pb_colour8r = writeData[16,8]; pixel_writer.pb_colour8g = writeData[8,8]; pixel_writer.pb_colour8b = writeData[0,8];       // ARGB
                                }
                                case 2b01: {
                                    pixel_writer.pb_colour8r = writeData[24,8]; pixel_writer.pb_colour8g = writeData[16,8]; pixel_writer.pb_colour8b = writeData[8,8];      // RGBA
                                }
                                case 2b10: {
                                    pixel_writer.pb_colour8r = writeData[0,8]; pixel_writer.pb_colour8g = writeData[8,8]; pixel_writer.pb_colour8b = writeData[16,8];       // ABGR
                                }
                                case 2b11: {
                                    pixel_writer.pb_colour8r = writeData[8,8]; pixel_writer.pb_colour8g = writeData[16,8]; pixel_writer.pb_colour8b = writeData[24,8];      // BGRA
                                }
                            }
                            pixel_writer.pb_newpixel = 2;
                        }
                        case 4he: {
                            switch( memoryAddress[1,2] ) {                                                                      // SET GPU CROP - ADJUST INTO RANGE
                                case 2h0: { pixel_writer.crop_left = minmax; }
                                case 2h1: { pixel_writer.crop_right = minmax; }
                                case 2h2: { pixel_writer.crop_top = minmax; }
                                case 2h3: { pixel_writer.crop_bottom = minmax; }
                            }
                        }
                        case 4hf: {
                            switch( memoryAddress[1,2] ) {
                                default: { framebuffer_display.framebuffer = writeData; }
                                case 2h1: { framebuffer.framebuffer = writeData; }
                                case 2h2: { framebuffer_display.display256 = writeData; }
                            }
                        }
                        default: {}

                    }
                }
                case 2b00: { pixel_writer.gpu_write = 0;  pixel_writer.pb_newpixel = 0; }
                default: {}
            }

            LATCHmemoryWrite = memoryWrite;
        }
    }
}

unit charactermap_memmap(
    // Clocks
    input   uint1   video_clock,
    input   uint1   video_reset,
    input   uint1   clockCG,

    // Pixels
    input   uint10  pix_x,
    input   uint10  pix_x1,
    input   uint9   pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint8   pixel,
    output! uint1   pixel_display,
    input   uint1   blink,
    input   uint1   lorez,

    // Memory access
    input   uint4   memoryAddress,
    input   uint1   memoryWrite,
    input   uint25  writeData,

    // Memory access direct to charactermap
    input   uint15  memoryAddressDirect,
    input   uint1   memoryWriteDirect,
    output! uint25  readDataDirect,

    output  uint5   tpu_active,
    output  uint25  tpu_cell,
    output  uint25  curses_cell,
) <reginputs> {
    // 80 x 30 character buffer
    dualport_bram uint25 charactermap <@video_clock,@clock> [4800] = uninitialized;

    // CHARACTER MAP DISPLAY
    uint10  dopix_x <:: lorez ? pix_x[1,9] : pix_x;  uint10  dopix_x1 <:: lorez ? pix_x1[1,9] : pix_x1; uint9  dopix_y <:: lorez ? pix_y[1,8] : pix_y;
    character_map character_map_window <@video_clock,!video_reset> (
        clockCG <: clockCG,
        charactermap <:> charactermap,
        pix_x      <: dopix_x,
        pix_x1     <: dopix_x1,
        pix_y      <: dopix_y,
        pix_active <: pix_active,
        pix_vblank <: pix_vblank,
        pixel    :> pixel,
        character_map_display :> pixel_display,
        blink <: blink,
        cursor_x <: CMW.cursor_x,
        cursor_y <: CMW.cursor_y
    );

    // CHARACTER MAP WRITER
    character_map_writer CMW( charactermap <:> charactermap, writeDataDirect <: writeData, memoryAddressDirect <: memoryAddressDirect[2,13], memoryWriteDirect <: memoryWriteDirect, readDataDirect :> readDataDirect );
    CMW.tpu_write := 0;

    algorithm <autorun> { while(1) {
        if( memoryWrite ) {
            switch( memoryAddress[1,3] ) {
                case 3h0: { CMW.tpu_x = writeData; }
                case 3h1: { CMW.tpu_y = writeData; }
                case 3h2: { CMW.tpu_character = writeData; }
                case 3h3: { CMW.tpu_background = writeData; character_map_window.tpu_background = writeData; }
                case 3h4: { CMW.tpu_foreground = writeData; character_map_window.tpu_foreground = writeData; }
                case 3h5: { CMW.tpu_write = writeData; }
                case 3h6: { character_map_window.tpu_showcursor = writeData; }
                default: {}
            }
        }
    } }
}

unit sprite_memmap(
    // Clocks
    input   uint1   video_clock,
    input   uint1   video_reset,

    // Pixels
    input   uint10  pix_x,
    input   uint10  pix_x1,
    input   uint9   pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    input   uint1   pix_end,
    output(!) uint8   pixel,
    output(!) uint1   pixel_display,

    // Memory access
    input   uint1   bitmapwriter,
    input   uint8   memoryAddress,
    input   uint1   memoryWrite,
    input   uint16  writeData,

    input   uint1   collision_layer_1,
    input   uint1   collision_layer_2,
    input   uint1   collision_layer_3,
    input   uint1   collision_layer_4,

    // For reading sprite characteristics
    $$for i=0,15 do
        output  uint1   sprite_read_active_$i$,
        output  uint4   sprite_read_actions_$i$,
        output  int11   sprite_read_x_$i$,
        output  int10   sprite_read_y_$i$,
        output  uint3   sprite_read_tile_$i$,
        output uint16   collision_$i$,
        output uint4    layer_collision_$i$,
    $$end
) <reginputs> {
    $$for i=0,15 do
        // Sprite Tiles - 16 x 16 x 8 in RRGGGBBM colour
        simple_dualport_bram uint8 tiles_$i$ <@video_clock,@clock> [2048] = uninitialised;
    $$end

    sprite_layer sprites <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_x1     <: pix_x1,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: pix_vblank,
        pix_end <: pix_end,
        pixel    :> pixel,
        sprite_layer_display :> pixel_display,
        collision_layer_1 <: collision_layer_1,
        collision_layer_2 <: collision_layer_2,
        collision_layer_3 <: collision_layer_3,
        collision_layer_4 <: collision_layer_4,
        $$for i=0,15 do
            sprite_read_active_$i$ <: sprite_read_active_$i$,
            sprite_read_actions_$i$ <: sprite_read_actions_$i$,
            sprite_read_x_$i$ <: sprite_read_x_$i$,
            sprite_read_y_$i$ <: sprite_read_y_$i$,
            sprite_read_tile_$i$ <: sprite_read_tile_$i$,
            collision_$i$ :> collision_$i$,
            layer_collision_$i$ :> layer_collision_$i$,
        $$end
        $$for i=0,15 do
            tiles_$i$ <:> tiles_$i$,
        $$end
    );
    sprite_layer_writer SLW(
        $$for i=0,15 do
            sprite_read_active_$i$ :> sprite_read_active_$i$,
            sprite_read_actions_$i$ :> sprite_read_actions_$i$,
            sprite_read_x_$i$ :> sprite_read_x_$i$,
            sprite_read_y_$i$ :> sprite_read_y_$i$,
            sprite_read_tile_$i$ :> sprite_read_tile_$i$,
        $$end
        // SET SPRITE NUMBER AND VALUE TO WRITE FROM THE MEMORY ADDRESS
        sprite_set_number <: memoryAddress[1,4],
        sprite_write_value <: writeData
    );

    $$for i=0,15 do
        tiles_$i$.wdata1 := writeData;
        tiles_$i$.wenable1 := 0;
    $$end
    SLW.sprite_layer_write := 0;

    algorithm <autorun> {
        uint12  writerpixel = uninitialised;             uint12  writerpixel_NEXT <:: writerpixel + 1;
        uint3   sprite_register <:: memoryAddress[5,3] + 1;

        while(1) {
            // SPRITE BITMAP WRITER - SETTING THE SPRITE NUMBER RESETS THE COUNT, WRITING A PIXEL INCREMENTS THE COUNT - ALLOWS USE OF DMA TRANSFER
            uint4   writerspritenumber = uninitialised;

            if( memoryWrite ) {
                if( bitmapwriter ) {
                    switch( memoryAddress[1,1] ) {
                        case 0: { writerspritenumber = writeData; writerpixel = 0; }
                        case 1: {
                            switch( writerspritenumber ) {
                                $$for i=0,15 do
                                    case $i$: { tiles_$i$.addr1 = writerpixel; tiles_$i$.wenable1 = 1; }
                                $$end
                            }
                            writerpixel = writerpixel_NEXT;
                        }
                    }
                } else {
                    SLW.sprite_layer_write = sprite_register;                                                                   // SET SPRITE ATTRIBUTE
                }
            }
        }
    }
}

unit tilemap_memmap(
    // Clocks
    input   uint1   video_clock,
    input   uint1   video_reset,
    input   uint1   clockTG,
    input   uint1   lorez,

    // Pixels
    input   uint10  pix_x,
    input   uint10  pix_x1,
    input   uint9   pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint8   pixel,
    output! uint1   pixel_display,

    // Memory access
    input   uint6   memoryAddress,
    input   uint1   memoryWrite,
    input   uint16  writeData,
    output  uint9   tm_read,
    output  uint6   tm_base_x,
    output  uint6   tm_base_y,
    output  uint4   tm_lastaction,
    output  uint3   tm_active
) <reginputs> {
    // Tiles 64 x 16 x 16 ARRGGBB ( first tile defaults to transparent )
    simple_dualport_bram uint8 tiles16x16 <@clockTG,@clock> [ 16384 ] = {
        64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
        64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
        64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
        64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
        64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
        64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
        64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
        64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
        64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
        64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
        64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
        64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
        64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
        64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
        64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
        64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
        pad(uninitialized)
    };

    // 64 x 64 tile map, 40 x 32 visiable, allows for pixel scrolling with border { 3 bits rotation/reflection, 6 bits tile number }
    dualport_bram uint9 tiles <@video_clock,@clock> [4096] = uninitialized;

    uint10  dopix_x <:: lorez ? pix_x[1,9] : pix_x; uint10  dopix_x1 <:: lorez ? pix_x1[1,9] : pix_x1; uint9  dopix_y <:: lorez ? pix_y[1,8] : pix_y;
    tilemap tile_map <@video_clock,!video_reset> (
        clockTG <: clockTG,
        tiles16x16 <:> tiles16x16,
        tiles <:> tiles,
        pix_x      <: dopix_x,
        pix_x1     <: dopix_x1,
        pix_y      <: dopix_y,
        pix_active <: pix_active,
        pix_vblank <: pix_vblank,
        pixel    :> pixel,
        base_x <: TMW.base_x,
        base_y <: TMW.base_y,
        tm_offset_x <: TMW.tm_offset_x,
        tm_offset_y <: TMW.tm_offset_y,
        tilemap_display :> pixel_display
    );

    tile_map_writer TMW( tiles <:> tiles, tm_read :> tm_read, base_x :> tm_base_x, base_y :> tm_base_y, tm_lastaction :> tm_lastaction, tm_active :> tm_active );
    tiles16x16.wdata1 := writeData; tiles16x16.wenable1 := 0; TMW.tm_write := 0; TMW.tm_scrollwrap := 0;

    algorithm <autorun> {
        uint8   TBMWpixel_NEXT <:: tiles16x16.addr1[0,8] + 1;                                                                   // NEXT PIXEL IN TILE

        while(1) {
            if( memoryWrite ) {
                switch( memoryAddress[1,3] ) {
                    case 3h0: { TMW.tm_x = writeData; }                                                                         // SET X
                    case 3h1: { TMW.tm_y = writeData; }                                                                         // SET Y
                    case 3h2: { TMW.tm_character = writeData; }                                                                 // SET TILE NUMBER
                    case 3h3: { TMW.tm_actions = writeData; }                                                                   // SET ACTION ( ROTATION AND REFLECTION )
                    case 3h4: { TMW.tm_write = 1; }                                                                             // COMMIT TO TILEMAP
                    case 3h5: { tiles16x16.addr1 = { writeData[0,6], 8hff }; }                                                  // TILE BITMAP WRITER, MOVE TO NEW TILE
                    case 3h6: { tiles16x16.addr1[0,8] = TBMWpixel_NEXT; tiles16x16.wenable1 = |tiles16x16.addr1[8,6]; }         // TILE BITMAP WRITER, MOVE TO NEXT PIXEL, ONLY WRITE IF NOT TILE 0
                    case 3h7: { if( memoryAddress[0,1] ) { TMW.tm_adjust = writeData; } else { TMW.tm_scrollwrap = writeData; } }
                }
            }
        }
    }
}
