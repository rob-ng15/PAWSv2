// RISC V INSTRUCTION DECODER + REGISTER BLOCK
unit control(
    // THREAD, DMA AND MEMORY ACCESS SIZE
    input   uint1   cacheselect,
    output  uint2   accesssize,
    output  uint1   IS_MEM64,
    input   uint1   DMAACTIVE,
    input   uint2   DMAACCESSSIZE,
    input   uint1   SMT,
    input   uint1   COMMIT_SMT,

    // PC and instruction decoding
    input   uint$addr_width$ PC,
    input   uint32  instruction,
    input   uint1   compressed,
    output  uint5   opCode,
    output  uint3   function3,
    output  uint7   function7,
    output  uint5   rs1,
    output  uint5   rs2,
    output  uint64  immediateValue,
    output  uint1   IS_AUIPCLUI,
    output  uint1   IS_JAL,
    output  uint1   IS_CSR,
    output  uint1   IS_ATOMIC,
    output  uint1   IS_FPU,
    output  uint1   IS_LOAD,
    output  uint1   IS_STORE,
    output  uint1   IS_FENCE,
    output  uint1   IS_ALU,
    output  uint1   IS_FAST,
    output  uint1   IS_FASTFPU,
    output  uint1   IS_ALU32,
    output  uint1   IS_ALU32SIGNX,

    // REGISTER OUTPUT, RESULT INPUT AND RESULT TYPE (I/F)
    input   uint1   frd,
    input   uint1   write,
    input   uint64  result,
    output  uint64  sourceReg1,
    output  uint32  S1_abs32,
    output  uint64  S1_abs64,
    output  uint64  sourceReg2,
    output  uint32  S2_abs32,
    output  uint64  S2_abs64,
    output  uint1   writeRegisterF,
    output  uint1   writeRegister,

    // REGISTER COMPARISONS
    output  uint1   LT,
    output  uint1   LTU,
    output  uint1   EQ,

    // ADDRESS GENERATION
    output  uint64  AUIPCLUI,
    output  uint$addr_width$  loadAddress,
    output  uint$addr_width$  storeAddress,
    output  uint1   IS_MA,
    output  uint$addr_width$  nextPC,
    output  uint$addr_width$  newPC
) <reginputs> {
    // INSTRUCTION CLASSIFICATION AND CPU CONTROL FLAGS
    controlflags FLAGS(
        opCode <: Rtype(instruction).opCode[2,5],
        function3 <: Rtype(instruction).function3,
        function7 <: Rtype(instruction).function7,
        IS_AUIPCLUI :> IS_AUIPCLUI,
        IS_JAL :> IS_JAL,
        IS_CSR :> IS_CSR,
        IS_ATOMIC :> IS_ATOMIC,
        IS_LOAD :> IS_LOAD,
        IS_STORE :> IS_STORE,
        IS_FENCE :> IS_FENCE,
        writeRegister :> writeRegister,
        writeRegisterF :> writeRegisterF,
        IS_FPU :> IS_FPU,
        IS_ALU :> IS_ALU,
        IS_ALU32 :> IS_ALU32,
        IS_ALU32SIGNX :> IS_ALU32SIGNX,
        IS_FAST :> IS_FAST,
        IS_FASTFPU :> IS_FASTFPU
    );

    // DETERMINE MEMORY ACCESS FLAGS
    memsize MEMACCESSFLAGS(
        cacheselect <: cacheselect,
        DMAACTIVE <: DMAACTIVE,
        DMAACCESSSIZE <: DMAACCESSSIZE,
        function3 <: Rtype(instruction).function3[0,2],
        I1R <: I1R.rdata0[0,1],
        I20 <: instruction[20,1],
        I7 <: instruction[7,1],
        IS_ATOMIC <: FLAGS.IS_ATOMIC,
        IS_LOAD <: FLAGS.IS_LOAD,
        IS_STORE <: FLAGS.IS_STORE,
        IS_MA :> IS_MA,
        IS_MEM64 :> IS_MEM64,
        accesssize :> accesssize
    );

    // ADDRESS GENERATORS
    loadaddress LA( instruction <: instruction, IS_ATOMIC <: FLAGS.IS_ATOMIC, I1R <: I1R.rdata0, loadAddress :> loadAddress );
    storeaddress SA( instruction <: instruction, IS_ATOMIC <: FLAGS.IS_ATOMIC, I1R <: I1R.rdata0, storeAddress :> storeAddress );
    jumpaddress JA( instruction <: instruction, IS_BRANCH <: FLAGS.IS_BRANCH, PC <: PC );
    auipclui AUI( instruction <: instruction, PC <: PC, AUIPCLUI :> AUIPCLUI );
    incpc INCPC( PC <: PC, compressed <: compressed, nextPC :> nextPC );

    simple_dualport_bram int64 I1[64] = { 0, pad(uninitialized) };                                                              // 32 MAIN, 32 SMT INTEGER REGISTERS - sourceReg1
    simple_dualport_bram int64 I2[64] = { 0, pad(uninitialized) };                                                              // 32 MAIN, 32 SMT INTEGER REGISTERS - sourceReg2

    uint1   Iwrite <:: write & ~frd & |Rtype(instruction).destReg;                                                              // INTEGER REGISTER WRITE SWITCH
    regR I1R( SMT <: SMT, regfile <:> I1, addr0 <: Rtype(instruction).sourceReg1, rdata0 :> sourceReg1 );                       // INTEGER REGISTERS - sourceReg1 - READ
    regR I2R( SMT <: SMT, regfile <:> I2, addr0 <: Rtype(instruction).sourceReg2, rdata0 :> sourceReg2 );                       // INTEGER REGISTERS - sourceReg2 - READ
    regW I1W( SMT <: COMMIT_SMT, regfile <:> I1, addr1 <: Rtype(instruction).destReg, wdata1 <: result, wenable1 <: Iwrite );   // INTEGER REGISTERS - sourceReg1 - WRITE
    regW I2W( SMT <: COMMIT_SMT, regfile <:> I2, addr1 <: Rtype(instruction).destReg, wdata1 <: result, wenable1 <: Iwrite );   // INTEGER REGISTERS - sourceReg2 - WRITE

    abs3264 S1_abs( sourceReg <: I1R.rdata0, abs32 :> S1_abs32, abs64 :> S1_abs64 );                                            // ABSOLUTE VALUES OF sourceReg1
    abs3264 S2_abs( sourceReg <: I2R.rdata0, abs32 :> S2_abs32, abs64 :> S2_abs64 );                                            // ABSOLUTE VALUES OF sourceReg2

    int64   operand2 <:: instruction[5,1] ? I2R.rdata0 : { {52{instruction[31,1]}}, Itype(instruction).immediate };             // REGISTER OR IMMEDIATE FOR COMPARISONS
    uint4   flags <:: { COMPARE.LTU, COMPARE.LT, 1b0, COMPARE.EQ };                                                             // COMPARISON RESULT { LESS UNSIGNED, LESS SIGNED, 0, EQUAL }
    integercomparisons COMPARE(                                                                                                 // GENERATE INTEGER COMPARISONS
        sourceReg1 <: I1R.rdata0,
        operand2 <: operand2,
        LT :> LT,
        LTU :> LTU,
        EQ :> EQ
    );

    opCode := instruction[2,5]; function3 := Rtype(instruction).function3; function7 := Rtype(instruction).function7;           // EXTRACT BITFIELDS FROM INSTRUCTION
    immediateValue := { {52{instruction[31,1]}}, Itype(instruction).immediate };                                                // EXTRACT AND SIGN EXTEND IMMEDIATE VALUE FROM INSTRUCTION
    rs1 := Rtype(instruction).sourceReg1; rs2 := Rtype(instruction).sourceReg2;                                                 // EXTRACT REGISTER NUMBERS FROM INSTRUCTION

    newPC := FLAGS.incPC ? ( FLAGS.IS_BRANCH & ( Rtype(instruction).function3[0,1] ^ flags[ Rtype(instruction).function3[1,2], 1 ] ) ? JA.jumpAddress : INCPC.nextPC ) :
                           ( instruction[3,1] ? JA.jumpAddress : LA.loadAddress );
}

unit float_control(
    input   uint32  instruction,                                                                                                // INSTRUCTION AND THREAD
    input   uint1   SMT,
    input   uint1   COMMIT_SMT,

    input   uint1   frd,                                                                                                        // REGISTER OUTPUT, RESULT INPUT AND RESULT TYPE (I/F)
    input   uint1   write,
    input   uint64  result,

    output  uint64  sourceReg1F,                                                                                                // ACTUAL FLOATING POINT REGISTERS
    output  uint64  sourceReg2F,
    output  uint64  sourceReg3F,
    output  uint64  sourceReg1Fx,                                                                                               // REPACKED FLOATING POINT REGISTERS INTO DOUBLE BITFIELDS
    output  uint64  sourceReg2Fx,
    output  uint64  sourceReg3Fx,
    output  uint64  sourceReg1Fxopp,                                                                                            // REPACKED FLOATING POINT REGISTER FOR CHANGE PRECISION
    output  uint4   typeAF,                                                                                                     // { INF sNAN qNAN ZERO } OF INPUT FLOAT REGISTER 1
    output  uint4   typeBF,                                                                                                     // { INF sNAN qNAN ZERO } OF INPUT FLOAT REGISTER 2
    output  uint4   typeCF,                                                                                                     // { INF sNAN qNAN ZERO } OF INPUT FLOAT REGISTER 3
    output  uint4   typeAopp,                                                                                                   // { INF sNAN qNAN ZERO } OF INPUT FLOAT REGISTER 1 FOR CHANGE PRECISION
    output  uint1   aObINF,                                                                                                     // EITHER A OR B INF?
    output  uint1   aAbINF,                                                                                                     // BOTH A AND B INF?
    output  uint1   aObNAN,                                                                                                     // EITHER A OR B NAN?
    output  uint1   aObZERO,                                                                                                    // EITHER A OR B ZERO?
    output  uint1   aAbZERO,                                                                                                    // BOTH A AND B ZERO?
    output  uint1   aZEROFRACTION,                                                                                              // A FRACTION PART 0, POWER OF TWO DETECTION AND TRUEZERO
    output  uint1   bZEROFRACTION,                                                                                              // B FRACTION PART 0, POWER OF TWO DETECTION AND TRUEZERO

    output  uint1   FLT,                                                                                                        // FLOAT REGISTER COMPARISONS   LESS THAN
    output  uint1   FEQ                                                                                                         //                              EQUAL
) <reginputs> {
    simple_dualport_bram int64 F1[64] = uninitialized;                                                                          // 32 MAIN, 32 SMT FLOAT REGISTERS - sourceReg1
    simple_dualport_bram int64 F2[64] = uninitialized;                                                                          // 32 MAIN, 32 SMT FLOAT REGISTERS - sourceReg2
    simple_dualport_bram int64 F3[64] = uninitialized;                                                                          // 32 MAIN, 32 SMT FLOAT REGISTERS - sourceReg3

    uint1   Fwrite <:: write & frd;                                                                                             // REGISTER WRITE SWITCHES
    regR F1R( SMT <: SMT, regfile <:> F1, addr0 <: R4type(instruction).sourceReg1, rdata0 :> sourceReg1F );                     //  READ REGISTERS   sourceReg1
    regR F2R( SMT <: SMT, regfile <:> F2, addr0 <: R4type(instruction).sourceReg2, rdata0 :> sourceReg2F );                     //                   sourceReg2
    regR F3R( SMT <: SMT, regfile <:> F3, addr0 <: R4type(instruction).sourceReg3, rdata0 :> sourceReg3F );                     //                   sourceReg3
    regW F1W( SMT <: COMMIT_SMT, regfile <:> F1, addr1 <: Rtype(instruction).destReg, wdata1 <: result, wenable1 <: Fwrite );   //  WRITE REGISTERS  sourceReg1
    regW F2W( SMT <: COMMIT_SMT, regfile <:> F2, addr1 <: Rtype(instruction).destReg, wdata1 <: result, wenable1 <: Fwrite );   //                   sourceReg2
    regW F3W( SMT <: COMMIT_SMT, regfile <:> F3, addr1 <: Rtype(instruction).destReg, wdata1 <: result, wenable1 <: Fwrite );   //                   sourceReg3

    // FLOATING POINT REGISTER TYPES - detect INF, NAN, ZERO
    typeF class1F( dsh <: Rtype(instruction).function7[0,2], a <: F1R.rdata0, zeroFRACTION :> aZEROFRACTION, type :> typeAF );  // CLASSIFY A FOR { INF, sNAN, qNAN, ZERO }, EXPORT ZEROFRACTION FLAG
    typeF class2F( dsh <: Rtype(instruction).function7[0,2], a <: F2R.rdata0, zeroFRACTION :> bZEROFRACTION, type :> typeBF );  // CLASSIFY B FOR { INF, sNAN, qNAN, ZERO }, EXPORT ZEROFRACTION FLAG
    typeF class3F( dsh <: Rtype(instruction).function7[0,2], a <: F3R.rdata0, type :> typeCF );                                 // CLASSIFY C FOR { INF, sNAN, qNAN, ZERO }

    typeF class1Fopp( dsh <: Rtype(instruction).sourceReg2[0,2], a <: F1R.rdata0, type :> typeAopp );                           // FORCE CLASSIFICATION OF DOUBLE/SINGLE/HALF FOR changeprecision
    repackage_wide Aopp( dsh <: Rtype(instruction).sourceReg2[0,2], a <: F1R.rdata0, repack :> sourceReg1Fxopp );               // BREAKDOWN sourceReg1F INTO SIGN, EXPONENT (with bias), FRACTION FOR changeprecision

    repackage_wide A( dsh <: Rtype(instruction).function7[0,2], a <: F1R.rdata0, repack :> sourceReg1Fx );                      // BREAKDOWN sourceReg1F INTO SIGN, EXPONENT (with bias), FRACTION
    repackage_wide B( dsh <: Rtype(instruction).function7[0,2], a <: F2R.rdata0, repack :> sourceReg2Fx );                      // BREAKDOWN sourceReg2F INTO SIGN, EXPONENT (with bias), FRACTION
    repackage_wide C( dsh <: Rtype(instruction).function7[0,2], a <: F3R.rdata0, repack :> sourceReg3Fx );                      // BREAKDOWN sourceReg3F INTO SIGN, EXPONENT (with bias), FRACTION

    floatcompare FPUcompare(                                                                                                    // FLOATING POINT COMPARISONS
        a <: A.repack, b <: B.repack,                                                                                           // PASS REPACKED VALUES TO COMPARE
        aObNAN <: aObNAN,                                                                                                       // A OR B NAN?
        aAbZERO <: aAbZERO,                                                                                                     // A == 0 AND B == 0
        aZEROFRACTION <: class1F.zeroFRACTION,                                                                                  // A FRACTION 0?
        bZEROFRACTION <: class2F.zeroFRACTION,                                                                                  // B FRACTION 0?
        less :> FLT, equal :> FEQ                                                                                               // A < B? A == B?
    );

    aObINF := class1F.type[3,1] | class2F.type[3,1]; aAbINF := class1F.type[3,1] & class1F.type[3,1];                           // A AND/OR B INF?
    aObNAN := |( class1F.type[1,2] | class2F.type[1,2] );                                                                       // A OR B NAN?
    aObZERO := class1F.type[0,1] | class2F.type[0,1]; aAbZERO := class1F.type[0,1] & class2F.type[0,1];                         // A AND/OR B ZERO
}

// DETERMINE MEMORY ACCESS FLAGS
unit memsize(
    input   uint1   cacheselect,
    input   uint1   DMAACTIVE,
    input   uint2   DMAACCESSSIZE,
    input   uint2   function3,
    input   uint1   I1R,
    input   uint1   I20,
    input   uint1   I7,
    input   uint1   IS_ATOMIC,
    input   uint1   IS_LOAD,
    input   uint1   IS_STORE,
    output  uint1   IS_MA,
    output  uint1   IS_MEM64,
    output  uint2   accesssize
) <reginputs> {
    accesssize := DMAACTIVE ? DMAACCESSSIZE : cacheselect ? IS_MA ? 2b00 : function3 : 2b10;                                    // DETERMINE MEMORY ACCESS SIZE - DMA 32, 16 or 8, INSTRUCTION (cacheselect == 0) 32
                                                                                                                                // ELSE BY function3 ( IS_MA AS BYTES )
    IS_MA := ~IS_ATOMIC & |function3 & (                                                                                        // ATOMIC OPERATIONS CANNOT BE MISALIGNED
            ( IS_LOAD & ( I20 ^ I1R ) ) |                                                                                       // DETECT MIS-ALIGNED LOADS ( 16, 32, 64 bit with address xx1 )
            ( IS_STORE & ( I7 ^ I1R ) ) );                                                                                      // DETECT MIS-ALIGNED STORES ( 16, 32, 64 bit with address xx1 )
    IS_MEM64 := &function3;                                                                                                     // DETECT 64 BIT MEMORY ACCESSES
}

// ADDRESS GENERATORS
unit loadaddress(
    input   uint32  instruction,
    input   uint1   IS_ATOMIC,
    output  uint$addr_width$  loadAddress,
    input   uint64  I1R
) <reginputs> {
    loadAddress := ( IS_ATOMIC ? 0 : { {52{instruction[31,1]}}, Itype(instruction).immediate } ) + I1R;
}
unit storeaddress(
    input   uint32  instruction,
    input   uint1   IS_ATOMIC,
    output  uint$addr_width$  storeAddress,
    input   uint64  I1R
) <reginputs> {
    storeAddress := ( IS_ATOMIC ? 0 : { {52{instruction[31,1]}}, Stype(instruction).immediate_bits_11_5, Stype(instruction).immediate_bits_4_0 } ) + I1R;
}
unit jumpaddress(
    input   uint32  instruction,
    input   uint1   IS_BRANCH,
    output  uint$addr_width$  jumpAddress,
    input   uint$addr_width$  PC
) <reginputs> {
    jumpAddress := ( IS_BRANCH ?
                    { {51{Btype(instruction).immediate_bits_12}}, Btype(instruction).immediate_bits_11, Btype(instruction).immediate_bits_10_5, Btype(instruction).immediate_bits_4_1, 1b0 } :
                    { {43{Jtype(instruction).immediate_bits_20}}, Jtype(instruction).immediate_bits_19_12, Jtype(instruction).immediate_bits_11, Jtype(instruction).immediate_bits_10_1, 1b0 }
                    ) + PC;
}
unit auipclui(
    input   uint32  instruction,
    output  uint64  AUIPCLUI,
    input   uint$addr_width$  PC
) <reginputs> {
    AUIPCLUI := { {32{instruction[31,1]}}, Utype(instruction).immediate_bits_31_12, 12b0 } + ( instruction[5,1] ? 0 : PC );
}
unit incpc(
    input   uint$addr_width$  PC,
    input   uint1   compressed,
    output  uint$addr_width$  nextPC
) <reginputs> {
    nextPC := PC + ( compressed ? 2 : 4 );
}

// REGISTER READ AND WRITE BLOCKS
unit regR(
    input   uint1   SMT,
    simple_dualport_bram_port0 regfile,
    input   uint5   addr0,
    output  uint64  rdata0
) <reginputs> {
    regfile.addr0 := { SMT, addr0 }; rdata0 := regfile.rdata0;
}
unit regW(
    input   uint1   SMT,
    simple_dualport_bram_port1 regfile,
    input   uint5   addr1,
    input   uint1   wenable1,
    input   uint64  wdata1
) <reginputs> {
    regfile.addr1 := { SMT, addr1 }; regfile.wdata1 := wdata1; regfile.wenable1 := wenable1;
}

// ABSOLUTE VALUES FOR 32 AND 64 BIT REGISTER CONTENTS
unit abs3264(
    input   uint64  sourceReg,
    output  uint32  abs32,
    output  uint64  abs64
) <reginputs> {
    abs32 := sourceReg[31,1] ? -sourceReg[0,32] : sourceReg[0,32];
    abs64 := sourceReg[63,1] ? -sourceReg : sourceReg;
}

// CLASSIFY INSTRUCTION TYPE AND DETIMINE CPU CONTROL FLAGS
unit controlflags(
    input   uint5   opCode,
    input   uint3   function3,
    input   uint7   function7,
    output  uint1   IS_AUIPCLUI,
    output  uint1   IS_JAL,
    output  uint1   IS_BRANCH,
    output  uint1   IS_CSR,
    output  uint1   IS_ATOMIC,
    output  uint1   IS_FPU,
    output  uint1   IS_LOAD,
    output  uint1   IS_STORE,
    output  uint1   IS_FENCE,
    output  uint1   writeRegister,
    output  uint1   writeRegisterF,
    output  uint1   incPC,
    output  uint1   IS_ALU,
    output  uint1   IS_FAST,
    output  uint1   IS_FASTFPU,
    output  uint1   IS_ALU32,
    output  uint1   IS_ALU32SIGNX
) <reginputs> {
    writeRegisterF := 0; writeRegister := 1; incPC := 1; IS_FAST := 1;                                                          // DEFAULT TO SINGLE-CYCLE, WRITE INTEGER REGISTER AND INCREMENT PC
    IS_ALU := 0; IS_ALU32 := 0; IS_ALU32SIGNX := 1;                                                                             // ALU DETECTED FLAGS, DEFAULT TO 32-BIT SIGN EXTENSION
    IS_AUIPCLUI := 0; IS_JAL := 0; IS_BRANCH := 0; IS_CSR := 0; IS_ATOMIC := 0; IS_LOAD := 0; IS_STORE := 0; IS_FENCE := 0;     // NON-ALU/FPU INSTRUCTION DETECTED FLAGS
    IS_FPU := 0; IS_FASTFPU := 0;                                                                                               // FLOATING-POINT UNIT DETECTION FLAGS

    algorithm <autorun> {
        uint1   f7E0000001 <:: ( function7 == 7b0000001 );                                                                      // DETECT MULTIPLICATION / DIVISION EXTENSION
        uint1   f7N0000100 <:: ( function7 != 7b0000100 );
        uint1   f7N0010000 <:: ( function7 != 7b0010000 );

        while(1) {
            switch( opCode ) {                                                                                                  // DETERMINE CPU CONTROL FLAGS BY OPCODE
                case 5b01101: { IS_AUIPCLUI = 1; }                                                                              // LUI
                case 5b00101: { IS_AUIPCLUI = 1; }                                                                              // AUIPC
                case 5b11011: { IS_JAL = 1; incPC = 0; }                                                                        // JAL
                case 5b11001: { IS_JAL = 1; incPC = 0; }                                                                        // JALR
                case 5b11000: { IS_BRANCH = 1; writeRegister = 0; }                                                             // BRANCH
                case 5b00000: { IS_LOAD = 1; }                                                                                  // LOAD
                case 5b00001: { IS_LOAD = 1; writeRegisterF = 1; }                                                              // FLOAT LOAD
                case 5b01000: { IS_STORE = 1; writeRegister = 0; }                                                              // STORE
                case 5b01001: { IS_STORE = 1; writeRegister = 0; }                                                              // FLOAT STORE
                case 5b00011: { IS_FENCE = 1; writeRegister = 0;}                                                               // FENCE[I]
                case 5b11100: { IS_CSR = 1; IS_FAST = 0; }                                                                      // CSR ECALL EBBREAK
                case 5b00100: { IS_ALU = 1; }                                                                                   // REGISTER-IMMEDIATE ALU
                case 5b01100: {                                                                                                 // REGISTER-REGISTER ALU
                    IS_ALU = 1;
                    IS_FAST = ~( f7E0000001 & function3[2,1] );                                                                 // FAST NOT DIVIDE
                }
                case 5b00110: {                                                                                                 // REGISTER-IMMEDIATE ALU 32BIT
                    IS_ALU = 1; IS_ALU32 = 1;
                    if( function3 == 3b001 ) { IS_ALU32SIGNX = ( function7[1,6] != 6b000010 ); }                                // DETECT SLLI.UW
                }
                case 5b01110: {                                                                                                 // REGISTER-REGISTER ALU 32BIT
                    IS_ALU = 1; IS_ALU32 = 1;
                    IS_FAST = ~( f7E0000001 & function3[2,1] );                                                                 // FAST NOT DIVIDE
                    if( ~function3[0,1] ) {
                        switch( function3[1,2] ) {
                            case 2b00: { IS_ALU32SIGNX = f7N0000100; }                                                          // DETECT ADD.UW ( f3 == 000 )
                            default: { IS_ALU32SIGNX = f7N0010000; }                                                            // DETECT SHxADD.UW ( f3 == 010 100 110 )
                        }
                    }
                }
                case 5b01011: { IS_ATOMIC = 1; IS_FAST = 0; }                                                                   // LR.W SC.W ATOMIC LOAD - MODIFY - STORE
                case 5b10100: { IS_FPU = 1; IS_FAST = 0; IS_FASTFPU = function7[4,1] | &function7[5,2]; }                       // NON-FUSED FPU ( FAST NOT ADD SUB MUL DIV SQRT )
                default: { IS_FPU = 1; IS_FAST = 0; }                                                                           // FUSED-FPU
            }
        }
    }
}

// COMPRESSED INSTRUCTION EXPANSION
unit compressed00(
    input   uint14  i16,
    output  uint28  i32                                                                                                         // { 00 xxxxxxxxxxxxxxxxxxxxxxxxxxxx 11 }
) <reginputs> {
    algorithm <autorun> { while(1) {
        switch( CBalu(i16).function3 ) {
            case 3b000: {
                // ADDI4SPN -> addi rd', x2, nzuimm[9:2] { 000, nzuimm[5:4|9:6|2|3] rd' 00 } -> { imm[11:0] rs1 000 rd 0010011 }
                i32 = {
                    CIu94(i16).ib_9_6, CIu94(i16).ib_5_4, CIu94(i16).ib_3, CIu94(i16).ib_2, 2b00,
                    5h2,
                    3b000,
                    2b01, CIu94(i16).rd_alt,
                    5b00100
                };
            }
            case 3b100: {
                // LBU -> lbu rd', uimm[1:0]rs1'  { 100 000 rs1' uimm[0|1] rd'  00 } -> { imm[11:0]     rs1 100 rd       0000011 }
                // LHU -> lhu rd', uimm[1]rs1'    { 100 001 rs1' 0 uimm[1] rd'  00 } -> { imm[11:0]     rs1 101 rd       0000011 }
                // LH  -> lh  rd', uimm[1]rs1'    { 100 001 rs1' 1 uimm[1] rd'  00 } -> { imm[11:0]     rs1 001 rd       0000011 }
                // SB  -> sb  uimm[1:0]rs1', rs2' { 100 010 rs1' uimm[0|1] rs2' 00 } -> { imm[11:5] rs2 rs1 000 imm[4:0] 0100011 }
                // SH  -> sh  uimm[1]rs1', rs2'   { 100 011 rs1' 0 uimm[1] rs2' 00 } -> { imm[11:5] rs2 rs1 001 imm[4:0] 0100011 }
                i32 = CSB(i16).function2[1,1] ?
                    {
                        5b00000,                                                                                                // STORE immediate[11->5]
                        2b01, CSB(i16).rs2_alt,                                                                                 // STORE rs2
                        2b01, CSB(i16).rs1_alt,                                                                                 // STORE rs1
                        2b00, CSB(i16).function2[0,1],                                                                          // STORE function3 ( accesssize )
                        3b000, CSB(i16).uimm1, CSB(i16).function2[0,1] ? 1b0 : CSB(i16).uimm0,                                  // STORE immediatep4->0]
                        5b01000                                                                                                 // STORE opcode
                    } :
                    {
                        8b00000000, CLB(i16).uimm1, CLB(i16).function2[0,1] ? 1b0 : CLB(i16).uimm0,                             // LOAD immediate[11->0]
                        2b01, CLB(i16).rs1_alt,                                                                                 // LOAD rs1
                        ~|CLB(i16).function2 | ( ~|CLB(i16).function2[1,2] & ~CLB(i16).uimm0 ), 1b0, CLB(i16).function2[0,1],   // LOAD function3 ( accesssize )
                        2b01, CLB(i16).rd_alt,                                                                                  // LOAD rd
                        5b00000                                                                                                 // LOAD opcode
                    };
            }
           default: {
                i32 = CS(i16).function3[2,1] ?
                    // FSD -> fsd rs2', offset[7:3](rs1') { 101 uimm[5:3] rs1' uimm[7:6] rs2' 00 } -> { imm[11:5] rs2 rs1 011 imm[4:0] 0100111 }
                    // SW -> sw rs2', offset[6:2](rs1')   { 110 uimm[5:3] rs1' uimm[2][6] rs2' 00 } -> { imm[11:5] rs2 rs1 010 imm[4:0] 0100011 }
                    // SD -> sd rs2', offset[7:3](rs1')   { 111 uimm[5:3] rs1' uimm[7:6] rs2' 00 } -> { imm[11:5] rs2 rs1 011 imm[4:0] 0100011 }
                    {
                        2b00, CS(i16).function3[0,1] ? { CSD(i16).ib_7_6 } : { 1b0, CS(i16).ib_6 }, CS(i16).ib_5,
                        2b01, CS(i16).rs2_alt,
                        2b01, CS(i16).rs1_alt,
                        2b01, CS(i16).function3[0,1],
                        CS(i16).function3[0,1] ? { CSD(i16).ib_4_3, 1b0 } : { CS(i16).ib_4_3, CS(i16).ib_2 }, 2b00,
                        4b0100, ~CS(i16).function3[1,1]
                    } :
                    // FLD -> flw rd', offset[7:3](rs1') { 001 uimm[5:3] rs1' uimm[7:6] rd' 00 } -> { imm[11:0] rs1 011 rd 0000111 }
                    // LW -> lw rd', offset[6:2](rs1')   { 010 uimm[5:3] rs1' uimm[2][6] rd' 00 } -> { imm[11:0] rs1 010 rd 0000011 }
                    // LD -> ld rd', offset[7:3](rs1')   { 011 uimm[5:3] rs1' uimm[7:6] rd' 00 } -> { imm[11:0] rs1 011 rd 0000011 }
                    {
                        2b00, CL(i16).function3[0,1] ? { CLD(i16).ib_7_6, CLD(i16).ib_5_3, 1b0 } : { 1b0, CL(i16).ib_6, CL(i16).ib_5_3, CL(i16).ib_2 }, 2b00,
                        2b01, CL(i16).rs1_alt,
                        2b01, CL(i16).function3[0,1],
                        2b01, CL(i16).rd_alt,
                        4b0000, ~CL(i16).function3[1,1]
                    };
            }
        }
    } }
}
unit compressed01(
    input   uint14  i16,
    output  uint30  i32
) <reginputs> {
    algorithm <autorun> { while(1) {
        if( CBalu(i16).function3[2,1] ) {
            switch( CBalu(i16).function3[0,2] ) {
                case 2b00: {
                    // MISC-ALU
                    switch( CBalu(i16).function2 ) {
                        default: {
                            // 2b00 -> SRLI -> srli rd', rd', shamt[5:0] { 100 nzuimm[5] 00 rs1'/rd' nzuimm[4:0] 01 } -> { 000000 shamt rs1 101 rd 0010011 }
                            // 2b01 -> SRAI -> srai rd', rd', shamt[5:0] { 100 nzuimm[5] 01 rs1'/rd' nzuimm[4:0] 01 } -> { 010000 shamt rs1 101 rd 0010011 }
                            // 2b10 -> ANDI -> andi rd', rd',   imm[5:0] { 100    imm[5] 10 rs1'/rd'    imm[4:0] 01 } -> { imm[11:0] rs1 111 rd 0010011 }
                            i32 = {
                                    CBalu50(i16).function2[1,1] ? {6{CBalu50(i16).ib_5}} : { 1b0, CBalu(i16).function2[0,1], 4b0000 }, CBalu50(i16).ib_5,
                                    CBalu50(i16).ib_4_0,
                                    2b01, CBalu50(i16).rd_alt,
                                    1b1, CBalu(i16).function2[1,1], 1b1,
                                    2b01, CBalu50(i16).rd_alt,
                                    5b00100
                            };
                        }
                        case 2b11: {
                            switch( CBalu(i16).ib_5 ) {
                                case 1b0: {
                                    // 2b00 -> SUB -> sub rd', rd', rs2'      { 100 0 11 rs1'/rd' 00 rs2' 01 } -> { 0100000 rs2   rs1 000 rd 0110011 }
                                    // 2b01 -> XOR -> xor rd', rd', rs2'      { 100 0 11 rs1'/rd' 01 rs2' 01 } -> { 0000000 rs2   rs1 100 rd 0110011 }
                                    // 2b10 -> OR  -> or  rd', rd', rd2'      { 100 0 11 rs1'/rd' 10 rs2' 01 } -> { 0000000 rs2   rs1 110 rd 0110011 }
                                    // 2b11 -> AND -> and rd', rd', rs2'      { 100 0 11 rs1'/rd' 11 rs2' 01 } -> { 0000000 rs2   rs1 111 rd 0110011 }
                                    i32 = {
                                            1b0, ~|CBalu(i16).logical2, 5b00000,
                                            2b01, CBalu(i16).rs2_alt,
                                            2b01, CBalu(i16).rd_alt,
                                            ^CBalu(i16).logical2 ? { 1b1, CBalu(i16).logical2[1,1], 1b0 } : {3{CBalu(i16).logical2[0,1]}},
                                            2b01, CBalu(i16).rd_alt,
                                            5b01100
                                    };
                                }
                                case 1b1: {
                                    switch( CBalu(i16).logical2 ) {
                                        // 2b11 -> ZEXT.B -> andi rd',rs1',0xff   { 100 1 11 rd1'/rd' 11 000 01 } -> { 0000111 11111 rs1 111 rd 0010011 }
                                        // 2b11 -> SEXT.B -> sext.b rd',rs1'      { 100 1 11 rd1'/rd' 11 001 01 } -> { 0110000 00100 rs1 001 rd 0010011 }
                                        // 2b11 -> ZEXT.H -> zext.h rd',rs1'      { 100 1 11 rd1'/rd' 11 010 01 } -> { 0000100 00000 rs1 100 rd 0111011 }
                                        // 2b11 -> SEXT.H -> sext.h rd',rs1'      { 100 1 11 rd1'/rd' 11 011 01 } -> { 0110000 00101 rs1 001 rd 0010011 }
                                        // 2b11 -> ZEXT.W -> add.uw rd',rs1',zero { 100 1 11 rd1'/rd' 11 100 01 } -> { 0000100 rs2   rs1 000 rd 0111011 }
                                        // 2b11 -> NOT ->    xor rd',rs1',-1      { 100 1 11 rd1'/rd' 11 101 01 } -> { 1111111 11111 rs1 100 rd 0010011 }
                                        case 2b11: {
                                            i32 = {
                                                ( CBalu(i16).rs2_alt == 3b000 ) ? 12b000011111111 :
                                                                        ( CBalu(i16).rs2_alt == 3b001 ) ? 12b011000000100 :
                                                                        ( CBalu(i16).rs2_alt == 3b010 ) ? 12b000010000000 :
                                                                        ( CBalu(i16).rs2_alt == 3b011 ) ? 12b011000000101 :
                                                                        ( CBalu(i16).rs2_alt == 3b100 ) ? 12b000010000000 :
                                                                                                          12b111111111111,
                                                2b01, CBalu(i16).rd_alt,
                                                ( CBalu(i16).rs2_alt == 3b000 ) ? 3b111 :
                                                                        ( CBalu(i16).rs2_alt == 3b001 ) ? 3b001 :
                                                                        ( CBalu(i16).rs2_alt == 3b010 ) ? 3b100 :
                                                                        ( CBalu(i16).rs2_alt == 3b011 ) ? 3b001 :
                                                                        ( CBalu(i16).rs2_alt == 3b100 ) ? 3b000 :
                                                                                                          3b100,
                                                2b01, CBalu(i16).rd_alt,
                                                ( ( CBalu(i16).rs2_alt == 3b010 ) | ( CBalu(i16).rs2_alt == 3b100 ) ) ? 5b01110 : 5b00100
                                            };
                                        }
                                        default: {
                                            // 2b11 -> SUBW -> subw rd', rd', rs2' { 100 1 11 rs1'/rd' 00 rs2' 01 } -> { 0100000 rs2 rs1 000 rd 0111011 }
                                            // 2b11 -> ADDW -> addw rd', rd', rs2' { 100 1 11 rs1'/rd' 01 rs2' 01 } -> { 0000000 rs2 rs1 000 rd 0111011 }
                                            // 2b11 -> MUL -> mul rd', rd', rs2'   { 100 1 11 rs1'/rd' 10 rs2' 01 } -> { 0000001 rs2 rs1 000 rd 0110011 }
                                            i32 = {
                                                1b0, ~|CBalu(i16).logical2, 4b0000, CBalu(i16).logical2[1,1],
                                                2b01, CBalu(i16).rs2_alt,
                                                2b01, CBalu(i16).rd_alt,
                                                3b000,
                                                2b01, CBalu(i16).rd_alt,
                                                3b011, ~CBalu(i16).logical2[1,1], 1b0
                                            };
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                case 2b01: {
                    // 3b101 -> J -> jal, x0, offset[11:1] { 101, imm[11|4|9:8|10|6|7|3:1|5] 01 } -> { imm[20|10:1|11|19:12] rd 1101111 }
                    i32 = {
                        CJ(i16).ib_11, CJ(i16).ib_10, CJ(i16).ib_9_8, CJ(i16).ib_7, CJ(i16).ib_6, CJ(i16).ib_5, CJ(i16).ib_4, CJ(i16).ib_3_1, {9{CJ(i16).ib_11}},
                        5h0,
                        5b11011
                    };
                }
                default: {
                    // 3b110 -> BEQZ -> beq rs1', x0, offset[8:1] { 110, imm[8|4:3] rs1' imm[7:6|2:1|5] 01 } -> { imm[12|10:5] rs2 rs1 000 imm[4:1|11] 1100011 }
                    // 3b111 -> BNEZ -> bne rs1', x0, offset[8:1] { 111, imm[8|4:3] rs1' imm[7:6|2:1|5] 01 } -> { imm[12|10:5] rs2 rs1 001 imm[4:1|11] 1100011 }
                    i32 = {
                        {4{CB(i16).offset_8}}, CB(i16).offset_7_6, CB(i16).offset_5,
                        5h0,
                        2b01, CB(i16).rs1_alt,
                        2b00, CB(i16).function3[0,1],
                        CB(i16).offset_4_3, CB(i16).offset_2_1, CB(i16).offset_8,
                        5b11000
                    };
                }
            }
        } else {
            switch( CI50(i16).function3[0,2] ) {
                default: {
                    // 3b000 -> ADDI -> addi rd, rd, nzimm[5:0] { 000 nzimm[5] rs1/rd!=0 nzimm[4:0] 01 } -> { imm[11:0] rs1 000 rd 0010011 }
                    //          NOP if rd == 0 and nzimm == 5b000000
                    // 3b001 -> ADDIW -> addiw rd,rd,imm[5:0]   { 001   imm[5]     rd      imm[4:0] 01 } -> { imm[11:0] rd 000 rd 0011011 }
                    // 3b010 -> LI -> addi rd, x0, imm[5:0]     { 010   imm[5]     rd!=0    mm[4:0] 01 } -> { imm[11:0] rs1 000 rd 0010011 }
                    i32 = {
                            {7{CI50(i16).ib_5}}, CI50(i16).ib_4_0,
                            CI50(i16).function3[1,1] ? 5h0 : CI50(i16).rd,
                            3b000, CI50(i16).rd,
                            3b001, CI50(i16).function3[0,1], 1b0
                    };
                }
                case 2b11: {
                    if( CI(i16).rd == 2 ) {
                        // 3b111 -> ADDI16SP -> addi x2, x2, nzimm[9:4] { 011 nzimm[9] 00010 nzimm[4|6|8:7|5] 01 } -> { imm[11:0] rs1 000 rd 0010011 }
                        i32 = {
                            {3{CI94(i16).ib_9}}, CI94(i16).ib_8_7, CI94(i16).ib_6, CI94(i16).ib_5, CI94(i16).ib_4, 4b0000,
                            5h2,
                            3b000,
                            5h2,
                            5b00100
                        };
                    } else {
                        // 3b111 -> LUI -> lui rd, nzuimm[17:12] { 011 nzimm[17] rd!={0,2} nzimm[16:12] 01 } -> { imm[31:12] rd 0110111 }
                        i32 = {
                            {15{CIlui(i16).ib_17}}, CIlui(i16).ib_16_12,
                            CIlui(i16).rd,
                            5b01101
                        };
                    }
                }
            }
        }
    } }
}
unit compressed10(
    input   uint14  i16,
    output  uint27  i32                                                                                                         // { 000 xxxxxxxxxxxxxxxxxxxxxxxxxxx 11 }
) <reginputs> {
    algorithm <autorun> { while(1) {
        switch( CBalu(i16).function3 ) {
            case 3b000: {
                // SLLI -> slli rd, rd, shamt[5:0] { 000, nzuimm[5], rs1/rd!=0 nzuimm[4:0] 10 } -> { 000000 shamt rs1 001 rd 0010011 }
                i32 = {
                    3b000,
                    CI50(i16).ib_5, CI50(i16).ib_4_0,
                    CI50(i16).rd,
                    3b001,
                    CI50(i16).rd,
                    5b00100
                };
            }
            case 3b100: {
                // J[AL]R / MV / ADD
                if( ~|CR(i16).rs2 ) {
                    // JR   -> jalr x0, rs1, 0 { 100 0 rs1 00000 10 } -> { imm[11:0] rs1 000 rd 1100111 }
                    // JALR -> jalr x1, rs1, 0 { 100 1 rs1 00000 10 } -> { imm[11:0] rs1 000 rd 1100111 }
                    i32 = {
                        9b000000000,
                        CR(i16).rs1,
                        3b000,
                        4b0000, CR(i16).function4[0,1],
                        5b11001
                    };
                } else {
                    // MV  -> add rd, x0, rs2 { 100 0 rd!=0 rs2!=0 10 }     -> { 0000000 rs2 rs1 000 rd 0110011 }
                    // ADD -> add rd, rd, rs2 { 100 1 rs1/rd!=0 rs2!=0 10 } -> { 0000000 rs2 rs1 000 rd 0110011 }
                    i32 = {
                        4b0000,
                        CR(i16).rs2,
                        CR(i16).function4[0,1] ? CR(i16).rs1 : 5h0,
                        3b000,
                        CR(i16).rs1,
                        5b01100
                    };
                }
            }
            default: {
                i32 = CSS(i16).function3[2,1] ?
                    // FSDSP -> fsd rs2, offset[8:3](x2) { 101 uimm[5:3][8:6] rs2 10 } -> { imm[11:5] rs2 rs1 011 imm[4:0] 0100111 }
                    // SWSP -> sw rs2, offset[7:2](x2)   { 110 uimm[5][4:2][7:6] rs2 10 } -> { imm[11:5] rs2 rs1 010 imm[4:0] 0100011 }
                    // SDSP -> sd rs2, offset[8:3](x2)   { 111 uimm[5:3][8:6] rs2 10 } -> { imm[11:5] rs2 rs1 011 imm[4:0] 0100111 }
                    {
                        CSS(i16).function3[0,1] ? { CSSD(i16).ib_8_6, CSSD(i16).ib_5 } : { 1b0, CSS(i16).ib_7_6, CSS(i16).ib_5 },
                        CSS(i16).rs2,
                        5h2,
                        2b01, CSS(i16).function3[0,1],
                        CSS(i16).function3[0,1] ? { CSSD(i16).ib_4_3, 1b0 } : { CSS(i16).ib_4_2 }, 2b00,
                        4b0100, ~CSS(i16).function3[1,1]
                    } :
                    // FLDSP -> fld rd, offset[8:3](x2) { 001 uimm[5] rd uimm[4:3|8:6] 10 } -> { imm[11:0] rs1 011 rd 0000111 }
                    // LWSP -> lw rd, offset[7:2](x2) { 010 uimm[5] rd uimm[4:2|7:6] 10 } -> { imm[11:0] rs1 010 rd 0000011 }
                    // LDSP -> ld rd, offset[8:3](x2)   { 011 uimm[5] rd uimm[4:3|8:6] 10 } -> { imm[11:0] rs1 011 rd 0000011 }
                    {
                        CLS(i16).function3[0,1] ? { CLSD(i16).ib_8_6, CLSD(i16).ib_5, CLSD(i16).ib_4_3, 1b0 } : { 1b0, CLS(i16).ib_7_6, CLS(i16).ib_5, CLS(i16).ib_4_2 }, 2b00,
                        5h2,
                        2b01, CSS(i16).function3[0,1] ,
                        CI(i16).rd,
                        4b0000, ~CSS(i16).function3[1,1]
                    };
            }
        }
    } }
}

// RISC-V MANDATORY CSR REGISTERS
unit csrf(
    output  uint8   CSRf(0),
    input   uint2   csr,
    input   uint8   writevalue,
    input   uint2   writetype,
    input   uint1   update,
    input   uint5   newflags
) <reginputs> {
    algorithm <autorun> { while(1) {
        if( update ) {
            CSRf = { CSRf[5,3], newflags };
        } else {
            switch( csr ) {
                case 0: {}
                case 1: {
                    // CSRRW / CSRRWI
                    switch( writetype ) {
                        case 1: { CSRf[0,5] = writevalue[0,5]; }
                        case 2: { CSRf[5,3] = writevalue[0,3]; }
                        case 3: { CSRf = writevalue[0,8]; }
                        default: {}
                    }
                }
                case 2: {
                    // CSRRS / CSRRSI
                    switch( writetype ) {
                        case 1: { CSRf[0,5] = CSRf[0,5] | writevalue[0,5]; }
                        case 2: { CSRf[5,3] = CSRf[5,3] | writevalue[0,3]; }
                        case 3: { CSRf = CSRf | writevalue[0,8]; }
                        default: {}
                    }
                }
                case 3: {
                    // CSRRC / CSRRCI
                    switch( writetype ) {
                        case 1: { CSRf[0,5] = CSRf[0,5] & ~writevalue[0,5]; }
                        case 2: { CSRf[5,3] = CSRf[5,3] & ~writevalue[0,3]; }
                        case 3: { CSRf = CSRf & ~writevalue[0,8]; }
                        default: {}
                    }
                }
            }
        }
    } }
}
unit csr_timer(
    output  uint$CWIDTH$  counter(0)
) <reginputs> {
    counter := counter + 1;
}
unit csr_smt_counter(
    input   uint1   SMT,
    input   uint1   trigger,
    output  uint$CWIDTH$  counter0(0),
    output  uint$CWIDTH$  counter1(0)
) <reginputs> {
    algorithm <autorun> {
        uint$CWIDTH$  counter0_p1 <:: counter0 + 1;
        uint$CWIDTH$  counter1_p1 <:: counter1 + 1;

        while(1) {
            if( trigger ) {
                counter0 = SMT ? counter0 : counter0_p1;
                counter1 = SMT ? counter1_p1 : counter1;
            }
        }
    }
}

unit CSRblock(
    input   uint1   start,
    input   uint1   SMT,
    input   uint12  csrRegister,
    input   uint3   function3,
    input   uint5   rs1,
    input   uint8   sourceReg1,
    input   uint1   incCSRinstret,
    input   uint1   updateFPUflags,
    input   uint5   FPUnewflags,
    output  uint8   FPUflags,
    output  uint64  result,
//    output  uint64  mcause,                                                                                                     // 342 MACHINE EXCEPTION CAUSE
//    output  uint64  mstatus,                                                                                                    // 300 MACHINE STATUS BIT 3 IS MIE, 7 IS MPIE
//    output  uint64  mepc,                                                                                                       // 341 MACHINE EXECPTION PROGRAM COUNTER
//    output  uint64  mtvec                                                                                                       // 305 MACHINE TRAP VECTOR BASE ADDRESS
) <reginputs> {
    csr_timer TIMER();                                                                                                          // TIMER
    csr_smt_counter CYCLE( SMT <: SMT );                                                                                        // CYCLES PER THREAD
    csr_smt_counter INSTRET( SMT <: SMT, trigger <: incCSRinstret );                                                            // INSTRUCTIONS RETIRED

    uint32  writevalue <:: function3[2,1] ? rs1 : sourceReg1;                                                                   // SWITCH BETWEEN IMMEDIATE OR REGISTER VALUE TO WRITE TO CSR
    csrf CSRF0( csr <: csrRegister[0,2], writevalue <: writevalue, newflags <: FPUnewflags );                                   // MAIN CSRf ( csrRegister[0,2] )
    csrf CSRF1( csr <: csrRegister[0,2], writevalue <: writevalue, newflags <: FPUnewflags );                                   // SMT CSRf  ( csrRegister[0,2] )

    CSRF0.writetype := 0; CSRF1.writetype := 0; CSRF0.update := updateFPUflags & ~SMT;  CSRF1.update := updateFPUflags & SMT;   // UPDATE FLAGS FPU-FLAGS
    CYCLE.trigger := 1;                                                                                                         //UPDATE FLAGS FOR COUNTERS AND TIMERS

    FPUflags := SMT ? CSRF1.CSRf : CSRF0.CSRf;                                                                                  // PASS FPU FLAGS PER THREAD BACK TO FPU

    algorithm <autorun> { while(1) {
        if( start & ~|csrRegister[4,8] ) {
            switch( function3[0,2] ) {
                case 2b00: {}                                                                                                   // ECALL / EBBREAK
                case 2b01: {
                    switch( { ~|rs1, function3[2,1] } ) {                                                                       // CSRRW / CSRRWI
                        case 2b10: {}
                        default: { if( SMT ) { CSRF1.writetype = 1; } else { CSRF0.writetype = 1; } }
                    }
                }
                default: {
                    if( |rs1 ) { if( SMT ) { CSRF1.writetype = function3[0,2]; } else { CSRF0.writetype = function3[0,2]; } }
                }
            }
        }

        result = 0;
        switch( csrRegister[8,4] ) {
            case 4h0: {
                switch( csrRegister[0,2] ) {
                    case 2h1: { result = SMT ? CSRF1.CSRf[0,5] : CSRF0.CSRf[0,5];  }                                            // frflags
                    case 2h2: { result = SMT ? CSRF1.CSRf[5,3] : CSRF0.CSRf[5,3]; }                                             // frrm
                    case 2h3: { result = SMT ? CSRF1.CSRf : CSRF0.CSRf; }                                                       // frcsr
                    default: {}
                }
            }
            case 4h3: { result = $CPUISA$; }
            case 4hc: {
                switch( { csrRegister[7,1], csrRegister[0,2] } ) {
                    case 3h0: { result = SMT ? CYCLE.counter1 : CYCLE.counter0; }
                    case 3h1: { result = TIMER.counter; }
                    case 3h2: { result = SMT ? INSTRET.counter1 : INSTRET.counter0; }
                    default: {}
                }
                }
            case 4hf: { result = SMT; }                                                                                         // HART ID
            default: {}
        }
    } }
}
