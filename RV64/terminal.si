unit terminal(
    input   uint1   clockCG,

    dualport_bram_port0 terminal,

    input   uint10  pix_x,
    input   uint10  pix_x1,
    input   uint9   pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint1   pixel,
    output! uint1   terminal_display,

    input   uint1   blink,
    input   uint1   showterminal,
    input   uint7   terminal_x
) <reginputs> {
    characterrom256 CGROM <@clockCG> ( tile <: terminal.rdata0, y <: pix_y[0,3] );                                              // Character ROM 8x8

    uint6   yterminalpos <:: ( pix_vblank ? 0 : pix_y - 416 );                                                                  // Character position on the terminal x 0-79, y 0-7 * 80
    uint1   terminalpixel <:: CGROM.line[ ~pix_x[0,3], 1 ];                                                                     // Derive the actual pixel in the current terminal

    terminal.addr0 := pix_x1[3,7] + yterminalpos[3,3] * 80;                                                                      // Setup the reading of the terminal memory

    always_after {
        uint1 is_cursor = blink & ( ( pix_x >> 3 ) == terminal_x ) & ( &yterminalpos[3,3] );                                    // Determine if cursor, and if cursor is flashing

        terminal_display = pix_active & showterminal & ( pix_y > 415 );                                                         // In terminal window range and displayed?
        pixel = terminalpixel ^ is_cursor;                                                                                      // Pixel or cursor?
    }
}

unit terminalcursor(
    input   uint7   terminal_x,
    output  uint1   endofline,
    output  uint7   NEXT,
    output  uint7   PREV,
    output  uint10  ADDRESS
) <reginputs> {
    always_after {
        endofline = ( terminal_x == 79 );
        NEXT = endofline ? 0 : terminal_x + 1;
        PREV = terminal_x - 1;
        ADDRESS = terminal_x + 560;
    }
}

unit terminal_writer(
    dualport_bram_port1 terminal,

    input   uint8   terminal_character,
    input   uint2   terminal_write,
    output  uint2   terminal_active(0),
    output  uint7   terminal_x(0),
) <reginputs> {
    terminalcursor TC( terminal_x <: terminal_x );

    // Terminal active (scroll) flag and temporary storage for scrolling
    uint10  terminal_scroll = uninitialised;
    uint10  terminal_scroll_next <:: terminal_scroll + 1;
    uint10  terminal_scroll_next_line <:: terminal_scroll + 80;

    // Setup the writing to the terminal memory
    terminal.wenable1 := 0;

    algorithm <autorun> {
        uint1   scrolling <:: ( terminal_scroll < 560 );
        uint1   working <:: ( terminal_scroll != 640 );

        while(1) {
            if( |terminal_active ) {
                while( working ) {
                    terminal.addr1 = terminal_scroll_next_line;                                                                                                  // READ NEXT LINE
                    ++:
                    terminal.addr1 = terminal_scroll;
                    terminal.wdata1 = terminal_active[1,1] ? 0 : scrolling ? terminal.rdata1 : 0;                                                               // COPY CHARACTER IF SCROLLING, BLANK IF LAST LINE/WIPE
                    terminal.wenable1 = 1; terminal_scroll = terminal_scroll_next;
                }
                if( terminal_active[1,1] ) { terminal_x = 0; }
                terminal_active = 0;
            } else {
                terminal_scroll = 0;
            }
        }
    }

    always_after {
        if( |terminal_write ) {
            onehot( terminal_write ) {                                                                                                                          // WRITE CHARACTER
                case 0: {
                    switch( terminal_character ) {
                        case 8: {                                                                                                                               // BACKSPACE, move back one character
                            if( |terminal_x ) {
                                terminal_x = TC.PREV;
                                terminal.addr1 = TC.ADDRESS; terminal.wdata1 = 0; terminal.wenable1 = 1;
                            }
                        }
                        case 10: { terminal_active = 1; }                                                                                                       // LINE FEED, force scroll
                        case 13: { terminal_x = 0; }                                                                                                            // CARRIAGE RETURN, return to left
                        default: {                                                                                                                              // Display character
                            terminal.addr1 = TC.ADDRESS; terminal.wdata1 = terminal_character; terminal.wenable1 = 1;
                            terminal_active = TC.endofline;
                            terminal_x = TC.NEXT;
                        }
                    }
                }
                case 1: { terminal_active = 2; }                                                                                                                // RESET
            }
        }
    }

}
