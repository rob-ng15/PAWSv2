// HART ID 0 L0 CACHE
unit il00cache_read(
$$for i=0,(L00Iblocks-1) do
    simple_dualport_bram_port0 L0cache_$i$,
$$end
    simple_dualport_bram_port0 L0tags,
    input   uint$addr_width$  address,
    input   uint1   invalidate,
    input   uint1   CLS,
    output  uint30  instruction,
    output  uint1   compressed,
    output  uint1   tagmatch
) <reginputs> {
    uint32 cacheline = uninitialised;

    $$for i=0,(L00Iblocks-1) do
        L0cache_$i$.addr0 := address[$1+L00Icount$,$L0Icacheaddrwidth$];                                                        // FOR EACH CACHE BLOCK, SET ADDRESS FROM CPU ADDRESS
    $$end
    L0tags.addr0 := address[1,$L00Itagscount$];

    tagmatch := ~( invalidate | CLS ) & ( L0tags.rdata0 == address[$L00Ipartaddressstart$,$L00Ipartaddresswidth$] ) & L00cacheI( cacheline).valid;
    instruction := L00cacheI( cacheline ).instruction;
    compressed := L00cacheI( cacheline ).compressed;

    always_after {
        switch( address[1,$L00Icount$] ) {
            $$for i=0,(L00Iblocks-1) do
                case $i$: { cacheline = L0cache_$i$.rdata0; }                                                                   // EXTRACT CACHELINE IF CPU ADDRESS MATCHES CACHE BLOCK
            $$end
        }
    }
}

unit il00cache_write(
$$for i=0,(L00Iblocks-1) do
    simple_dualport_bram_port1 L0cache_$i$,
$$end
    simple_dualport_bram_port1 L0tags,
    input   uint$addr_width$  address,
    input   uint30  newinstruction,
    input   uint1   newcompressed,
    input   uint1   update,
    input   uint1   invalidate,
    output  uint1   CLS
) <reginputs> {
    uint$L0Icacheaddrwidth+1$ count = 0;
    uint$L0Icacheaddrwidth+1$ countNEXT <:: count + 1;

    $$for i=0,(L00Iblocks-1) do
        L0cache_$i$.wenable1 := 1;
    $$end
    L0tags.wenable1 := 1;

    CLS := invalidate | ( count != $L0Isize$ );

    algorithm <autorun> {
        while(1) {
            if( update & ~CLS ) {
                switch( address[1,$L00Icount$] ) {
                    $$for i=0,(L00Iblocks-1) do
                        case $i$: {
                            L0cache_$i$.addr1 = address[$1+L00Icount$,$L0Icacheaddrwidth$];
                            L0cache_$i$.wdata1 = { newinstruction, newcompressed, 1b1 };
                        }
                    $$end
                }
                L0tags.addr1 = address[1,$L00Itagscount$]; L0tags.wdata1 = address[$L00Ipartaddressstart$,$L00Ipartaddresswidth$];
            }
        }
    }

    always_after {
        if( CLS ) {
            if( invalidate ) {
                count = 0;
            } else {
                $$for i=0,(L00Iblocks-1) do
                    L0cache_$i$.addr1 = count; L0cache_$i$.wdata1 = 0;
                $$end
                count = countNEXT;
            }
        }
    }
}

// HART ID 1 L0 CACHE
unit il01cache_read(
$$for i=0,(L01Iblocks-1) do
    simple_dualport_bram_port0 L0cache_$i$,
$$end
    simple_dualport_bram_port0 L0tags,
    input   uint$addr_width$  address,
    input   uint1   invalidate,
    input   uint1   CLS,
    output  uint30  instruction,
    output  uint1   compressed,
    output  uint1   tagmatch
) <reginputs> {
    uint32 cacheline = uninitialised;

    $$for i=0,(L01Iblocks-1) do
        L0cache_$i$.addr0 := address[$1+L01Icount$,$L0Icacheaddrwidth$];                                                        // FOR EACH CACHE BLOCK, SET ADDRESS FROM CPU ADDRESS
    $$end
    L0tags.addr0 := address[1,$L01Itagscount$];

    tagmatch := ~( invalidate | CLS ) & ( L0tags.rdata0 == address[$L01Ipartaddressstart$,$L01Ipartaddresswidth$] ) & L01cacheI( cacheline).valid;
    instruction := L01cacheI( cacheline ).instruction;
    compressed := L01cacheI( cacheline ).compressed;

    always_after {
        switch( address[1,$L01Icount$] ) {
            $$for i=0,(L01Iblocks-1) do
                case $i$: { cacheline = L0cache_$i$.rdata0; }                                                                   // EXTRACT CACHELINE IF CPU ADDRESS MATCHES CACHE BLOCK
            $$end
        }
    }
}

unit il01cache_write(
$$for i=0,(L01Iblocks-1) do
    simple_dualport_bram_port1 L0cache_$i$,
$$end
    simple_dualport_bram_port1 L0tags,
    input   uint$addr_width$  address,
    input   uint30  newinstruction,
    input   uint1   newcompressed,
    input   uint1   update,
    input   uint1   invalidate,
    output  uint1   CLS
) <reginputs> {
    uint$L0Icacheaddrwidth+1$ count = 0;
    uint$L0Icacheaddrwidth+1$ countNEXT <:: count + 1;

    $$for i=0,(L01Iblocks-1) do
        L0cache_$i$.wenable1 := 1;
    $$end
    L0tags.wenable1 := 1;

    CLS := invalidate | ( count != $L0Isize$ );

    algorithm <autorun> {
        while(1) {
            if( update & ~CLS ) {
                switch( address[1,$L01Icount$] ) {
                    $$for i=0,(L01Iblocks-1) do
                        case $i$: {
                            L0cache_$i$.addr1 = address[$1+L01Icount$,$L0Icacheaddrwidth$];
                            L0cache_$i$.wdata1 = { newinstruction, newcompressed, 1b1 };
                        }
                    $$end
                }
                L0tags.addr1 = address[1,$L01Itagscount$]; L0tags.wdata1 = address[$L01Ipartaddressstart$,$L01Ipartaddresswidth$];
            }
        }
    }

    always_after {
        if( CLS ) {
            if( invalidate ) {
                count = 0;
            } else {
                $$for i=0,(L01Iblocks-1) do
                    L0cache_$i$.addr1 = count; L0cache_$i$.wdata1 = 0;
                $$end
                count = countNEXT;
            }
        }
    }
}

// 32Mb of SDRAM using @sylefeb controller
// Controlled by a 16bit EVICTION CACHE FOR DATA
// Cache-coherency is maintained
// Controller is 16bit, the natural width of the SDRAM on the ULX3s
// An eviction cache was chosen as easy to implement as a directly mapped cache
// Writes to SDRAM only if required when evicting a cache entry

// 16 bit to 32 bit controller
// CPU has a 32 bit memory bus, with 16 bit aligned read/writes
// SDRAM is 16 bit
// Interface the 32 bit CPU memory bus to the 16 bit SDRAM memory bus
unit cachecontroller(
    sdram_user      sio,
    input   uint1   clock_cache,
    input   uint1   cacheselect,
    input   uint$sdram_addr_width$  address,
    input   uint2   accesssize,
    input   uint1   writeflag,
    input   uint32  writedata,
    input   uint1   readflag,
    output  uint32  readdata,
    output  uint1   busy(0)
) <reginputs> {
    uint32  cachewritevalue = uninitialized;                                                                                    // VALUE TO WRITE THROUGH TO THE CACHE
    simple_dualport_bram uint16 Dcache0 <@clock_cache,@clock> [$L1size$] = uninitialized;                                       // COMBINED DATA&INSTRUCTION CACHE
    simple_dualport_bram uint$L1partaddresswidth+2$ Dtags0 <@clock_cache,@clock> [$L1size$] = uninitialized;
    simple_dualport_bram uint16 Dcache1 <@clock_cache,@clock> [$L1size$] = uninitialized;
    simple_dualport_bram uint$L1partaddresswidth+2$ Dtags1 <@clock_cache,@clock> [$L1size$] = uninitialized;
    cache_read DCACHE <@clock_cache> ( cache0 <:> Dcache0, tags0 <:> Dtags0, cache1 <:> Dcache1, tags1 <:> Dtags1, address <: address );
    cache_write DCACHEW( cache0 <:> Dcache0, tags0 <:> Dtags0, cache1 <:> Dcache1, tags1 <:> Dtags1, needwritetosdram <: dowrite, address <: address, writedata <: cachewritevalue );

    uint32  sdramreaddata = uninitialized;          sdramcontroller SDRAM( sio <:> sio );                                       // SDRAM CONTROLLER
    uint1   dowrite = uninitialized;                                                                                            // MEMORY WRITE OPERATION FLAG

    SDRAM.readflag := 0; SDRAM.writeflag := 0; DCACHEW.update := 0;                                                             // SDRAM ACCESS AND CACHE UPDATE FLAGS

    algorithm <autorun> {
        uint1   doread = uninitialized;                                                                                         // MEMORY READ OPERATION FLAG
        uint$sdram_addr_width$ address2 <:: address + 2;                                                                        // ADDRESS FOR FOLLOWING MEMORY ADDRESS
        uint2   accessmask <:: { accesssize[1,1], 1b1 };                                                                        // ACCESSMASK WHICH PARTS OF THE 2 x 16 BIT CACHE PARTS ARE USED
        uint1   Dmatch <:: ( accesssize[1,1] ? &DCACHE.tagmatch : DCACHE.tagmatch[0,1] );                                       // CACHE MATCH FLAGS ( 32 bit both, 16/8 bit lower )
        uint2   Devict <:: accessmask & DCACHE.needswrite & ~DCACHE.tagmatch;                                                   // CACHE EVICTION FLAG ( HIGH, LOW )
        uint2   Dread <:: accessmask & ~DCACHE.tagmatch;                                                                        // CACHE READ REQUIRED FLAG ( HIGH, LOW )
        uint1   doreadsdram <:: ( doread | ( dowrite & ~|accesssize ) );                                                        // SDRAM READ FLAG FOR CACHE MISS, READ OR 8 BIT WRITE

        while(1) {
            doread = readflag; dowrite = writeflag;                                                                             // LATCH READ/WRITE FLAGS
            if( doread | dowrite ) {
                if( Dmatch ) {                                                                                                  // CACHE HIT
                    if( dowrite ) {
                        ++:
                        DCACHEW.update = accessmask;                                                                            // UPDATE CACHE IF WRITE
                    }
                } else {                                                                                                        // CACHE MISS
                    busy = 1; if( SDRAM.busy ) { while( SDRAM.busy ) {} }                                                       // WAIT FOR SDRAM IF BUSY
                    if( |Devict ) {                                                                                             // EVICT AS PARTS OF CACHE LINE NEEDED AND OCCUPIED
                        SDRAM.address = Devict[0,1] ? DCACHE.cacheaddressL : DCACHE.cacheaddressH;                              //      EVICT FIRST ( possibly only ) 16 BITS
                        SDRAM.writedata = DCACHE.rdata[ Devict[0,1] ? 0 : 16, 16 ]; SDRAM.writeflag = 1;
                        if( &Devict ) {
                            while( ~sio.done ) {} SDRAM.address = DCACHE.cacheaddressH;                                         //      EVICT SECOND 16 BITS
                            SDRAM.writedata = DCACHE.rdata[16,16]; SDRAM.writeflag = 1;
                        }
                        if( doreadsdram & |Dread ) { while( ~sio.done ) {} }                                                    // ONLY WAIT IF READ IS TO FOLLOW
                    }
                    if( doreadsdram & |Dread) {                                                                                 // READ FROM SDRAM FOR READ / 8 BIT WRITE
                        SDRAM.address = Dread[0,1] ? address : address2; SDRAM.readflag = 1; while( ~sio.done ) {}              //      READ FIRST ( possibly only ) 16 BITS
                        if( &Dread ) {
                            sdramreaddata[0,16] = SDRAM.readdata;                                                               //      LATCH LOWER 16 BITS FOR ALL 32 BIT READ
                            SDRAM.address = address2; SDRAM.readflag = 1;                                                       //      READ UPPER 16 BITS
                            while( ~sio.done ) {} sdramreaddata[16,16] = SDRAM.readdata;                                        //      LATCH UPPER 16 BITS
                        } else {
                            sdramreaddata = Dread[0,1] ? { 16b0, SDRAM.readdata } : { SDRAM.readdata, 16b0 };                   //      LTACH LOWER OR UPPER 16 BITS FOR ONLY 16 BIT READ
                        }
                    }
                    DCACHEW.update = doreadsdram ? Dread : accessmask;                                                          // UPDATE CACHE READ AND 8 BIT WRITE : 32/16 WRITE
                    busy = 0;
                }
            }
        }
    }

    always_after {                                                                                                              // SET THE CACHE WRITE THROUGH VALUE ABD READDATA VALUE
        switch( accesssize ) {                                                                                                  // FROM CACHE OR SDRAM AS APPLICABLE
            case 2b00: {
                readdata = DCACHE.tagmatch[0,1] ? DCACHE.rdata[0,16] : sdramreaddata[0,16];
                cachewritevalue = dowrite ? address[0,1] ? { writedata[0,8], DCACHE.tagmatch[0,1] ? DCACHE.rdata[0,8] : sdramreaddata[0,8] } :
                                                           { DCACHE.tagmatch[0,1] ? DCACHE.rdata[8,8] : sdramreaddata[8,8], writedata[0,8] } : readdata;
            }
            case 2b01: {
                readdata = DCACHE.tagmatch[0,1] ? DCACHE.rdata[0,16] : sdramreaddata[0,16];
                cachewritevalue = dowrite ? writedata[0,16] : readdata;
            }
            default: {
                readdata = { DCACHE.tagmatch[1,1] ? DCACHE.rdata[16,16] : sdramreaddata[16,16], DCACHE.tagmatch[0,1] ? DCACHE.rdata[0,16] : sdramreaddata[0,16] };
                cachewritevalue = dowrite ? writedata : readdata;
            }
        }
    }
}

// L1 CACHES
unit cache_read(
    simple_dualport_bram_port0 cache0,
    simple_dualport_bram_port0 tags0,
    simple_dualport_bram_port0 cache1,
    simple_dualport_bram_port0 tags1,
    input!  uint$sdram_addr_width$  address,
    output! uint$sdram_addr_width$  cacheaddressL,
    output! uint$sdram_addr_width$  cacheaddressH,
    output! uint2   tagmatch,
    output! uint32  rdata,
    output! uint2   needswrite
) <reginputs> {
    // DATA CACHE for SDRAM - CACHE SIZE DETERMINED BY L1size DEFINED ABOVE, MUST BE A POWER OF 2
    // 2 BLOCKS ONE FOR xxx0x ONE FOR xxx1x addresses
    // DATA CACHE ADDRESS IS LOWER bits of the address, dropping the BYTE AND HALF WORD address bits
    // DATA CACHE TAG IS REMAINING bits of the address + 1 bit for valid flag + 1 bit for needwritetosdram flag
    uint$sdram_addr_width$ address0 <: address + { address[1,1], 1b0 };
    uint$sdram_addr_width$ cacheaddress_address0 <: { L1cachetag(tags0.rdata0).partaddress, address0[2,$L1cacheaddrwidth$], 2b00 };
    uint$sdram_addr_width$ cacheaddress_address1 <: { L1cachetag(tags1.rdata0).partaddress, address[2,$L1cacheaddrwidth$], 2b10 };

    uint1   cache_match0 <: { L1cachetag(tags0.rdata0).valid, L1cachetag(tags0.rdata0).partaddress } == { 1b1, address0[$L1partaddressstart$,$L1partaddresswidth$] };
    uint1   cache_match1 <: { L1cachetag(tags1.rdata0).valid, L1cachetag(tags1.rdata0).partaddress } == { 1b1, address[$L1partaddressstart$,$L1partaddresswidth$] };

    cache0.addr0 := address0[2,$L1cacheaddrwidth$]; tags0.addr0 := address0[2,$L1cacheaddrwidth$];
    cache1.addr0 := address[2,$L1cacheaddrwidth$]; tags1.addr0 := address[2,$L1cacheaddrwidth$];

    tagmatch := address[1,1] ? { cache_match0, cache_match1 } : { cache_match1, cache_match0 };
    needswrite := address[1,1] ? { L1cachetag(tags0.rdata0).needswrite, L1cachetag(tags1.rdata0).needswrite } : { L1cachetag(tags1.rdata0).needswrite, L1cachetag(tags0.rdata0).needswrite };
    rdata := address[1,1] ? { cache0.rdata0, cache1.rdata0 } : { cache1.rdata0, cache0.rdata0 };

    cacheaddressL := address[1,1] ? cacheaddress_address1 : cacheaddress_address0;
    cacheaddressH := address[1,1] ? cacheaddress_address0 : cacheaddress_address1;
}

unit cache_write(
    simple_dualport_bram_port1 cache0,
    simple_dualport_bram_port1 tags0,
    simple_dualport_bram_port1 cache1,
    simple_dualport_bram_port1 tags1,
    input   uint$sdram_addr_width$  address,
    input   uint1   needwritetosdram,
    input   uint32  writedata,
    input   uint2   update
) <reginputs> {
    uint$sdram_addr_width$ address0 <:: address + { address[1,1], 1b0 };

    cache0.addr1 := address0[2,$L1cacheaddrwidth$]; cache0.wdata1 := address[1,1] ? writedata[16,16] : writedata[0,16]; cache0.wenable1 := address[1,1] ? update[1,1] : update[0,1];
    tags0.addr1 := address0[2,$L1cacheaddrwidth$]; tags0.wenable1 := address[1,1] ? update[1,1] : update[0,1];
    tags0.wdata1 := { needwritetosdram, 1b1, address0[$L1partaddressstart$,$L1partaddresswidth$] };

    cache1.addr1 := address[2,$L1cacheaddrwidth$]; cache1.wdata1 := address[1,1] ? writedata[0,16] : writedata[16,16]; cache1.wenable1 := address[1,1] ? update[0,1] : update[1,1];
    tags1.addr1 := address[2,$L1cacheaddrwidth$]; tags1.wenable1 := address[1,1] ? update[0,1] : update[1,1];
    tags1.wdata1 := { needwritetosdram, 1b1, address[$L1partaddressstart$,$L1partaddresswidth$] };
}

// START READ/WRITE FROM SDRAM, 16BIT
unit sdramcontroller(
    sdram_user      sio,
    input   uint$sdram_addr_width$  address,
    input   uint1   writeflag,
    input   uint16  writedata,
    input   uint1   readflag,
    output! uint16  readdata,
    output  uint1   busy(0)
) <reginputs> {
    uint1   rw <: readflag | writeflag;
    uint1   dR = uninitialized;

    sio.addr := address; sio.data_in := writedata; sio.rw := writeflag; sio.in_valid := rw;
    busy := rw ? 1 : sio.done ? 0 : busy;

    dR := rw ? readflag : dR;
    readdata := ( sio.done & dR ) ? sio.data_out : readdata;
}
