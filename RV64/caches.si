// HART ID 0 L0 CACHE
unit il00cache_read(
    simple_dualport_bram_port0 L0cache,
    simple_dualport_bram_port0 L0tags,
    input   uint$addr_width$  address,
    input   uint1   invalidate,
    input   uint1   CLS,
    output  uint30  instruction,
    output  uint1   compressed,
    output  uint1   tagmatch
) <reginputs> {
    L0cache.addr0 := address[1,$L00Icount$]; L0tags.addr0 := address[1,$L00Icount$];                                            // FOR EACH CACHE BLOCK, SET ADDRESS FROM CPU

    tagmatch := ~( invalidate | CLS ) & L0tags.rdata0 == address[$L00Ipartaddressstart$,$L00Ipartaddresswidth$] & L00cacheI( L0cache.rdata0 ).valid;
    instruction := L00cacheI( L0cache.rdata0 ).instruction;
    compressed := L00cacheI( L0cache.rdata0 ).compressed;
}

unit il00cache_write(
    simple_dualport_bram_port1 L0cache,
    input   uint$addr_width$  address,
    input   uint30  newinstruction,
    input   uint1   newcompressed,
    input   uint1   update,
    input   uint1   invalidate,
    output  uint1   CLS
) <reginputs> {
    uint$L00Icount+1$ count = 0;
    CLS := invalidate | ( count != $L00Iblocks$ ); L0cache.wenable1 := 1;

    always_after {
        if( CLS ) {
            if( invalidate ) {
                count = 0;
            } else {
                L0cache.addr1 = count; L0cache.wdata1 = 0;
                count = count + 1;
            }
        } else {
            if( update ) {
                L0cache.addr1 = address[1,$L00Icount$];
                L0cache.wdata1 = { newinstruction, newcompressed, 1b1 };
            }
        }
    }
}

unit il00tags_write(
    simple_dualport_bram_port1 L0tags,
    input   uint$addr_width$  address,
    input   uint1   update,
) <reginputs> {
    always_after {
        L0tags.addr1 = address[1,$L00Icount$];
        L0tags.wdata1 = address[$L00Ipartaddressstart$,$L00Ipartaddresswidth$];
        L0tags.wenable1 = update;
    }
}

// HART ID 1 L0 CACHE
unit il01cache_read(
    simple_dualport_bram_port0 L0cache,
    simple_dualport_bram_port0 L0tags,
    input   uint$addr_width$  address,
    input   uint1   invalidate,
    input   uint1   CLS,
    output  uint30  instruction,
    output  uint1   compressed,
    output  uint1   tagmatch
) <reginputs> {
    L0cache.addr0 := address[1,$L01Icount$]; L0tags.addr0 := address[1,$L01Icount$];                                            // FOR EACH CACHE BLOCK, SET ADDRESS FROM CPU ADDRESS

    tagmatch := ~( invalidate | CLS ) & L0tags.rdata0 == address[$L01Ipartaddressstart$,$L01Ipartaddresswidth$] & L01cacheI( L0cache.rdata0 ).valid;
    instruction := L01cacheI( L0cache.rdata0 ).instruction;
    compressed := L01cacheI( L0cache.rdata0 ).compressed;
}

unit il01cache_write(
    simple_dualport_bram_port1 L0cache,
    input   uint$addr_width$  address,
    input   uint30  newinstruction,
    input   uint1   newcompressed,
    input   uint1   update,
    input   uint1   invalidate,
    output  uint1   CLS
) <reginputs> {
    uint$L01Icount+1$ count = 0;
    CLS := invalidate | ( count != $L01Iblocks$ ); L0cache.wenable1 := 1;

    always_after {

        if( CLS ) {
            if( invalidate ) {
                count = 0;
            } else {
                L0cache.addr1 = count; L0cache.wdata1 = 0;
                count = count + 1;
            }
        } else {
            if( update ) {
                L0cache.addr1 = address[1,$L01Icount$];
                L0cache.wdata1 = { newinstruction, newcompressed, 1b1 };
            }
        }
    }
}

unit il01tags_write(
    simple_dualport_bram_port1 L0tags,
    input   uint$addr_width$  address,
    input   uint1   update,
) <reginputs> {
    always_after {
        L0tags.addr1 = address[1,$L01Icount$];
        L0tags.wdata1 = address[$L01Ipartaddressstart$,$L01Ipartaddresswidth$];
        L0tags.wenable1 = update;
    }
}


// 32Mb of SDRAM using @sylefeb controller
// Controlled by a 16bit EVICTION CACHE FOR DATA
// Cache-coherency is maintained
// Controller is 16bit, the natural width of the SDRAM on the ULX3s
// An eviction cache was chosen as easy to implement as a directly mapped cache
// Writes to SDRAM only if required when evicting a cache entry

// 16 bit to 32 bit controller
// CPU has a 32 bit memory bus, with 16 bit aligned read/writes
// SDRAM is 16 bit
// Interface the 32 bit CPU memory bus to the 16 bit SDRAM memory bus
unit cachecontroller(
    sdram_user      sio,
    input   uint1   clock_cache,
    input   uint1   cacheselect,
    input   uint$sdram_addr_width$  address,
    input   uint2   accesssize,
    input   uint1   writeflag,
    input   uint32  writedata,
    input   uint1   readflag,
    output  uint32  readdata,
    output  uint1   busy(0)
) <reginputs> {
    uint32  cachewritevalue = uninitialized;                                                                                    // VALUE TO WRITE THROUGH TO THE CACHE
    simple_dualport_bram uint16 Dcache0 <@clock_cache,@clock> [$L1size$] = uninitialized;                                       // COMBINED DATA&INSTRUCTION CACHE
    simple_dualport_bram uint$L1partaddresswidth+2$ Dtags0 <@clock_cache,@clock> [$L1size$] = uninitialized;
    simple_dualport_bram uint16 Dcache1 <@clock_cache,@clock> [$L1size$] = uninitialized;
    simple_dualport_bram uint$L1partaddresswidth+2$ Dtags1 <@clock_cache,@clock> [$L1size$] = uninitialized;
    cache_read DCACHE <@clock_cache> ( cache0 <:> Dcache0, cache1 <:> Dcache1, address <: address );
    tags_read DTAGS <@clock_cache> ( tags0 <:> Dtags0, tags1 <:> Dtags1, address <: address );
    cache_write DCACHEW( cache0 <:> Dcache0, cache1 <:> Dcache1, address <: address, writedata <: cachewritevalue );
    tags_write DTAGSW( tags0 <:> Dtags0, tags1 <:> Dtags1, needwritetosdram <: dowrite, address <: address );

    uint32  sdramreaddata = uninitialized;                                                                                      // SDRAM CONTROLLER
    uint1   dowrite = uninitialized;                                                                                            // MEMORY WRITE OPERATION FLAG

    sio.in_valid := 0; DCACHEW.update := 0; DTAGSW.update := 0;                                                                 // SDRAM ACCESS AND CACHE/TAGS UPDATE FLAGS

    algorithm <autorun> {
        uint1   doread = uninitialized;                                                                                         // MEMORY READ OPERATION FLAG
        uint$sdram_addr_width$ address2 <:: address + 2;                                                                        // ADDRESS FOR FOLLOWING MEMORY ADDRESS
        uint2   accessmask <:: { accesssize[1,1], 1b1 };                                                                        // ACCESSMASK WHICH PARTS OF THE 2 x 16 BIT CACHE PARTS ARE USED
        uint1   Dmatch <:: ( accesssize[1,1] ? &DTAGS.tagmatch : DTAGS.tagmatch[0,1] );                                         // CACHE MATCH FLAGS ( 32 bit both, 16/8 bit lower )
        uint2   Devict <:: accessmask & DTAGS.needswrite & ~DTAGS.tagmatch;                                                     // CACHE EVICTION FLAG ( HIGH, LOW )
        uint2   Dread <:: accessmask & ~DTAGS.tagmatch;                                                                         // CACHE READ REQUIRED FLAG ( HIGH, LOW )
        uint1   doreadsdram <:: ( doread | ( dowrite & ~|accesssize ) );                                                        // SDRAM READ FLAG FOR CACHE MISS, READ OR 8 BIT WRITE

        while(1) {
            doread = readflag; dowrite = writeflag;                                                                             // LATCH READ/WRITE FLAGS
            if( doread | dowrite ) {
                if( Dmatch ) {                                                                                                  // CACHE HIT
                    if( dowrite ) {
                        ++:
                        DCACHEW.update = accessmask; DTAGSW.update = accessmask;                                                // UPDATE CACHE/TAGS IF WRITE
                    }
                } else {                                                                                                        // CACHE MISS
                    busy = 1;
                    if( |Devict ) {                                                                                             // EVICT AS PARTS OF CACHE LINE NEEDED AND OCCUPIED
                        sio.rw = 1;
                        sio.addr = Devict[0,1] ? DTAGS.cacheaddressL : DTAGS.cacheaddressH;                                     //      EVICT FIRST ( possibly only ) 16 BITS
                        sio.data_in = DCACHE.rdata[ Devict[0,1] ? 0 : 16, 16 ]; sio.in_valid = 1;
                        if( &Devict ) {
                            while( ~sio.done ) {} sio.addr = DTAGS.cacheaddressH;                                               //      EVICT SECOND 16 BITS
                            sio.data_in = DCACHE.rdata[16,16];sio.in_valid = 1;
                        }
                        while( ~sio.done ) {}
                    }
                    if( doreadsdram & |Dread) {                                                                                 // READ FROM SDRAM FOR READ / 8 BIT WRITE
                        sio.rw = 0;
                        sio.addr = Dread[0,1] ? address : address2; sio.in_valid = 1; while( ~sio.done ) {}                     //      READ FIRST ( possibly only ) 16 BITS
                        if( &Dread ) {
                            sdramreaddata[0,16] = sio.data_out;                                                                 //      LATCH LOWER 16 BITS FOR ALL 32 BIT READ
                            sio.addr = address2; sio.in_valid = 1;                                                              //      READ UPPER 16 BITS
                            while( ~sio.done ) {} sdramreaddata[16,16] = sio.data_out;                                          //      LATCH UPPER 16 BITS
                        } else {
                            sdramreaddata = Dread[0,1] ? { 16b0, sio.data_out } : { sio.data_out, 16b0 };                       //      LTACH LOWER OR UPPER 16 BITS FOR ONLY 16 BIT READ
                        }
                    }
                    DCACHEW.update = doreadsdram ? Dread : accessmask;                                                          // UPDATE CACHE READ AND 8 BIT WRITE : 32/16 WRITE
                    DTAGSW.update = doreadsdram ? Dread : accessmask;                                                           // UPDATE TAGS READ AND 8 BIT WRITE : 32/16 WRITE
                    busy = 0;
                }
            }
        }
    }

    always_after {                                                                                                              // SET THE CACHE WRITE THROUGH VALUE ABD READDATA VALUE
        switch( accesssize ) {                                                                                                  // FROM CACHE OR SDRAM AS APPLICABLE
            case 2b00: {
                readdata = DTAGS.tagmatch[0,1] ? DCACHE.rdata[0,16] : sdramreaddata[0,16];
                cachewritevalue = dowrite ? address[0,1] ? { writedata[0,8], DTAGS.tagmatch[0,1] ? DCACHE.rdata[0,8] : sdramreaddata[0,8] } :
                                                           { DTAGS.tagmatch[0,1] ? DCACHE.rdata[8,8] : sdramreaddata[8,8], writedata[0,8] } : readdata;
            }
            case 2b01: {
                readdata = DTAGS.tagmatch[0,1] ? DCACHE.rdata[0,16] : sdramreaddata[0,16];
                cachewritevalue = dowrite ? writedata[0,16] : readdata;
            }
            default: {
                readdata = { DTAGS.tagmatch[1,1] ? DCACHE.rdata[16,16] : sdramreaddata[16,16], DTAGS.tagmatch[0,1] ? DCACHE.rdata[0,16] : sdramreaddata[0,16] };
                cachewritevalue = dowrite ? writedata : readdata;
            }
        }
    }
}

// L1 CACHES
// DATA CACHE for SDRAM - CACHE SIZE DETERMINED BY L1size DEFINED ABOVE, MUST BE A POWER OF 2
// 2 BLOCKS ONE FOR xxx0x ONE FOR xxx1x addresses
// DATA CACHE ADDRESS IS LOWER bits of the address, dropping the BYTE AND HALF WORD address bits
// DATA CACHE TAG IS REMAINING bits of the address + 1 bit for valid flag + 1 bit for needwritetosdram flag
unit cache_read(
    simple_dualport_bram_port0 cache0,
    simple_dualport_bram_port0 cache1,
    input   uint$sdram_addr_width$  address,
    output! uint32  rdata,
) <reginputs> {
    always_after {
        uint$sdram_addr_width$ address0 = address + { address[1,1], 1b0 };

        cache0.addr0 = address0[2,$L1cacheaddrwidth$]; cache1.addr0 = address[2,$L1cacheaddrwidth$];
        rdata = address[1,1] ? { cache0.rdata0, cache1.rdata0 } : { cache1.rdata0, cache0.rdata0 };
    }
}

unit tags_read(
    simple_dualport_bram_port0 tags0,
    simple_dualport_bram_port0 tags1,
    input   uint$sdram_addr_width$  address,
    output! uint$sdram_addr_width$  cacheaddressL,
    output! uint$sdram_addr_width$  cacheaddressH,
    output! uint2   tagmatch,
    output! uint2   needswrite
) <reginputs> {
    always_after {
        uint$sdram_addr_width$ address0 = address + { address[1,1], 1b0 };
        uint$sdram_addr_width$ cacheaddress_address0 = { L1cachetag(tags0.rdata0).partaddress, address0[2,$L1cacheaddrwidth$], 2b00 };
        uint$sdram_addr_width$ cacheaddress_address1 = { L1cachetag(tags1.rdata0).partaddress, address[2,$L1cacheaddrwidth$], 2b10 };

        uint1   cache_match0 = { L1cachetag(tags0.rdata0).valid, L1cachetag(tags0.rdata0).partaddress } == { 1b1, address0[$L1partaddressstart$,$L1partaddresswidth$] };
        uint1   cache_match1 = { L1cachetag(tags1.rdata0).valid, L1cachetag(tags1.rdata0).partaddress } == { 1b1, address[$L1partaddressstart$,$L1partaddresswidth$] };

        tags0.addr0 = address0[2,$L1cacheaddrwidth$]; tags1.addr0 = address[2,$L1cacheaddrwidth$];

        tagmatch = address[1,1] ? { cache_match0, cache_match1 } : { cache_match1, cache_match0 };
        needswrite = address[1,1] ? { L1cachetag(tags0.rdata0).needswrite, L1cachetag(tags1.rdata0).needswrite } : { L1cachetag(tags1.rdata0).needswrite, L1cachetag(tags0.rdata0).needswrite };

        cacheaddressL = address[1,1] ? cacheaddress_address1 : cacheaddress_address0;
        cacheaddressH = address[1,1] ? cacheaddress_address0 : cacheaddress_address1;
    }
}

unit cache_write(
    simple_dualport_bram_port1 cache0,
    simple_dualport_bram_port1 cache1,
    input   uint$sdram_addr_width$  address,
    input   uint32  writedata,
    input   uint2   update
) <reginputs> {
    always_after {
        uint$sdram_addr_width$ address0 = address + { address[1,1], 1b0 };

        cache0.addr1 = address0[2,$L1cacheaddrwidth$]; cache0.wdata1 = address[1,1] ? writedata[16,16] : writedata[0,16]; cache0.wenable1 = address[1,1] ? update[1,1] : update[0,1];
        cache1.addr1 = address[2,$L1cacheaddrwidth$]; cache1.wdata1 = address[1,1] ? writedata[0,16] : writedata[16,16]; cache1.wenable1 = address[1,1] ? update[0,1] : update[1,1];
    }
}

unit tags_write(
    simple_dualport_bram_port1 tags0,
    simple_dualport_bram_port1 tags1,
    input   uint$sdram_addr_width$  address,
    input   uint1   needwritetosdram,
    input   uint2   update
) <reginputs> {
    always_after {
        uint$sdram_addr_width$ address0 = address + { address[1,1], 1b0 };

        tags0.addr1 = address0[2,$L1cacheaddrwidth$]; tags0.wenable1 = address[1,1] ? update[1,1] : update[0,1];
        tags0.wdata1 = { needwritetosdram, 1b1, address0[$L1partaddressstart$,$L1partaddresswidth$] };

        tags1.addr1 = address[2,$L1cacheaddrwidth$]; tags1.wenable1 = address[1,1] ? update[0,1] : update[1,1];
        tags1.wdata1 = { needwritetosdram, 1b1, address[$L1partaddressstart$,$L1partaddresswidth$] };
    }
}

