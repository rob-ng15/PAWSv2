// HART ID 0 L0 CACHE
unit il00cache_read(
$$for i=0,(L00Iblocks-1) do
    simple_dualport_bram_port0 L0cache_$i$,
$$end
    input   uint$addr_width$  address,
    input   uint1   invalidate,
    input   uint1   CLS,
    output  uint30  instruction,
    output  uint1   compressed,
    output  uint1   tagmatch
) <reginputs> {
    uint$32+L00Ipartaddresswidth$ cacheline = uninitialised;

    $$for i=0,(L00Iblocks-1) do
        L0cache_$i$.addr0 := address[$1+L00Icount$,$L0Icacheaddrwidth$];
    $$end

    algorithm <autorun> {
        while(1) {
            tagmatch = ~( invalidate | CLS ) & ( L00cacheI( cacheline ).tag == address[$L00Ipartaddressstart$,$L00Ipartaddresswidth$] ) & L00cacheI( cacheline).valid;
            instruction = L00cacheI( cacheline ).instruction;
            compressed = L00cacheI( cacheline ).compressed;
        }
    }

    always_after {
        switch( address[1,$L00Icount$] ) {
            $$for i=0,(L00Iblocks-1) do
                case $i$: { cacheline = L0cache_$i$.rdata0; }
            $$end
        }
    }
}

unit il00cache_write(
$$for i=0,(L00Iblocks-1) do
    simple_dualport_bram_port1 L0cache_$i$,
$$end
    input   uint$addr_width$  address,
    input   uint30  newinstruction,
    input   uint1   newcompressed,
    input   uint1   update,
    input   uint1   invalidate,
    output  uint1   CLS
) <reginputs> {
    uint$L0Icacheaddrwidth+1$ count = 0;
    uint$L0Icacheaddrwidth+1$ countNEXT <:: count + 1;

    $$for i=0,(L00Iblocks-1) do
        L0cache_$i$.wenable1 := 1;
    $$end
    CLS := invalidate | ( count != $L0Isize$ );

    algorithm <autorun> {
        while(1) {
            if( update & ~CLS ) {
                switch( address[1,$L00Icount$] ) {
                    $$for i=0,(L00Iblocks-1) do
                        case $i$: {
                            L0cache_$i$.addr1 = address[$1+L00Icount$,$L0Icacheaddrwidth$];
                            L0cache_$i$.wdata1 = { address[$L00Ipartaddressstart$,$L00Ipartaddresswidth$], newinstruction, newcompressed, 1b1 };
                        }
                    $$end
                }
            }
        }
    }

    always_after {
        if( CLS ) {
            if( invalidate ) {
                count = 0;
            } else {
                $$for i=0,(L00Iblocks-1) do
                    L0cache_$i$.addr1 = count; L0cache_$i$.wdata1 = 0;
                $$end
                count = countNEXT;
            }
        }
    }
}

// HART ID 1 L0 CACHE
unit il01cache_read(
$$for i=0,(L01Iblocks-1) do
    simple_dualport_bram_port0 L0cache_$i$,
$$end
    input   uint$addr_width$  address,
    input   uint1   invalidate,
    input   uint1   CLS,
    output  uint30  instruction,
    output  uint1   compressed,
    output  uint1   tagmatch
) <reginputs> {
    uint$32+L01Ipartaddresswidth$ cacheline = uninitialised;

    $$for i=0,(L01Iblocks-1) do
        L0cache_$i$.addr0 := address[$1+L01Icount$,$L0Icacheaddrwidth$];
    $$end

    algorithm <autorun> {
        while(1) {
            tagmatch = ~( invalidate | CLS ) & ( L01cacheI( cacheline ).tag == address[$L01Ipartaddressstart$,$L01Ipartaddresswidth$] ) & L01cacheI( cacheline ).valid;
            instruction = L01cacheI( cacheline ).instruction;
            compressed =  L01cacheI( cacheline ).compressed;
        }
    }

    always_after {
        switch( address[1,$L01Icount$] ) {
            $$for i=0,(L01Iblocks-1) do
                case $i$: { cacheline = L0cache_$i$.rdata0; }
            $$end
        }
    }
}

unit il01cache_write(
$$for i=0,(L01Iblocks-1) do
    simple_dualport_bram_port1 L0cache_$i$,
$$end
    input   uint$addr_width$  address,
    input   uint30  newinstruction,
    input   uint1   newcompressed,
    input   uint1   update,
    input   uint1   invalidate,
    output  uint1   CLS
) <reginputs> {
    uint$L0Icacheaddrwidth+1$ count = 0;
    uint$L0Icacheaddrwidth+1$ countNEXT <:: count + 1;

    $$for i=0,(L01Iblocks-1) do
        L0cache_$i$.wenable1 := 1;
    $$end
    CLS := invalidate | ( count != $L0Isize$ );

    algorithm <autorun> {
        while(1) {
            if( update & ~CLS ) {
                switch( address[1,$L01Icount$] ) {
                    $$for i=0,(L01Iblocks-1) do
                        case $i$: {
                            L0cache_$i$.addr1 = address[$1+L01Icount$,$L0Icacheaddrwidth$];
                            L0cache_$i$.wdata1 = { address[$L01Ipartaddressstart$,$L01Ipartaddresswidth$], newinstruction, newcompressed, 1b1 };
                        }
                    $$end
                }
            }
        }
    }

    always_after {
        if( CLS ) {
            if( invalidate ) {
                count = 0;
            } else {
                $$for i=0,(L01Iblocks-1) do
                    L0cache_$i$.addr1 = count; L0cache_$i$.wdata1 = 0;
                $$end
                count = countNEXT;
            }
        }
    }
}

// 32Mb of SDRAM using @sylefeb controller
// Controlled by a 16bit EVICTION CACHE FOR DATA
// Cache-coherency is maintained
// Controller is 16bit, the natural width of the SDRAM on the ULX3s
// An eviction cache was chosen as easy to implement as a directly mapped cache
// Writes to SDRAM only if required when evicting a cache entry

// 16 bit to 32 bit controller
// CPU has a 32 bit memory bus, with 16 bit aligned read/writes
// SDRAM is 16 bit
// Interface the 32 bit CPU memory bus to the 16 bit SDRAM memory bus
unit cachecontroller(
    sdram_user      sio,
    input   uint1   clock_cache,
    input   uint1   cacheselect,
    input   uint$sdram_addr_width$  address,
    input   uint2   accesssize,
    input   uint1   writeflag,
    input   uint32  writedata,
    input   uint1   readflag,
    output  uint32  readdata,
    output  uint1   busy(0)
) <reginputs> {
    // COMBINED DATA&INSTRUCTION CACHE
    simple_dualport_bram uint16 Dcache0 <@clock_cache,@clock> [$L1size$] = uninitialized;
    simple_dualport_bram uint$L1partaddresswidth+2$ Dtags0 <@clock_cache,@clock> [$L1size$] = uninitialized;
    simple_dualport_bram uint16 Dcache1 <@clock_cache,@clock> [$L1size$] = uninitialized;
    simple_dualport_bram uint$L1partaddresswidth+2$ Dtags1 <@clock_cache,@clock> [$L1size$] = uninitialized;
    cache_read DCACHE <@clock_cache> ( cache0 <:> Dcache0, tags0 <:> Dtags0, cache1 <:> Dcache1, tags1 <:> Dtags1, address <: address );
    cache_write DCACHEW( cache0 <:> Dcache0, tags0 <:> Dtags0, cache1 <:> Dcache1, tags1 <:> Dtags1, needwritetosdram <: dowrite, address <: address, writedata <: cachewritevalue );

    // SDRAM CONTROLLER
    uint32  sdramreaddata = uninitialized;          sdramcontroller SDRAM( sio <:> sio );

    // VALUE TO WRITE THROUGH TO THE CACHE
    uint32  cachewritevalue = uninitialized;

    // MEMORY ACCESS FLAGS
    uint1   doread = uninitialized;                 uint1   dowrite = uninitialized;

    // ADDRESS FOR FOLLOWING MEMORY ADDRESS
    uint$sdram_addr_width$ address2 <:: address + 2;

    // ACCESSMASK WHICH PARTS OF THE 2 x 16 BIT CACHE PARTS ARE USED
    uint2   accessmask <:: { accesssize[1,1], 1b1 };

    // CACHE TAG flags
    uint1   Dmatch <:: ( accesssize[1,1] ? &DCACHE.tagmatch : DCACHE.tagmatch[0,1] );
    uint2   Devict <:: accessmask & DCACHE.needswrite & ~DCACHE.tagmatch;
    uint2   Dread <:: accessmask & ~DCACHE.tagmatch;

    // SDRAM READ FLAG FOR CACHE MISS, READ OR 8 BIT WRITE
    uint1   doreadsdram <:: ( doread | ( dowrite & ~|accesssize ) );

    // SDRAM ACCESS AND CACHE UPDATE FLAGS
    SDRAM.readflag := 0; SDRAM.writeflag := 0; DCACHEW.update := 0;

    algorithm <autorun> {
        while(1) {
            doread = readflag; dowrite = writeflag;
            if( doread | dowrite ) {
                if( Dmatch ) {                                                                                                          // CACHE HIT
                    if( dowrite ) {
                        ++:
                        DCACHEW.update = accessmask;                                                                                    // UPDATE CACHE IF WRITE
                    }
                } else {                                                                                                                // CACHE MISS
                    busy = 1;
                    if( |Devict ) {
                        switch( Devict ) {                                                                                              // EVICT AS CACHE LINE NEEDED AND OCCUPIED
                            case 2b00: {}
                            case 2b01: {
                                SDRAM.address = DCACHE.cacheaddressL; SDRAM.writedata = DCACHE.rdata[0,16]; SDRAM.writeflag = 1;
                                while(1) { if( sio.done ) { break; } }
                            }
                            case 2b10: {
                                SDRAM.address = DCACHE.cacheaddressH; SDRAM.writedata = DCACHE.rdata[16,16]; SDRAM.writeflag = 1;
                                while(1) { if( sio.done ) { break; } }
                            }
                            case 2b11: {
                                SDRAM.address = DCACHE.cacheaddressH; SDRAM.writedata = DCACHE.rdata[16,16]; SDRAM.writeflag = 1;
                                while(1) { if( sio.done ) { SDRAM.address = DCACHE.cacheaddressL; SDRAM.writedata = DCACHE.rdata[0,16]; SDRAM.writeflag = 1; break; }  }
                                while(1) { if( sio.done ) { break; } }
                            }
                        }
                    }
                    if( doreadsdram ) {
                        switch( Dread ) {                                                                                               // READ FROM SDRAM FOR READ / 8 BIT WRITE
                            case 2b00: {}
                            case 2b01: {
                                SDRAM.address = address; SDRAM.readflag = 1;
                                while(1) { if( sio.done ) { sdramreaddata = { 16b0, SDRAM.readdata }; break; } }
                            }
                            case 2b10: {
                                SDRAM.address = address2; SDRAM.readflag = 1;
                                while(1) { if( sio.done ) { sdramreaddata = { SDRAM.readdata, 16b0 }; break; } }
                            }
                            case 2b11: {
                                SDRAM.address = address; SDRAM.readflag = 1;
                                while(1) { if( sio.done ) { sdramreaddata[0,16] = SDRAM.readdata; SDRAM.address = address2; SDRAM.readflag = 1; break; }  }
                                while(1) { if( sio.done ) { sdramreaddata[16,16] = SDRAM.readdata; break; }  }
                            }
                        }
                    }
                    DCACHEW.update = doreadsdram ? Dread : accessmask;                                                                  // UPDATE CACHE READ AND 8 BIT WRITE : 32/16 WRITE
                    busy = 0;
                }
            }
        }
    }

    always_after {
        switch( accesssize ) {
            case 2b00: {
                readdata = DCACHE.tagmatch[0,1] ? DCACHE.rdata[0,16] : sdramreaddata[0,16];
                cachewritevalue = dowrite ? address[0,1] ? { writedata[0,8], DCACHE.tagmatch[0,1] ? DCACHE.rdata[0,8] : sdramreaddata[0,8] } :
                                                           { DCACHE.tagmatch[0,1] ? DCACHE.rdata[8,8] : sdramreaddata[8,8], writedata[0,8] } : readdata;
            }
            case 2b01: {
                readdata = DCACHE.tagmatch[0,1] ? DCACHE.rdata[0,16] : sdramreaddata[0,16];
                cachewritevalue = dowrite ? writedata[0,16] : readdata;
            }
            default: {
                readdata = { DCACHE.tagmatch[1,1] ? DCACHE.rdata[16,16] : sdramreaddata[16,16], DCACHE.tagmatch[0,1] ? DCACHE.rdata[0,16] : sdramreaddata[0,16] };
                cachewritevalue = dowrite ? writedata : readdata;
            }
        }
    }
}

// L1 CACHES
unit cache_read(
    simple_dualport_bram_port0 cache0,
    simple_dualport_bram_port0 tags0,
    simple_dualport_bram_port0 cache1,
    simple_dualport_bram_port0 tags1,
    input!  uint$sdram_addr_width$  address,
    output! uint$sdram_addr_width$  cacheaddressL,
    output! uint$sdram_addr_width$  cacheaddressH,
    output! uint2   tagmatch,
    output! uint32  rdata,
    output! uint2   needswrite
) <reginputs> {
    // DATA CACHE for SDRAM - CACHE SIZE DETERMINED BY L1size DEFINED ABOVE, MUST BE A POWER OF 2
    // 2 BLOCKS ONE FOR xxx0x ONE FOR xxx1x addresses
    // DATA CACHE ADDRESS IS LOWER bits of the address, dropping the BYTE AND HALF WORD address bits
    // DATA CACHE TAG IS REMAINING bits of the address + 1 bit for valid flag + 1 bit for needwritetosdram flag
    uint$sdram_addr_width$ address0 <: address + { address[1,1], 1b0 };

    cache0.addr0 := address0[2,$L1cacheaddrwidth$]; tags0.addr0 := address0[2,$L1cacheaddrwidth$];
    cache1.addr0 := address[2,$L1cacheaddrwidth$]; tags1.addr0 := address[2,$L1cacheaddrwidth$];

    tagmatch := address[1,1] ? { { L1cachetag(tags0.rdata0).valid, L1cachetag(tags0.rdata0).partaddress } == { 1b1, address0[$L1partaddressstart$,$L1partaddresswidth$] },
                            { L1cachetag(tags1.rdata0).valid, L1cachetag(tags1.rdata0).partaddress } == { 1b1, address[$L1partaddressstart$,$L1partaddresswidth$] } } :
                            { { L1cachetag(tags1.rdata0).valid, L1cachetag(tags1.rdata0).partaddress } == { 1b1, address[$L1partaddressstart$,$L1partaddresswidth$] },
                            { L1cachetag(tags0.rdata0).valid, L1cachetag(tags0.rdata0).partaddress } == { 1b1, address0[$L1partaddressstart$,$L1partaddresswidth$] } };

    needswrite := address[1,1] ? { L1cachetag(tags0.rdata0).needswrite, L1cachetag(tags1.rdata0).needswrite } : { L1cachetag(tags1.rdata0).needswrite, L1cachetag(tags0.rdata0).needswrite };
    rdata := address[1,1] ? { cache0.rdata0, cache1.rdata0 } : { cache1.rdata0, cache0.rdata0 };

    cacheaddressL := address[1,1] ? { L1cachetag(tags1.rdata0).partaddress, address[2,$L1cacheaddrwidth$], 2b10 } : { L1cachetag(tags0.rdata0).partaddress, address0[2,$L1cacheaddrwidth$], 2b00 };
    cacheaddressH := address[1,1] ? { L1cachetag(tags0.rdata0).partaddress, address0[2,$L1cacheaddrwidth$], 2b00 } : { L1cachetag(tags1.rdata0).partaddress, address[2,$L1cacheaddrwidth$], 2b10 };
}

unit cache_write(
    simple_dualport_bram_port1 cache0,
    simple_dualport_bram_port1 tags0,
    simple_dualport_bram_port1 cache1,
    simple_dualport_bram_port1 tags1,
    input   uint$sdram_addr_width$  address,
    input   uint1   needwritetosdram,
    input   uint32  writedata,
    input   uint2   update
) <reginputs> {
    uint$sdram_addr_width$ address0 <:: address + { address[1,1], 1b0 };

    cache0.addr1 := address0[2,$L1cacheaddrwidth$]; cache0.wdata1 := address[1,1] ? writedata[16,16] : writedata[0,16]; cache0.wenable1 := address[1,1] ? update[1,1] : update[0,1];
    tags0.addr1 := address0[2,$L1cacheaddrwidth$]; tags0.wenable1 := address[1,1] ? update[1,1] : update[0,1];
    tags0.wdata1 := { needwritetosdram, 1b1, address0[$L1partaddressstart$,$L1partaddresswidth$] };

    cache1.addr1 := address[2,$L1cacheaddrwidth$]; cache1.wdata1 := address[1,1] ? writedata[0,16] : writedata[16,16]; cache1.wenable1 := address[1,1] ? update[0,1] : update[1,1];
    tags1.addr1 := address[2,$L1cacheaddrwidth$]; tags1.wenable1 := address[1,1] ? update[0,1] : update[1,1];
    tags1.wdata1 := { needwritetosdram, 1b1, address[$L1partaddressstart$,$L1partaddresswidth$] };
}

// START READ/WRITE FROM SDRAM, 16BIT
unit sdramcontroller(
    sdram_user      sio,
    input   uint$sdram_addr_width$  address,
    input   uint1   writeflag,
    input   uint16  writedata,
    input   uint1   readflag,
    output! uint16  readdata,
    output  uint1   busy(0)
) <reginputs> {
    uint1   rw <: readflag | writeflag;
    uint1   dR = uninitialized;

    sio.addr := address; sio.data_in := writedata; sio.rw := writeflag; sio.in_valid := rw;
    busy := rw ? 1 : sio.done ? 0 : busy;

    dR := rw ? readflag : dR;
    readdata := ( sio.done & dR ) ? sio.data_out : readdata;
}
