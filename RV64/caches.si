// HART ID 0 L0 CACHE
unit il00cache_read(
$$for i=0,(L00Iblocks-1) do
    simple_dualport_bram_port0 L0cache_$i$,
$$end
    input   uint$addr_width$  address,
    input   uint1   invalidate,
    input   uint1   CLS,
    output  uint30  instruction,
    output  uint1   compressed,
    output  uint1   tagmatch
) <reginputs> {
    $$for i=0,(L00Iblocks-1) do
        L0cache_$i$.addr0 := address[$1+L00Icount$,$L0Icacheaddrwidth$];
    $$end

    always_after {
        uint$32+L00Ipartaddresswidth$ cacheline = uninitialised;
        { tagmatch = ~( invalidate | CLS ) & ( L00cacheI( cacheline ).tag == address[$L00Ipartaddressstart$,$L00Ipartaddresswidth$] ) & L00cacheI( cacheline).valid; }
        { instruction = L00cacheI( cacheline ).instruction; }
        { compressed = L00cacheI( cacheline ).compressed; }
        {
            switch( address[1,$L00Icount$] ) {
                $$for i=0,(L00Iblocks-1) do
                    case $i$: { cacheline = L0cache_$i$.rdata0; }
                $$end
            }
        }
   }
}

unit il00cache_write(
$$for i=0,(L00Iblocks-1) do
    simple_dualport_bram_port1 L0cache_$i$,
$$end
    input   uint$addr_width$  address,
    input   uint30  newinstruction,
    input   uint1   newcompressed,
    input   uint1   update,
    input   uint1   invalidate,
    output  uint1   CLS
) <reginputs> {
    uint$L0Icacheaddrwidth+1$ count = uninitialised;

    $$for i=0,(L00Iblocks-1) do
        L0cache_$i$.wenable1 := 1;
    $$end
    CLS := ( count != $L0Isize$ );

    always_after {
        switch( { CLS, invalidate } ) {
            case 2b00: {
                if( update ) {
                    switch( address[1,$L00Icount$] ) {
                        $$for i=0,(L00Iblocks-1) do
                            case $i$: {
                                L0cache_$i$.addr1 = address[$1+L00Icount$,$L0Icacheaddrwidth$];
                                L0cache_$i$.wdata1 = { address[$L00Ipartaddressstart$,$L00Ipartaddresswidth$], newinstruction, newcompressed, 1b1 };
                            }
                        $$end
                    }
                }
            }
            case 2b10: {
                $$for i=0,(L00Iblocks-1) do
                    L0cache_$i$.addr1 = count; L0cache_$i$.wdata1 = 0;
                $$end
                count = count + 1;
            }
            default: { count = 0; }
        }
    }
}

// HART ID 1 L0 CACHE
unit il01cache_read(
$$for i=0,(L01Iblocks-1) do
    simple_dualport_bram_port0 L0cache_$i$,
$$end
    input   uint$addr_width$  address,
    input   uint1   invalidate,
    input   uint1   CLS,
    output  uint30  instruction,
    output  uint1   compressed,
    output  uint1   tagmatch
) <reginputs> {
    $$for i=0,(L01Iblocks-1) do
        L0cache_$i$.addr0 := address[$1+L01Icount$,$L0Icacheaddrwidth$];
    $$end

    always_after {
        uint$32+L01Ipartaddresswidth$ cacheline = uninitialised;
        { tagmatch = ~( invalidate | CLS ) & ( L01cacheI( cacheline ).tag == address[$L01Ipartaddressstart$,$L01Ipartaddresswidth$] ) & L01cacheI( cacheline ).valid; }
        { instruction = L01cacheI( cacheline ).instruction; }
        { compressed =  L01cacheI( cacheline ).compressed; }
        {
            switch( address[1,$L01Icount$] ) {
                $$for i=0,(L01Iblocks-1) do
                    case $i$: { cacheline = L0cache_$i$.rdata0; }
                $$end
            }
        }
    }
}

unit il01cache_write(
$$for i=0,(L01Iblocks-1) do
    simple_dualport_bram_port1 L0cache_$i$,
$$end
    input   uint$addr_width$  address,
    input   uint30  newinstruction,
    input   uint1   newcompressed,
    input   uint1   update,
    input   uint1   invalidate,
    output  uint1   CLS
) <reginputs> {
    uint$L0Icacheaddrwidth+1$ count = uninitialised;

    $$for i=0,(L01Iblocks-1) do
        L0cache_$i$.wenable1 := 1;
    $$end
    CLS := ( count != $L0Isize$ );

    always_after {
        switch( { CLS, invalidate } ) {
            case 2b00: {
                if( update ) {
                    switch( address[1,$L01Icount$] ) {
                        $$for i=0,(L01Iblocks-1) do
                            case $i$: {
                                L0cache_$i$.addr1 = address[$1+L01Icount$,$L0Icacheaddrwidth$];
                                L0cache_$i$.wdata1 = { address[$L01Ipartaddressstart$,$L01Ipartaddresswidth$], newinstruction, newcompressed, 1b1 };
                            }
                        $$end
                    }
                }
            }
            case 2b10: {
                $$for i=0,(L01Iblocks-1) do
                    L0cache_$i$.addr1 = count; L0cache_$i$.wdata1 = 0;
                $$end
                count = count + 1;
            }
            default: { count = 0; }
        }
    }
}

// 32Mb of SDRAM using @sylefeb controller
// Controlled by a 16bit EVICTION CACHE FOR DATA
// Cache-coherency is maintained
// Controller is 16bit, the natural width of the SDRAM on the ULX3s
// An eviction cache was chosen as easy to implement as a directly mapped cache
// Writes to SDRAM only if required when evicting a cache entry

// 16 bit to 32 bit controller
// CPU has a 32 bit memory bus, with 16 bit aligned read/writes
// SDRAM is 16 bit
// Interface the 32 bit CPU memory bus to the 16 bit SDRAM memory bus
unit cachecontroller(
    sdram_user      sio,
    input   uint1   clock_cache,
    input   uint1   cacheselect,
    input   uint$sdram_addr_width$  address,
    input   uint2   accesssize,
    input   uint1   writeflag,
    input   uint32  writedata,
    input   uint1   readflag,
    output  uint32  readdata,
    output  uint1   busy(0)
) <reginputs> {
    // COMBINED DATA&INSTRUCTION CACHE
    simple_dualport_bram uint16 Dcache0 <@clock_cache,@clock> [$L1size$] = uninitialized;
    simple_dualport_bram uint$L1partaddresswidth+2$ Dtags0 <@clock_cache,@clock> [$L1size$] = uninitialized;
    simple_dualport_bram uint16 Dcache1 <@clock_cache,@clock> [$L1size$] = uninitialized;
    simple_dualport_bram uint$L1partaddresswidth+2$ Dtags1 <@clock_cache,@clock> [$L1size$] = uninitialized;
    cache_read DCACHE <@clock_cache> ( cache0 <:> Dcache0, tags0 <:> Dtags0, cache1 <:> Dcache1, tags1 <:> Dtags1, address <: address );
    cache_write DCACHEW( cache0 <:> Dcache0, tags0 <:> Dtags0, cache1 <:> Dcache1, tags1 <:> Dtags1, needwritetosdram <: dowrite, address <: address, writedata <: cachewritevalue );

    // SDRAM CONTROLLER
    uint32  sdramreaddata = uninitialized;          sdramcontroller SDRAM( sio <:> sio );

    // VALUE TO WRITE THROUGH TO THE CACHE
    uint32  cachewritevalue = uninitialized;

    // MEMORY ACCESS FLAGS
    uint1   doread = uninitialized;                 uint1   dowrite = uninitialized;

    // ADDRESS FOR FOLLOWING MEMORY ADDRESS
    uint$sdram_addr_width$ address2 <:: address + 2;

    // ACCESSMASK WHICH PARTS OF THE 2 x 16 BIT CACHE PARTS ARE USED
    uint2   accessmask <:: { accesssize[1,1], 1b1 };

    // CACHE TAG flags
    uint1   Dmatch <:: ( accesssize[1,1] ? &DCACHE.tagmatch : DCACHE.tagmatch[0,1] );
    uint2   Devict <:: accessmask & DCACHE.needswrite & ~DCACHE.tagmatch;
    uint2   Dread <:: accessmask & ~DCACHE.tagmatch;

    // SDRAM READ FLAG FOR CACHE MISS, READ OR 8 BIT WRITE
    uint1   doreadsdram <:: ( doread | ( dowrite & ~|accesssize ) );

    // SDRAM ACCESS AND CACHE UPDATE FLAGS
    SDRAM.readflag := 0; SDRAM.writeflag := 0; DCACHEW.update := 0;

    algorithm <autorun> {
        while(1) {
            doread = readflag; dowrite = writeflag;
            if( doread | dowrite ) {
                if( Dmatch ) {                                                                                                          // CACHE HIT
                    if( dowrite ) {
                        ++:
                        DCACHEW.update = accessmask;                                                                                    // UPDATE CACHE IF WRITE
                    } else {
                        DCACHEW.update = 0;
                    }
                } else {                                                                                                                // CACHE MISS
                    busy = 1;
                    if( |Devict ) {
                        switch( Devict ) {                                                                                              // EVICT AS CACHE LINE NEEDED AND OCCUPIED
                            case 2b00: { SDRAM.writeflag = 0; }
                            case 2b01: {
                                SDRAM.address = DCACHE.cacheaddressL; SDRAM.writedata = DCACHE.rdata[0,16]; SDRAM.writeflag = 1; while( ~sio.done ) {}
                            }
                            case 2b10: {
                                SDRAM.address = DCACHE.cacheaddressH; SDRAM.writedata = DCACHE.rdata[16,16]; SDRAM.writeflag = 1; while( ~sio.done ) {}
                            }
                            case 2b11: {
                                SDRAM.address = DCACHE.cacheaddressH; SDRAM.writedata = DCACHE.rdata[16,16]; SDRAM.writeflag = 1; while( ~sio.done ) {}
                                SDRAM.address = DCACHE.cacheaddressL; SDRAM.writedata = DCACHE.rdata[0,16]; SDRAM.writeflag = 1; while( ~sio.done ) {}
                            }
                        }
                    } else {
                        SDRAM.writeflag = 0;
                    }
                    if( doreadsdram ) {
                        switch( Dread ) {                                                                                               // READ FROM SDRAM FOR READ / 8 BIT WRITE
                            case 2b00: { SDRAM.readflag = 0; }
                            case 2b01: {
                                SDRAM.address = address; SDRAM.readflag = 1; while( ~sio.done ) {} sdramreaddata = { 16b0, SDRAM.readdata };
                            }
                            case 2b10: {
                                SDRAM.address = address2; SDRAM.readflag = 1; while( ~sio.done ) {} sdramreaddata = { SDRAM.readdata, 16b0 };
                            }
                            case 2b11: {
                                SDRAM.address = address; SDRAM.readflag = 1; while( ~sio.done ) {} sdramreaddata[0,16] = SDRAM.readdata;
                                SDRAM.address = address2; SDRAM.readflag = 1; while( ~sio.done ) {} sdramreaddata[16,16] = SDRAM.readdata;
                            }
                        }
                        DCACHEW.update = Dread;                                                                                         // UPDATE THE CACHE FOR READ / 8 BIT WRITE
                    } else {
                        DCACHEW.update = accessmask;                                                                                    // UPDATE CACHE FOR 32/16 BIT WRITE
                    }
                    busy = 0;
                }
            } else {
                busy = 0;
            }
        }
    }

    always_after {
        {
            switch( accesssize ) {
                case 2b00: {
                    readdata = DCACHE.tagmatch[0,1] ? DCACHE.rdata[0,16] : sdramreaddata[0,16];
                    cachewritevalue = dowrite ? address[0,1] ? { writedata[0,8], DCACHE.tagmatch[0,1] ? DCACHE.rdata[0,8] : sdramreaddata[0,8] } :
                                                               { DCACHE.tagmatch[0,1] ? DCACHE.rdata[8,8] : sdramreaddata[8,8], writedata[0,8] } : readdata;
                }
                case 2b01: {
                    readdata = DCACHE.tagmatch[0,1] ? DCACHE.rdata[0,16] : sdramreaddata[0,16];
                    cachewritevalue = dowrite ? writedata[0,16] : readdata;
                }
                default: {
                    readdata = { DCACHE.tagmatch[1,1] ? DCACHE.rdata[16,16] : sdramreaddata[16,16], DCACHE.tagmatch[0,1] ? DCACHE.rdata[0,16] : sdramreaddata[0,16] };
                    cachewritevalue = dowrite ? writedata : readdata;
                }
            }
        }
    }
}

// L1 CACHES
unit cache_read(
    simple_dualport_bram_port0 cache0,
    simple_dualport_bram_port0 tags0,
    simple_dualport_bram_port0 cache1,
    simple_dualport_bram_port0 tags1,
    input!  uint$sdram_addr_width$  address,
    output! uint$sdram_addr_width$  cacheaddressL,
    output! uint$sdram_addr_width$  cacheaddressH,
    output! uint2   tagmatch,
    output! uint32  rdata,
    output! uint2   needswrite
) <reginputs> {
    // DATA CACHE for SDRAM - CACHE SIZE DETERMINED BY L1size DEFINED ABOVE, MUST BE A POWER OF 2
    // 2 BLOCKS ONE FOR xxx0x ONE FOR xxx1x addresses
    // DATA CACHE ADDRESS IS LOWER bits of the address, dropping the BYTE AND HALF WORD address bits
    // DATA CACHE TAG IS REMAINING bits of the address + 1 bit for valid flag + 1 bit for needwritetosdram flag
    uint$sdram_addr_width$ address0 <:: address + { address[1,1], 1b0 };

    always_after {
        { cache0.addr0 = address0[2,$L1cacheaddrwidth$]; } { tags0.addr0 = address0[2,$L1cacheaddrwidth$]; }
        { cache1.addr0 = address[2,$L1cacheaddrwidth$]; } { tags1.addr0 = address[2,$L1cacheaddrwidth$]; }

        {
            tagmatch = address[1,1] ? { { L1cachetag(tags0.rdata0).valid, L1cachetag(tags0.rdata0).partaddress } == { 1b1, address0[$L1partaddressstart$,$L1partaddresswidth$] },
                                        { L1cachetag(tags1.rdata0).valid, L1cachetag(tags1.rdata0).partaddress } == { 1b1, address[$L1partaddressstart$,$L1partaddresswidth$] } } :
                                    { { L1cachetag(tags1.rdata0).valid, L1cachetag(tags1.rdata0).partaddress } == { 1b1, address[$L1partaddressstart$,$L1partaddresswidth$] },
                                        { L1cachetag(tags0.rdata0).valid, L1cachetag(tags0.rdata0).partaddress } == { 1b1, address0[$L1partaddressstart$,$L1partaddresswidth$] } };
        }

        { needswrite = address[1,1] ? { L1cachetag(tags0.rdata0).needswrite, L1cachetag(tags1.rdata0).needswrite } : { L1cachetag(tags1.rdata0).needswrite, L1cachetag(tags0.rdata0).needswrite }; }
        { rdata = address[1,1] ? { cache0.rdata0, cache1.rdata0 } : { cache1.rdata0, cache0.rdata0 }; }
        { cacheaddressL = address[1,1] ? { L1cachetag(tags1.rdata0).partaddress, address[2,$L1cacheaddrwidth$], 2b10 } : { L1cachetag(tags0.rdata0).partaddress, address0[2,$L1cacheaddrwidth$], 2b00 }; }
        { cacheaddressH = address[1,1] ? { L1cachetag(tags0.rdata0).partaddress, address0[2,$L1cacheaddrwidth$], 2b00 } : { L1cachetag(tags1.rdata0).partaddress, address[2,$L1cacheaddrwidth$], 2b10 }; }
    }
}
unit cache_write(
    simple_dualport_bram_port1 cache0,
    simple_dualport_bram_port1 tags0,
    simple_dualport_bram_port1 cache1,
    simple_dualport_bram_port1 tags1,
    input   uint$sdram_addr_width$  address,
    input   uint1   needwritetosdram,
    input   uint32  writedata,
    input   uint2   update
) <reginputs> {
    uint$sdram_addr_width$ address0 <:: address + { address[1,1], 2b0 };

    cache0.wenable1 := 0; cache1.wenable1 := 0; tags0.wenable1 := 0; tags1.wenable1 := 0;

    always_after {
        { cache0.addr1 = address0[2,$L1cacheaddrwidth$]; } { tags0.addr1 = address0[2,$L1cacheaddrwidth$]; }
        { cache1.addr1 = address[2,$L1cacheaddrwidth$]; } { tags1.addr1 = address[2,$L1cacheaddrwidth$]; }

        {
            switch( address[1,1] ) {
                case 0: { if( update[0,1] ) { cache0.wdata1 = writedata[0,16]; cache0.wenable1 = 1; } }
                case 1: { if( update[0,1] ) { cache1.wdata1 = writedata[0,16]; cache1.wenable1 = 1; } }
            }
        }
        {
            switch( address[1,1] ) {
                case 0: { if( update[0,1] ) { tags0.wdata1 = { needwritetosdram, 1b1, address0[$L1partaddressstart$,$L1partaddresswidth$] }; tags0.wenable1 = 1; } }
                case 1: { if( update[0,1] ) { tags1.wdata1 = { needwritetosdram, 1b1, address[$L1partaddressstart$,$L1partaddresswidth$] }; tags1.wenable1 = 1; } }
            }
        }
        {
            switch( address[1,1] ) {
                case 0: { if( update[1,1] ) { cache1.wdata1 = writedata[16,16]; cache1.wenable1 = 1; } }
                case 1: { if( update[1,1] ) { cache0.wdata1 = writedata[16,16]; cache0.wenable1 = 1; } }
            }
        }
        {
            switch( address[1,1] ) {
                case 0: { if( update[1,1] ) { tags1.wdata1 = { needwritetosdram, 1b1, address[$L1partaddressstart$,$L1partaddresswidth$] }; tags1.wenable1 = 1; } }
                case 1: { if( update[1,1] ) { tags0.wdata1 = { needwritetosdram, 1b1, address0[$L1partaddressstart$,$L1partaddresswidth$] }; tags0.wenable1 = 1; } }
            }
        }
    }
}

// START READ/WRITE FROM SDRAM, 16BIT
unit sdramcontroller(
    sdram_user      sio,
    input   uint$sdram_addr_width$  address,
    input   uint1   writeflag,
    input   uint16  writedata,
    input   uint1   readflag,
    output! uint16  readdata,
    output  uint1   busy(0)
) <reginputs> {
    uint1   rw <:: readflag | writeflag;

    always_after {
        uint1   dR = uninitialized;

        { if( writeflag ) { sio.data_in = writedata; } }
        { if( rw ) { sio.addr = address; } }
        { if( rw ) { dR = readflag; } }
        { sio.rw = writeflag; }
        { sio.in_valid = rw; }
        { busy = rw ? 1 : sio.done ? 0 : busy; }
        { if( sio.done & dR ) { readdata = sio.data_out; } }
    }
}
