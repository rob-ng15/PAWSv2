unit gpu_queue(
    output  int11   bitmap_x_write,
    output  int11   bitmap_y_write,
    output  uint8   bitmap_colour_write,
    output  uint8   bitmap_colour_write_alt,
    output  uint1   bitmap_write,
    output  uint9   bitmap_crop_left,
    output  uint9   bitmap_crop_right,
    output  uint8   bitmap_crop_top,
    output  uint8   bitmap_crop_bottom,
    output  uint4   gpu_active_dithermode,

    input   uint9   crop_left,
    input   uint9   crop_right,
    input   uint8   crop_top,
    input   uint8   crop_bottom,

    input   int11   gpu_x,
    input   int11   gpu_y,
    input   uint8   gpu_colour,
    input   uint8   gpu_colour_alt,
    input   int11   gpu_param0,
    input   int11   gpu_param1,
    input   int11   gpu_param2,
    input   int11   gpu_param3,
    input   int11   gpu_param4,
    input   int11   gpu_param5,
    input   uint4   gpu_write,
    input   uint4   gpu_dithermode,

    simple_dualport_bram_port0 blit1tilemap,
    simple_dualport_bram_port0 characterGenerator8x8,
    simple_dualport_bram_port0 colourblittilemap,

    input   uint1   pb_mode,
    input   uint8   pb_colour,
    input   uint8   pb_colour8r,
    input   uint8   pb_colour8g,
    input   uint8   pb_colour8b,
    input   uint2   pb_newpixel,

    simple_dualport_bram_port0 pb_colourmap,

    input   uint8   vector_block_colour,
    input   int11   vector_drawer_gpu_x,
    input   int11   vector_drawer_gpu_y,
    input   int11   vector_drawer_gpu_param0,
    input   int11   vector_drawer_gpu_param1,
    input   uint1   vector_drawer_gpu_write,
    input   uint1   vector_block_active,

    output  uint1   queue_full(0),
    output  uint1   queue_complete(1),
    output  uint1   gpu_active
) <reginputs> {
    gpu GPU(
        blit1tilemap <:> blit1tilemap,
        characterGenerator8x8 <:> characterGenerator8x8,
        colourblittilemap <:> colourblittilemap,
        pb_colourmap <:> pb_colourmap,
        bitmap_x_write :> bitmap_x_write, bitmap_y_write :> bitmap_y_write,
        bitmap_colour_write :> bitmap_colour_write, bitmap_colour_write_alt :> bitmap_colour_write_alt,
        bitmap_write :> bitmap_write,
        gpu_active_dithermode :> gpu_active_dithermode,
        pb_mode <: pb_mode, pb_colour <: pb_colour, pb_colour8r <: pb_colour8r, pb_colour8g <: pb_colour8g, pb_colour8b <: pb_colour8b, pb_newpixel <: pb_newpixel,
        gpu_active :> gpu_active
    );

    // QUEUE STORAGE
    uint1   queue_busy = uninitialised;
    int11   queue_x = uninitialised;                int11   queue_y = uninitialised;
    uint8   queue_colour = uninitialised;           uint8   queue_colour_alt = uninitialised;
    int11   queue_param0 = uninitialised;           int11   queue_param1 = uninitialised;
    int11   queue_param2 = uninitialised;           int11   queue_param3 = uninitialised;
    int11   queue_param4 = uninitialised;           int11   queue_param5 = uninitialised;
    uint4   queue_dithermode = uninitialised;
    uint4   queue_write = 0;
    uint9   queue_cropL = uninitialised;            uint8   queue_cropT = uninitialised;
    uint9   queue_cropR = uninitialised;            uint8   queue_cropB = uninitialised;

    GPU.gpu_write := 0; queue_full := vector_block_active | queue_busy ; queue_complete := ~( gpu_active | queue_full );
    bitmap_crop_left := GPU.crop_left; bitmap_crop_right := GPU.crop_right; bitmap_crop_top := GPU.crop_top; bitmap_crop_bottom := GPU.crop_bottom;
    queue_busy := |queue_write;

    algorithm <autorun> {
        while(1) {
            // PUT INTO QUEUE
            if( vector_drawer_gpu_write ) {
                GPU.gpu_colour = vector_block_colour;
                GPU.gpu_x = vector_drawer_gpu_x; GPU.gpu_y = vector_drawer_gpu_y;
                GPU.gpu_param0 = vector_drawer_gpu_param0; GPU.gpu_param1 = vector_drawer_gpu_param1;
                GPU.gpu_param2 = 1;
                GPU.crop_left = crop_left; GPU.crop_right = crop_right; GPU.crop_top = crop_top; GPU.crop_bottom = crop_bottom;
                GPU.gpu_write = 2;
            }
            if( |gpu_write ) {
                queue_dithermode = gpu_dithermode; queue_colour = gpu_colour; queue_colour_alt = gpu_colour_alt; queue_write = gpu_write;
                ( queue_x, queue_y ) = copycoordinates( gpu_x, gpu_y );
                ( queue_param0, queue_param1 ) = copycoordinates( gpu_param0, gpu_param1 );
                ( queue_param2, queue_param3 ) = copycoordinates( gpu_param2, gpu_param3 );
                ( queue_param4, queue_param5 ) = copycoordinates( gpu_param4, gpu_param5 );
                ( queue_cropL, queue_cropR ) = copycoordinates( crop_left, crop_right );
                ( queue_cropT, queue_cropB ) = copycoordinates( crop_top, crop_bottom );
            }
        }
    }

    always_after {
        // PROCESS QUEUE
        if( queue_busy & ~gpu_active ) {
            GPU.gpu_dithermode = queue_dithermode; GPU.gpu_colour = queue_colour; GPU.gpu_colour_alt = queue_colour_alt;
            GPU.gpu_x = queue_x; GPU.gpu_y = queue_y;
            GPU.gpu_param0 = queue_param0; GPU.gpu_param1 = queue_param1;
            GPU.gpu_param2 = queue_param2; GPU.gpu_param3 = queue_param3;
            GPU.crop_left = queue_cropL; GPU.crop_right = queue_cropR; GPU.crop_top = queue_cropT; GPU.crop_bottom = queue_cropB;

            switch( queue_write ) {
                case 0: {}
                case 14: {
                    // SECOND TRIANGLE TO GPU
                    GPU.gpu_param0 = queue_param4; GPU.gpu_param1 = queue_param5;
                    GPU.gpu_write = 6;
                    queue_write = 0;

                }
                case 15: {
                    // QUADRILATERAL, SEND FIRST TRIANGLE TO GPU
                    GPU.gpu_write = 6;
                    queue_write = 14;
                }
                default: {
                    // EVERYTHING ELSE, SEND TO GPU
                    GPU.gpu_write = queue_write;
                    queue_write = 0;
                }
            }
        }
    }
}

unit gpu(
    simple_dualport_bram_port0 blit1tilemap,
    simple_dualport_bram_port0 characterGenerator8x8,
    simple_dualport_bram_port0 colourblittilemap,
    simple_dualport_bram_port0 pb_colourmap,

    // GPU to SET and GET pixels
    output int11   bitmap_x_write,
    output int11   bitmap_y_write,
    output uint8   bitmap_colour_write,
    output uint8   bitmap_colour_write_alt,
    output uint1   bitmap_write,
    output uint4   gpu_active_dithermode,

    input   uint9   crop_left,
    input   uint9   crop_right,
    input   uint8   crop_top,
    input   uint8   crop_bottom,

    input   int11   gpu_x,
    input   int11   gpu_y,
    input   uint8   gpu_colour,
    input   uint8   gpu_colour_alt,
    input   int11   gpu_param0,
    input   int11   gpu_param1,
    input   int11   gpu_param2,
    input   int11   gpu_param3,
    input   int11   gpu_param4,
    input   int11   gpu_param5,
    input   uint4   gpu_write,
    input   uint4   gpu_dithermode,

    input   uint1   pb_mode,
    input   uint8   pb_colour,
    input   uint8   pb_colour8r,
    input   uint8   pb_colour8g,
    input   uint8   pb_colour8b,
    input   uint2   pb_newpixel,

    output  uint1   gpu_active(0),
) <reginputs> {
    // GPU SUBUNITS
    rectangle GPUrectangle(
        crop_left <: crop_left, crop_right <: crop_right, crop_top <: crop_top, crop_bottom <: crop_bottom,
        x <: gpu_x, y <: gpu_y, x1 <: gpu_param0, y1 <: gpu_param1
    );
    line GPUline(
        x <: gpu_x, y <: gpu_y, x1 <: gpu_param0, y1 <: gpu_param1,
        width <: gpu_param2[0,8]
    );
    circle GPUcircle(
        x <: gpu_x, y <: gpu_y, radius <: gpu_param0, sectormask <: gpu_param1
    );
    triangle GPUtriangle(
        crop_left <: crop_left, crop_right <: crop_right, crop_top <: crop_top, crop_bottom <: crop_bottom,
        x <: gpu_x, y <: gpu_y, x1 <: gpu_param0, y1 <: gpu_param1, x2 <: gpu_param2, y2 <: gpu_param3
    );
    blit GPUblit(
        blit1tilemap <:> blit1tilemap,
        characterGenerator8x8 <:> characterGenerator8x8,
        colourblittilemap <:> colourblittilemap,
        x <: gpu_x, y <: gpu_y,
        tile <: gpu_param0[0,9], scale <: gpu_param1[0,2], action <: gpu_param2[0,3]
    );
    pixelblock GPUpixelblock(
        colourmap <:> pb_colourmap,
        x <: gpu_x, y <: gpu_y, width <: gpu_param0,
        ignorecolour <: gpu_param1,
        mode <: pb_mode, colour <: pb_colour,
        colour8r <: pb_colour8r, colour8g <: pb_colour8g, colour8b <: pb_colour8b,
        newpixel <: pb_newpixel
    );

    // GPU UNIT BUSY FLAGS
    uint6   gpu_busy_flags <:: { GPUpixelblock.busy, |GPUblit.busy, GPUtriangle.busy, GPUcircle.busy, GPUrectangle.busy, GPUline.busy };
    uint1   gpu_busy <:: ( |gpu_busy_flags );

    // CONTROLS FOR BITMAP PIXEL WRITER AND GPU SUBUNITS
    bitmap_write := GPUline.bitmap_write | GPUrectangle.bitmap_write | GPUcircle.bitmap_write |
                                    GPUtriangle.bitmap_write | GPUblit.bitmap_write | GPUpixelblock.bitmap_write;

    GPUrectangle.start := 0; GPUline.start := 0; GPUcircle.start := 0; GPUtriangle.start := 0; GPUblit.start := 0; GPUpixelblock.start := 0;
    gpu_active := ( |gpu_write[1,3] ) | gpu_busy;

    algorithm <autorun> {
        while(1) {
            if( |gpu_write ) {
                // START THE GPU DRAWING UNIT - RESET DITHERMODE TO 0 (most common)
                gpu_active_dithermode = 0; bitmap_colour_write = gpu_colour; bitmap_colour_write_alt = gpu_colour_alt;
                GPUcircle.filledcircle = gpu_write[0,1]; GPUblit.tilecharacter = gpu_write[0,1];
                switch( gpu_write ) {
                    default: {}
                    case 1: { ( bitmap_x_write, bitmap_y_write ) = copycoordinates(  gpu_x, gpu_y ); bitmap_write = 1; }
                    case 2: { GPUline.start = 1; }                                                  // DRAW LINE FROM (X,Y) to (PARAM0,PARAM1)
                    case 3: { gpu_active_dithermode = gpu_dithermode; GPUrectangle.start = 1; }     // DRAW RECTANGLE FROM (X,Y) to (PARAM0,PARAM1)
                    case 4: { GPUcircle.start = 1; }                                                // DRAW CIRCLE CENTRE (X,Y) with RADIUS PARAM0
                    case 5: { gpu_active_dithermode = gpu_dithermode; GPUcircle.start = 1; }        // DRAW FILLED CIRCLE CENTRE (X,Y) with RADIUS PARAM0
                    case 6: { gpu_active_dithermode = gpu_dithermode; GPUtriangle.start = 1; }      // DRAW FILLED TRIANGLE WITH VERTICES (X,Y) (PARAM0,PARAM1) (PARAM2,PARAM3)
                    case 7: { GPUblit.start = 1; }                                                  // BLIT 16 x 16 TILE PARAM0 TO (X,Y)
                    case 8: { GPUblit.start = 1; }                                                  // BLIT 8 x 8 CHARACTER PARAM0 TO (X,Y) as 8 x 8
                    case 9: { GPUblit.start = 2; }                                                  // BLIT 16 x 16 COLOUR TILE PARAM0 TO (X,Y) as 16 x 16
                    case 10: { GPUpixelblock.start = 1; }                                           // START THE PIXELBLOCK WRITER AT (x,y) WITH WIDTH PARAM0, IGNORE COLOUR PARAM1
                    // 11
                    // 12
                    // 13
                    // 14
                    // 15 is quadrilateral, handled by the queue
                }
            }
        }
    }

    always_after {
        // COPY OUTPUT TO THE BITMAP WRITER
        if( gpu_busy ) {
            onehot( gpu_busy_flags ) {
                case 0: { ( bitmap_x_write, bitmap_y_write ) = copycoordinates(  GPUline.bitmap_x_write, GPUline.bitmap_y_write ); }
                case 1: { ( bitmap_x_write, bitmap_y_write ) = copycoordinates(  GPUrectangle.bitmap_x_write, GPUrectangle.bitmap_y_write ); }
                case 2: { ( bitmap_x_write, bitmap_y_write ) = copycoordinates(  GPUcircle.bitmap_x_write, GPUcircle.bitmap_y_write ); }
                case 3: { ( bitmap_x_write, bitmap_y_write ) = copycoordinates(  GPUtriangle.bitmap_x_write, GPUtriangle.bitmap_y_write ); }
                case 4: {
                    ( bitmap_x_write, bitmap_y_write ) = copycoordinates(  GPUblit.bitmap_x_write, GPUblit.bitmap_y_write );
                    if( GPUblit.busy[1,1] ) { bitmap_colour_write = GPUblit.bitmap_colour_write; }
                }
                case 5: { ( bitmap_x_write, bitmap_y_write ) = copycoordinates(  GPUpixelblock.bitmap_x_write, GPUpixelblock.bitmap_y_write ); bitmap_colour_write = GPUpixelblock.bitmap_colour_write; }
            }
        }
    }
}

// HELPER - DECIDE IF MIN/MAX ARE WITHIN CROP
unit istodraw(
    input   int11   crop_left,
    input   int11   crop_right,
    input   int11   crop_top,
    input   int11   crop_bottom,
    input   int11   min_x,
    input   int11   min_y,
    input   int11   max_x,
    input   int11   max_y,
    output  uint1   draw
) <reginputs> {
    always_after {
        draw = ~|{ ( max_x < crop_left ), ( max_y < crop_top ), ( min_x > crop_right ), ( min_y > crop_bottom ) };
    }
}

// HELPER - APPLY CROPPING RECTANGLE FOR RECTANGLES AND TRIANGLES
unit applycrop(
    input   int11   crop_left,
    input   int11   crop_right,
    input   int11   crop_top,
    input   int11   crop_bottom,
    input   int11   x1,
    input   int11   y1,
    input   int11   x2,
    input   int11   y2,
    output  int11   min_x,
    output  int11   min_y,
    output  int11   max_x,
    output  int11   max_y
) <reginputs> {
    always_after {
        min_x = ( x1 < crop_left ) ? crop_left : x1;   max_x = ( ( x2 > crop_right ) ? crop_right : x2 );
        min_y = ( y1 < crop_top ) ? crop_top : y1;     max_y = 1 + ( ( y2 > crop_bottom ) ? crop_bottom : y2 );
    }
}

// RECTANGLE - OUTPUT PIXELS TO DRAW A RECTANGLE
unit preprectangle(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint9   crop_left,
    input   uint9   crop_right,
    input   uint8   crop_top,
    input   uint8   crop_bottom,
    input   int11   x,
    input   int11   y,
    input   int11   param0,
    input   int11   param1,
    output  int11   min_x,
    output  int11   min_y,
    output  int11   max_x,
    output  int11   max_y,
    output  uint1   todraw
) <reginputs> {
    uint1   xcompareparam0 <:: ( x < param0 );          uint1   ycompareparam1 <:: ( y < param1 );
    int11   x1 <:: xcompareparam0 ? x : param0;         int11   y1 <:: ycompareparam1 ? y : param1;
    int11   x2 <:: xcompareparam0 ? param0 : x;         int11   y2 <:: ycompareparam1 ? param1 : y;

    applycrop CROP( crop_left <: crop_left, crop_right <: crop_right, crop_top <: crop_top, crop_bottom <: crop_bottom,
                    x1 <: x1, y1 <: y1, x2 <: x2, y2 <: y2, min_x :> min_x, min_y :> min_y, max_x :> max_x, max_y :> max_y );

    istodraw TODRAW( crop_left <: crop_left, crop_right <: crop_right, crop_top <: crop_top, crop_bottom <: crop_bottom,
                min_x <: CROP.min_x, min_y <: CROP.min_y, max_x <: CROP.max_x, max_y <: CROP.max_y );

    todraw := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1;
                ++: ++:
                todraw = TODRAW.draw;
                busy = 0;
            }
        }
    }
}
unit drawrectangle(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint9   min_x,
    input   uint8   min_y,
    input   uint9   max_x,
    input   uint8   max_y,
    output  uint9   bitmap_x_write,
    output  uint8   bitmap_y_write,
    output  uint1   bitmap_write
) <reginputs> {
    uint9   xNEXT <:: bitmap_x_write + 1;
    uint8   yNEXT <:: bitmap_y_write + 1;
    uint1   lineend <:: ( bitmap_x_write == max_x );

    bitmap_write := 0;

    always_after {
        if( start ) {
            busy = 1; bitmap_x_write = min_x; bitmap_y_write = min_y; bitmap_write = 1;     // Output 1st Pixel
        } else {
            if( busy ) {
               if( lineend ) {
                    bitmap_x_write = min_x; bitmap_y_write = yNEXT;
                } else {
                    bitmap_x_write = xNEXT;
                }
                busy = ( bitmap_y_write != max_y ); bitmap_write = busy;                    // Output subsequent pixels
            }
        }
    }
}
unit rectangle (
    input   uint1   start,
    output  uint1   busy(0),
    input   uint9   crop_left,
    input   uint9   crop_right,
    input   uint8   crop_top,
    input   uint8   crop_bottom,
    input   int11   x,
    input   int11   y,
    input   int11   x1,
    input   int11   y1,

    output  uint9   bitmap_x_write,
    output  uint8   bitmap_y_write,
    output  uint1   bitmap_write
) <reginputs> {
    preprectangle PREP(
        start <: start,
        crop_left <: crop_left, crop_right <: crop_right, crop_top <: crop_top, crop_bottom <: crop_bottom,
        x <: x, y <: y, param0 <: x1, param1 <: y1
    );
    drawrectangle RECTANGLE(
        min_x <: PREP.min_x, min_y <: PREP.min_y, max_x <: PREP.max_x, max_y <: PREP.max_y,
        bitmap_x_write :> bitmap_x_write, bitmap_y_write :> bitmap_y_write, bitmap_write :> bitmap_write,
        start <: PREP.todraw
    );

    busy := start | PREP.busy | PREP.todraw | RECTANGLE.busy;
}

// LINE - OUTPUT PIXELS TO DRAW A LINE
unit prepline(
    input   uint1   start,
    output  uint1   todraw,
    input   int11   x,
    input   int11   y,
    input   int11   param0,
    input   int11   param1,
    output  int11   x1,
    output  int11   y1,
    output  int11   dx,
    output  int11   dy,
    output  uint1   dv,
    output  int11   numerator,
    output  int11   max_count
) <reginputs> {
    uint1 ylessparam1 <:: ( y < param1 );

    todraw := 0;

    always_after {
        if( start ) {
            // Setup drawing a line from x,y to param0,param1 of width param2 in colour
            // Ensure LEFT to RIGHT AND if moving UP or DOWN
            if( x < param0 ) { x1 = x; y1 = y; dv = ylessparam1; } else { x1 = param0; y1 = param1; dv = ~ylessparam1; }

            // Absolute DELTAs
            ( dx ) = absdelta( x, param0 ); ( dy ) = absdelta( y, param1 );

            // Numerator
            if( dx > dy ) { numerator = ( dx >> 1 ); max_count = dx + 1; } else { numerator = -( dy >> 1 ); max_count = dy + 1; }

            todraw = 1;
        }
    }
}
unit drawline(
    input   uint1   start,
    output  uint1   busy(0),
    input   int11   start_x,
    input   int11   start_y,
    input   int11   start_numerator,
    input   int11   dx,
    input   int11   dy,
    input   uint1   dv,
    input   int11   max_count,
    input   uint8   width,
    output  int11   bitmap_x_write,
    output  int11   bitmap_y_write,
    output  uint1   bitmap_write
) <reginputs> {
    int11   x = uninitialized;                          int11   xNEXT <:: x + n2dx;
    int11   y = uninitialized;                          int11   yNEXT <:: n2dy ? (y + ( dv ? 1 : -1 )) : y;
    int11   numerator = uninitialized;
    int11   numerator2 <:: numerator;                   int11   newnumerator <:: numerator - ( n2dx ? dy : 0 ) + ( n2dy ? dx : 0 );
    uint1   n2dx <:: numerator2 > (-dx);                uint1   n2dy <:: numerator2 < dy;
    uint1   dxdy <:: dx > dy;
    int11   count = uninitialized;                      int11   countNEXT <:: count + 1;
    uint1   working <:: ( count != max_count );
    int11   offset_x = uninitialised;                   int11   offset_xNEXT <:: offset_y + dxdy;
    int11   offset_y = uninitialised;                   int11   offset_yNEXT <:: offset_x + ~dxdy;
    int11   offset_start <:: -( width >> 1 );
    uint8   pixel_count = uninitialised;                uint8   pixel_countNEXT <:: pixel_count + 1;
    uint1   singlepixel <:: ( width == 1 );             uint1   morepixels <:: ( pixel_count != width );

    bitmap_write := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1;  x = start_x; y = start_y; numerator = start_numerator; count = 0; offset_x = 0; offset_y = 0;
                while( working ) {
                    if( singlepixel ) {
                        bitmap_write = 1;
                    } else {
                        pixel_count = 0; offset_x = dxdy ? 0 : offset_start; offset_y = dxdy ? offset_start : 0;
                        while( morepixels ) {
                            bitmap_write = 1; offset_y = offset_xNEXT; offset_x = offset_yNEXT; pixel_count = pixel_countNEXT;
                        }
                    }
                    numerator = newnumerator; x = xNEXT; y = yNEXT; count = countNEXT;
                }
                busy = 0;
            }
        }
    }

    always_after {
        bitmap_x_write = x + offset_x; bitmap_y_write = y + offset_y;
    }
}
unit line(
    input   uint1   start,
    output  uint1   busy(0),
    input   int11   x,
    input   int11   y,
    input   int11   x1,
    input   int11   y1,
    input   uint8   width,
    output  int11   bitmap_x_write,
    output  int11   bitmap_y_write,
    output  uint1   bitmap_write
) <reginputs> {
    prepline PREP(
        start <: start,
        x <: x, y <: y, param0 <: x1, param1 <: y1
    );
    drawline LINE(
        start_x <: PREP.x1, start_y <: PREP.y1,
        start_numerator <: PREP.numerator,
        dx <: PREP.dx, dy <: PREP.dy, dv <: PREP.dv,
        max_count <: PREP.max_count, width <: width,
        bitmap_x_write :> bitmap_x_write, bitmap_y_write :> bitmap_y_write,
        bitmap_write :> bitmap_write,
        start <: PREP.todraw
    );
    busy := start | PREP.todraw | LINE.busy;
}

//  CIRCLE - OUTPUT PIXELS TO DRAW AN OUTLINE OR FILLED CIRCLE
unit arccoords(
    input   int11   xc,
    input   int11   yc,
    input   int11   active_x,
    input   int11   count,
    input   uint3   arc,
    output  int11   bitmap_x_write,
    output  int11   bitmap_y_write,
    output  uint1   centrepixel
) <reginputs> {
    // PLUS OR MINUS OFFSETS
    int11   xcpax <:: xc + active_x;                int11   xcpc <:: xc + count;
    int11   xcmax <:: xc - active_x;                int11   xcmc <:: xc - count;
    int11   ycpax <:: yc + active_x;                int11   ycpc <:: yc + count;
    int11   ycmax <:: yc - active_x;                int11   ycmc <:: yc - count;

    always_after {
        switch( arc ) {
            case 0: { bitmap_x_write = xcpax; bitmap_y_write = ycpc; }
            case 1: { bitmap_y_write = ycmc; }
            case 2: { bitmap_x_write = xcmax; }
            case 3: { bitmap_y_write = ycpc; }
            case 4: { bitmap_x_write = xcpc; bitmap_y_write = ycpax; }
            case 5: { bitmap_y_write = ycmax; }
            case 6: { bitmap_x_write = xcmc; }
            case 7: { bitmap_y_write = ycpax; }
        }
        centrepixel = ( ~|count & ~|active_x );
    }
}
unit drawcircle(
    input   uint1   start,
    output  uint1   busy(0),
    input   int11   xc,
    input   int11   yc,
    input   int11   radius,
    input   int11   start_numerator,
    input   uint8   draw_sectors,
    input   uint1   filledcircle,
    output  int11   bitmap_x_write,
    output  int11   bitmap_y_write,
    output  uint1   bitmap_write
) <reginputs> {
    int11   numerator = uninitialised;                  int11   new_numerator <:: numerator[10,1] ? numerator + { active_x, 2b00 } + 6 : numerator + { (active_x - active_y), 2b00 } + 10;
    uint1   positivenumerator <:: ~numerator[10,1] & ( |numerator );
    int11   active_x = uninitialized;                   int11   active_xNEXT <:: active_x + 1;
    int11   active_y = uninitialized;                   int11   active_yNEXT <:: active_y - positivenumerator;
    int11   count = uninitialised;                      int11   countNEXT <:: filledcircle ? count - 1 : min_count;
    int11   min_count = uninitialised;                  int11   min_countNEXT <:: min_count + 1;
    uint1   drawingcircle <:: ( active_y >= active_x ); uint1   finishsegment <:: ( countNEXT == min_count );

    uint4   arc = uninitialised;                        uint4   arcNEXT <:: arc + 1;
    arccoords ARC( xc <: xc, yc <: yc, active_x <: active_x, count <: count, arc <: arc );

    bitmap_write := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1;
                active_x = 0; active_y = radius; count = radius; min_count = (-1); numerator = start_numerator;
                while( drawingcircle ) {
                    if( ARC.centrepixel ) {
                        // DETECT IF CENTRE PIXEL, OUTPUT ONCE
                        bitmap_write = |draw_sectors;
                    } else {
                        arc = 0; while( ~arc[3,1] ) {
                            // OUTPUT PIXELS IN THE 8 SEGMENTS/ARCS AS PER MASK
                            bitmap_write = draw_sectors[arc,1]; arc = arcNEXT;
                        }
                    }
                    if( finishsegment ) {
                        active_x = active_xNEXT; active_y = active_yNEXT; count = active_y; min_count = min_countNEXT; numerator = new_numerator;
                    } else {
                        count = countNEXT;
                    }
                }
                busy = 0;
            }
        }
    }

    always_after {
        bitmap_x_write = ARC.centrepixel ? xc : ARC.bitmap_x_write; bitmap_y_write = ARC.centrepixel ? yc : ARC.bitmap_y_write;
    }
}
unit circle(
    input   uint1   start,
    output  uint1   busy(0),
    input   int11   x,
    input   int11   y,
    input   int11   radius,
    input   uint8   sectormask,
    input   uint1   filledcircle,

    output  int11  bitmap_x_write,
    output  int11  bitmap_y_write,
    output  uint1  bitmap_write
) <reginputs> {
    int11   absradius <:: radius[10,1] ? -radius : radius;
    int11   gpu_numerator <:: 3 - ( { absradius, 1b0 } );

    drawcircle CIRCLE(
        xc <: x, yc <: y,
        radius <: absradius,
        start_numerator <: gpu_numerator,
        filledcircle <: filledcircle,
        bitmap_x_write :> bitmap_x_write, bitmap_y_write :> bitmap_y_write, bitmap_write :> bitmap_write,
        start <: start
    );
    CIRCLE.draw_sectors := { sectormask[5,1], sectormask[6,1], sectormask[1,1], sectormask[2,1], sectormask[4,1], sectormask[7,1], sectormask[0,1], sectormask[3,1] };
    busy := start | CIRCLE.busy;
}

// TRIANGLE - OUTPUT PIXELS TO DRAW A FILLED TRIANGLE
unit swaponcondition(
    input   int11   x1,
    input   int11   x2,
    input   int11   y1,
    input   int11   y2,
    input   uint1   condition,
    output  int11   nx1,
    output  int11   nx2,
    output  int11   ny1,
    output  int11   ny2
) <reginputs> {
    always_after {
        if( condition ) {
            nx1 = x2; ny1 = y2;
            nx2 = x1; ny2 = y1;
        } else {
            nx1 = x1; ny1 = y1;
            nx2 = x2; ny2 = y2;
        }
    }
}
unit min3(
    input   int11   n1,
    input   int11   n2,
    input   int11   n3,
    output  int11   min
) <reginputs> {
    always_after {
        min = ( n1 < n2 ) ? ( ( n1 < n3 ) ? n1 : n3 ) : ( ( n2 < n3 ) ? n2 : n3 );
    }
}
unit max3(
    input   int11   n1,
    input   int11   n2,
    input   int11   n3,
    output  int11   max
) <reginputs> {
    always_after {
        max = ( n1 > n2 ) ? ( ( n1 > n3 ) ? n1 : n3 ) : ( ( n2 > n3 ) ? n2 : n3 );
    }
}
unit preptriangle(
    input   uint1   start,
    output  uint1   busy(0),
    input   int11   crop_left,
    input   int11   crop_right,
    input   int11   crop_top,
    input   int11   crop_bottom,
    input   int11   x,
    input   int11   y,
    input   int11   param0,
    input   int11   param1,
    input   int11   param2,
    input   int11   param3,
    output  int11   x1,
    output  int11   y1,
    output  int11   x2,
    output  int11   y2,
    output  int11   x3,
    output  int11   y3,
    output  uint9   min_x,
    output  uint8   min_y,
    output  uint9   max_x,
    output  uint8   max_y,
    output  uint1   todraw
) <reginputs> {
    swaponcondition SWAP1( x1 <: param0, y1 <: param1, x2 <: param2, y2 <: param3 );                                                            // -> ( x2, y2 ) and ( x3, y3 )
    swaponcondition SWAP2( x1 <: x, y1 <: y, x2 <: SWAP1.nx1, y2 <: SWAP1.ny1 );                                                                // -> ( x1, y1 ) and ( x2, y2 )
    swaponcondition SWAP3( x1 <: SWAP2.nx1, y1 <: SWAP2.ny1, x2 <: SWAP1.nx2, y2 <: SWAP1.ny2 );                                                // -> ( x1, y1 ) and ( x3, y3 )
    swaponcondition SWAP4( x1 <: SWAP2.nx2, y1 <: SWAP2.ny2, x2 <: SWAP3.nx2, y2 <: SWAP3.ny2 );                                                // -> ( x2, y2 ) and ( x3, y3 )
    swaponcondition SWAP5( x1 <: SWAP3.nx1, y1 <: SWAP3.ny1, x2 <: SWAP4.nx1, y2 <: SWAP4.ny1, nx1 :> x1, ny1 :> y1 );                          // -> ( x1, y1 ) and ( x2, y2 )
    swaponcondition SWAP6( x1 <: SWAP5.nx2, y1 <: SWAP5.ny2, x2 <: SWAP4.nx2, y2 <: SWAP4.ny2, nx1 :> x2, ny1 :> y2, nx2 :> x3, ny2 :> y3 );    // -> ( x2, y2 ) and ( x3, y3 )

    // Find minimum and maximum of x, x1, x2, y, y1 and y2 for the bounding box
    min3 Xmin( n1 <: x1, n2 <: x2, n3 <: x3 );      min3 Ymin( n1 <: y1, n2 <: y2, n3 <: y3 );
    max3 Xmax( n1 <: x1, n2 <: x2, n3 <: x3 );      max3 Ymax( n1 <: y1, n2 <: y2, n3 <: y3 );

    applycrop CROP( crop_left <: crop_left, crop_right <: crop_right, crop_top <: crop_top, crop_bottom <: crop_bottom,
                    x1 <: Xmin.min, y1 <: Ymin.min, x2 <: Xmax.max, y2 <: Ymax.max, min_x :> min_x, min_y :> min_y, max_x :> max_x, max_y :> max_y );

    istodraw TODRAW( crop_left <: crop_left, crop_right <: crop_right, crop_top <: crop_top, crop_bottom <: crop_bottom,
                min_x <: CROP.min_x, min_y <: CROP.min_y, max_x <: CROP.max_x, max_y <: CROP.max_y );

    todraw := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1;
                // Setup drawing a filled triangle x,y param0, param1, param2, param3
                // Allow the cascade for the coordinates
                ++: ++: ++: ++: ++: ++: ++:
                todraw = TODRAW.draw;
                busy = 0;
            }
        }
    }

    always_after {
        SWAP1.condition = ( param3 < param1 );                                                                                                  // ( y3 < y2 )
        SWAP2.condition = ( SWAP1.ny1 < y );                                                                                                    // ( y2 < y1 )
        SWAP3.condition = ( SWAP1.ny2 < SWAP2.ny1 );                                                                                            // ( y3 < y1 )
        SWAP4.condition = ( SWAP3.ny2 < SWAP2.ny2 );                                                                                            // ( y3 < y2 )
        SWAP5.condition = ( SWAP4.ny1 == SWAP3.ny1 ) & ( SWAP4.nx1 < SWAP3.nx1 ) ;                                                              // ( y2 == y1 ) & ( x2 < x1 )
        SWAP6.condition = ( ( SWAP5.ny2 != SWAP5.ny1 ) & ( SWAP4.ny2 >= SWAP5.ny2 ) & ( SWAP5.nx2 < SWAP4.nx2 ) );                              // ( y2 != y1 ) & ( y3 >= y2 ) & ( x2 < x3 )
    }
}
unit intriangle(
    input   int11   x0,
    input   int11   y0,
    input   int11   x1,
    input   int11   y1,
    input   int11   x2,
    input   int11   y2,
    input   int11   px,
    input   int11   py,
    output  uint1   IN
) <reginputs> {
    int22   step1 <:: (( x2 - x1 ) * ( py - y1 ) - ( y2 - y1 ) * ( px - x1 ));
    int22   step2 <:: (( x0 - x2 ) * ( py - y2 ) - ( y0 - y2 ) * ( px - x2 ));
    int22   step3 <:: (( x1 - x0 ) * ( py - y0 ) - ( y1 - y0 ) * ( px - x0 ));

    always_after {
        IN =  ~|{ step1[21,1], step2[21,1], step3[21,1] };
    }
}
unit drawtriangle(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint9   min_x,
    input   uint8   min_y,
    input   uint9   max_x,
    input   uint8   max_y,
    input   int11   x0,
    input   int11   y0,
    input   int11   x1,
    input   int11   y1,
    input   int11   x2,
    input   int11   y2,
    output  uint9   bitmap_x_write,
    output  uint8   bitmap_y_write,
    output  uint1   bitmap_write
) <reginputs> {
    // Filled triangle calculations
    // Is the point px,py inside the triangle given by x0,x1 x1,y1 x2,y2?
    intriangle IS( x0 <: x0, x1 <: x1, x2 <: x2, px <: px, y0 <: y0, y1 <: y1, y2 <: y2, py <: py );
    uint1   beenInTriangle = uninitialized;

    // CLOSER TO LEFT OR RIGHT OF THE BOUNDING BOX
    uint1   leftright <:: ( px - min_x ) < ( max_x - px );

    // WORK COORDINATES AND DIRECTION
    uint9   px = uninitialized;
    uint8   py = uninitialized;                         uint8   pyNEXT <:: py + 1;
    uint1   dx = uninitialized;

    // DETECT IF AT LEFT/RIGHT/BOTTOM OF THE BOUNDING BOX
    uint1   stillinline <:: ( dx & ( px != max_x ) ) | ( ~dx & ( px != min_x ));
    uint1   working <:: ( py != max_y );

    bitmap_x_write := px; bitmap_y_write := py; bitmap_write := busy & IS.IN;

    always_after {
        if( start ) {
            busy = 1; dx = 1; px = min_x; py = min_y;
        } else {
            if( working ) {
                beenInTriangle = IS.IN | beenInTriangle;
                if( beenInTriangle ^ IS.IN ) {
                    // Exited the triangle, move to the next line
                    beenInTriangle = 0; py = pyNEXT; px = leftright ? min_x : max_x; dx = leftright;
                } else {
                    // MOVE TO THE NEXT PIXEL ON THE LINE LEFT/RIGHT OR DOWN AND SWITCH DIRECTION IF AT END
                    if( stillinline ) { px = px + ( dx ? 1 : (-1) ); } else { dx = ~dx; beenInTriangle = 0; py = pyNEXT; }
                }
            } else {
                busy = 0;
            }
        }
    }
}
unit triangle(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint9   crop_left,
    input   uint9   crop_right,
    input   uint8   crop_top,
    input   uint8   crop_bottom,
    input   int11   x,
    input   int11   y,
    input   int11   x1,
    input   int11   y1,
    input   int11   x2,
    input   int11   y2,
    output  uint9   bitmap_x_write,
    output  uint8   bitmap_y_write,
    output  uint1   bitmap_write
) <reginputs> {
    // VERTEX COORDINATES AND BOUNDING BOX
    preptriangle PREP(
        start <: start,
        crop_left <: crop_left, crop_right <: crop_right, crop_top <: crop_top, crop_bottom <: crop_bottom,
        x <: x, y <: y, param0 <: x1, param1 <: y1, param2 <: x2, param3 <: y2
    );

    uint1   TRIANGLEbusy = uninitialised;
    drawtriangle TRIANGLE(
        min_x <: PREP.min_x, max_x <: PREP.max_x, min_y <: PREP.min_y, max_y <: PREP.max_y,
        x0 <: PREP.x1, y0 <: PREP.y1, x1 <: PREP.x2, y1 <: PREP.y2, x2 <: PREP.x3, y2 <: PREP.y3,
        bitmap_x_write :> bitmap_x_write, bitmap_y_write :> bitmap_y_write, bitmap_write :> bitmap_write,
        start <: PREP.todraw
    );

    busy := start | PREP.busy | PREP.todraw | TRIANGLE.busy;
}

// BLIT - ( tilecharacter == 0 ) OUTPUT PIXELS TO BLIT AN 8 x 8 CHARACTER ( PARAM1 == 0 as 8 x 8, == 1 as 16 x 16, == 2 as 32 x 32, == 3 as 64 x 64 )
// COLOURBLIT - OUTPUT PIXELS TO BLIT A 16 x 16 TILE ( PARAM1 == 0 as 16 x 16, == 1 as 32 x 32, == 2 as 64 x 64, == 3 as 128 x 128 )
unit blitscale(
    input   uint7   offset,
    input   uint2   scale,
    output  uint7   base,
    output  int11   scaled
) <reginputs> {
    always_after {
        base = offset; scaled = offset << scale;
    }
}
unit   blittilexy(
    input   uint7   px,
    input   uint7   py,
    input   uint3   action,
    output  uint4   xinblittile,
    output  uint3   xinchartile,
    output  uint4   yinblittile,
    output  uint3   yinchartile
) <reginputs> {
    uint4   revx4 <:: ~px[0,4];                      uint4   revy4 <:: ~py[0,4];
    uint3   revx3 <:: ~px[0,3];                      uint3   revy3 <:: ~py[0,3];
    uint1   action00 <:: ( ~|action[0,2] );          uint1   action01 <:: ( action[0,2] == 2b01 );        uint1   action10 <:: ( action[0,2] == 2b10 );

    // find y and x positions within the tile/character bitmap handling rotation or reflection
    always_after {
        xinblittile = ( action[2,1] ?  action00 ? revx4 : action01 ? py[0,4] : action10 ? px[0,4] : revy4 : action[0,1] ? px[0,4] : revx4 );
        yinblittile = action[2,1] ? action00 ? py[0,4] : action01 ? px[0,4] : action10 ? revy4 : revx4 : action[1,1] ? revy4 :  py[0,4];
        xinchartile = ( action[2,1] ? action00 ? revx3 : action01 ? py[0,3] : action10 ? px[0,3] : revy3 : action[0,1] ?  px[0,3] : revx3 );
        yinchartile = action[2,1] ? action00 ? py[0,3] : action01 ? px[0,3] : action10 ? revy3 : revx3 : action[1,1] ? revy3 :  py[0,3];
    }
}
unit cololurblittilexy(
    input   uint7   px,
    input   uint7   py,
    input   uint3   action,
    output  uint4   xintile,
    output  uint4   yintile
) <reginputs> {
    uint4   revx <:: ~px[0,4];                       uint4   revy <:: ~py[0,4];
    uint1   action00 <:: ( ~|action[0,2] );          uint1   action01 <:: ( action[0,2] == 2b01 );        uint1   action10 <:: ( action[0,2] == 2b10 );

    // find y and x positions within the tile bitmap handling rotation or reflection
    always_after {
        xintile = action[2,1] ? action00 ? px[0,4] : action01 ? revy : action10 ? revx : py[0,4] : action[0,1] ? revx :  px[0,4];
        yintile = action[2,1] ? action00 ? py[0,4] : action01 ? px[0,4] : action10 ? revy : revx : action[1,1] ? revy :  py[0,4];
    }
}
unit blit(
    input   uint2   start,
    output  uint2   busy(0),
    simple_dualport_bram_port0 blit1tilemap,
    simple_dualport_bram_port0 characterGenerator8x8,
    simple_dualport_bram_port0 colourblittilemap,

    input   int11   x,
    input   int11   y,
    input   uint9   tile,
    input   uint2   scale,
    input   uint3   action,

    output  int11   bitmap_x_write,
    output  int11   bitmap_y_write,
    output  uint1   bitmap_write,
    output  uint8   bitmap_colour_write,

    input   uint1   tilecharacter
) <reginputs> {
    // START POSITION ON THE SCREEN, POSITION IN TILE/CHARACTER AND PIXEL COUNT FOR SCALING
    uint4   x2 = uninitialised;                         int11   x2NEXT <:: x2 + 1;                      uint1   x2working <:: x2 != max_count;
    uint4   y2 = uninitialised;                         int11   y2NEXT <:: y2 + 1;                      uint1   y2working <:: y2 != max_count;
    blitscale PXS( scale <: scale );                    int11   pxNEXT <:: PXS.base + 1;                uint1   pxworking <:: PXS.offset != max_pixels;
    blitscale PYS( scale <: scale );                    int11   pyNEXT <:: PYS.base + 1;                uint1   pyworking <:: PYS.offset != max_pixels;

    // MAX PIXELS IN TILE AND NUMBER OF TIMES TO USE EACH PIXEL
    uint5   max_pixels <:: tilecharacter ? 16 : 8;       uint4   max_count <:: ( 1 << scale );

    // FIND X AND Y WITHIN THE TILE/CHARACTER BITMAP
    blittilexy BTXY( px <: PXS.base, py <: PYS.base, action <: action );
    cololurblittilexy CBTXY( px <: PXS.base, py <: PYS.base, action <: action );

    blit1tilemap.addr0 := { tile, BTXY.yinblittile }; characterGenerator8x8.addr0 := { tile, BTXY.yinchartile }; colourblittilemap.addr0 := { tile, CBTXY.yintile, CBTXY.xintile };
    bitmap_write := 0;

    algorithm <autorun> {
        while(1) {
            if( |start ) {
                busy = start;
                PYS.offset = 0;
                while( pyworking ) {
                    PXS.offset = 0;
                    while( pxworking ) {
                        y2 = 0;
                        while( y2working ) {
                            x2 = 0;
                            while( x2working ) {
                                onehot( busy ) {
                                    case 0: { bitmap_write = tilecharacter ? blit1tilemap.rdata0[BTXY.xinblittile, 1] : characterGenerator8x8.rdata0[BTXY.xinchartile, 1]; }
                                    case 1: { bitmap_write = colourblittilemap.rdata0 != 64; }
                                }
                                x2 = x2NEXT;
                            }
                            y2 = y2NEXT;
                        }
                        PXS.offset = pxNEXT;
                    }
                    PYS.offset = pyNEXT;
                }
                busy = 0;
            }
        }
    }

    always_after {
        bitmap_x_write = x + PXS.scaled + x2; bitmap_y_write = y + PYS.scaled + y2; bitmap_colour_write = colourblittilemap.rdata0;
    }
}

// PIXELBLOCK - OUTPUT PIXELS TO RECTANGLE START AT X, Y WITH WIDTH PARAM0, PIXELS PROVIDED SEQUENTIALLY BY CPU, MOVE ALONG RECTANGLE UNTIL STOP RECEIVED
// CAN HANDLE 7bit ( ARRGGBB ) colours, with one defined as transparent or 24bit RGB colours, scaling to the PAWS colour map
unit pixelblock(
    input   uint1   start,
    output  uint1   busy(0),
    simple_dualport_bram_port0 colourmap,

    input   int11   x,
    input   int11   y,
    input   int11   width,
    input   uint8   ignorecolour,

    input   uint1   mode,
    input   uint8   colour,
    input   uint8   colour8r,
    input   uint8   colour8g,
    input   uint8   colour8b,
    input   uint2   newpixel,

    output  int11   bitmap_x_write,
    output  int11   bitmap_y_write,
    output  uint8   bitmap_colour_write,
    output  uint1   bitmap_write
) <reginputs> {
    uint8   rrrgggbb <:: { colour8r[5,3], colour8g[5,3], colour8b[6,2] };                  uint8   grey <:: ( ( colour8r + colour8g + colour8b ) * 341 ) >> 10;
    uint1   update = uninitialised;                 uint2   toprocess = uninitialised;

    int11   xNEXT <:: bitmap_x_write + 1;
    int11   yNEXT <:: bitmap_y_write + 1;
    uint1   lineend <:: ( bitmap_x_write == ( x + width - 1) );

    // LOOKUP THE COLOUR FROM THE REMAPPER
    colourmap.addr0 := colour;

    bitmap_colour_write := ( toprocess == 1 ) ? mode ? colourmap.rdata0 : colour : mode ? ( grey == 64 ) ? 65 : grey : ( rrrgggbb == 64 ) ? 32 : rrrgggbb; bitmap_write := 0;

    always_before {
        if( reset ) { busy = 0; }
    }

    always_after {
        if( start ) {
            busy = 1; bitmap_x_write = x; bitmap_y_write = y;
        } else {
            if( busy ) {
                if( update ) {
                    if( lineend ) {
                        bitmap_x_write = x; bitmap_y_write = yNEXT;
                    } else {
                        bitmap_x_write = xNEXT;
                    }
                    update = 0;
                }
                if( |toprocess ) {
                    if( &toprocess ) {
                        busy = 0;
                    } else {
                        bitmap_write = ( ( toprocess == 1 ) & ( colour != ignorecolour ) ) | ( toprocess == 2 );
                        update = 1;
                    }
                }
                toprocess = newpixel;
            }
        }
    }
}

// Vector Block
// Stores blocks of upto 16 vertices which can be sent to the GPU for line drawing
// Each vertices represents a delta from the centre of the vector
// Deltas are stored as 6 bit 2's complement range -31 to 0 to 31
// Each vertices has an active flag, processing of a vector block stops when the active flag is 0
// Each vector block has a centre x and y coordinate and a colour { rrggbb } when drawn

// SCALE A DELTA USING THE SCALE ATTRIBUTE
unit scaledetla(
    input   uint3   scale,
    input   uint6   delta,
    output  int11   scaled
) <reginputs> {
    // SIGN EXTEND THE DELTA, THEN SCALE
    int11   extdelta <:: { {11{delta[5,1]}}, delta };

    always_after {
        scaled = ( scale[2,1] ? ( __signed(extdelta) >>> scale[0,2] ) : ( extdelta << scale[0,2] ) );
    }
}
unit cpm(
    input   int11   xc,
    input   uint6   dx,
    input   int11   yc,
    input   uint6   dy,
    input   uint3   scale,
    output  int11   xcpdx,
    output  int11   xcndx,
    output  int11   ycpdy,
    output  int11   ycndy,
    output  int11   xcpdy,
    output  int11   xcndy,
    output  int11   ycpdx,
    output  int11   ycndx,
) <reginputs> {
    // SIGN EXTEND DELTAS AND APPLY SCALE
    scaledetla SDX( scale <: scale, delta <: dx ); scaledetla SDY( scale <: scale, delta <: dy );

    // PLUS OR MINUS SCALE
    always_after {
        xcpdx = xc + SDX.scaled;                       xcndx = xc - SDX.scaled;
        ycpdy = yc + SDY.scaled;                       ycndy = yc - SDY.scaled;
        xcpdy = xc + SDY.scaled;                       xcndy = xc - SDY.scaled;
        ycpdx = yc + SDX.scaled;                       ycndx = yc - SDX.scaled;
    }
}
// ADJUST COORDINATES BY DELTAS AND SCALE
unit centreplusdelta(
    input   int11   xc,
    input   uint6   dx,
    input   int11   yc,
    input   uint6   dy,
    input   uint3   scale,
    input   uint3   action,
    output  int11   xdx,
    output  int11   ydy
) <reginputs> {
    cpm CPM( xc <: xc, yc <: yc, dx <: dx, dy <: dy, scale <: scale );

    always_after {
        if( action[2,1] ) {
            // ROTATION
            switch( action[0,2] ) {
                case 0: { xdx = CPM.xcpdx; ydy = CPM.ycpdy; }
                case 1: { xdx = CPM.xcndy; ydy = CPM.ycpdx; }
                case 2: { xdx = CPM.xcndx; ydy = CPM.ycndy; }
                case 3: { xdx = CPM.xcpdy; ydy = CPM.ycndx; }
            }
        } else {
            // REFLECTION
            xdx = action[0,1] ? CPM.xcndx : CPM.xcpdx;
            ydy = action[1,1] ? CPM.ycndy : CPM.ycpdy;
        }
    }
}
unit vectors(
    simple_dualport_bram_port0 vertex,
    input   uint6   vector_block_number,
    input   int11   vector_block_xc,
    input   int11   vector_block_yc,
    input   uint3   vector_block_scale,
    input   uint3   vector_block_action,
    input   uint1   draw_vector,
    output  uint1   vector_block_active(0),

    // Communication with the GPU
    output  int11   gpu_x,
    output  int11   gpu_y,
    output  int11   gpu_param0,
    output  int11   gpu_param1,
    output  uint1   gpu_write,
    input   uint1   gpu_active
) <reginputs> {
    // Add deltas to the centres
    centreplusdelta CENTREPLUSDELTA(
        xc <: vector_block_xc, yc <: vector_block_yc,
        dx <: vectorentry(vertex.rdata0).dx, dy <: vectorentry(vertex.rdata0).dy,
        scale <: vector_block_scale, action <: vector_block_action,
        xdx :> gpu_param0, ydy :> gpu_param1
    );

    // Vertices being processed, plus first coordinate of each line
    uint4   vertex = uninitialised;                     uint4   vertexNEXT <:: vertex + 1;
    uint1   working <:: vectorentry(vertex.rdata0).active & ( |vertex );

    // Set read address for the vertices
    vertex.addr0 := { vector_block_number, vertex };

    gpu_write := 0;

    algorithm <autorun> {
        while(1) {
            if( draw_vector ) {
                vector_block_active = 1; vertex = 1;
                ( gpu_x, gpu_y ) = copycoordinates( gpu_param0, gpu_param1 );       // Copy vertex 0 to line start x,y
                while( working ) {                                                  // Continue until an inactive or last vertex
                    ++:
                    while( gpu_active ) {} gpu_write = 1;                           // Dispatch line to GPU
                    ++:
                    ( gpu_x, gpu_y ) = copycoordinates( gpu_param0, gpu_param1 );   // Copy line end to line start and move onto the next vertex
                    vertex = vertexNEXT;
                }
                vector_block_active = 0;
            } else {
                vertex = 0;
            }
        }
    }
}
