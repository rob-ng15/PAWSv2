// FMIN.S FMAX.S FSGNJ.S FSGNJN.S FSGNJX.S FEQ.S FLT.S FLE.S FCLASS.S FMV.X.W
unit fpuSINGLECYCLE(
    input   uint1   df,
    input   uint2   function3,
    input   uint5   function7,
    input   uint64  sourceReg1,
    input   uint64  sourceReg1F,
    input   uint64  sourceReg2F,
    input   uint4   typeAF,
    input   uint4   typeBF,

    output  uint64  result,
    output  uint1   frd,
    input   uint5   FPUflags,
    output  uint5   FPUnewflags
) <reginputs> {
    floatcompare FPUlteq( df <: df, a <: sourceReg1F, b <: sourceReg2F, typeAF <: typeAF, typeBF <: typeBF );

    uint1   NAN <:: |( typeAF[1,2] | typeBF[1,2] );
    uint1   TRUEZERO <:: ~|( df ? fp64( sourceReg1F ).fraction : fp32( sourceReg1F ).fraction );
    uint3   LTEQ <:: { FPUlteq.equal, FPUlteq.less, FPUlteq.less | FPUlteq.equal };

    uint1   sign1F <:: df ? fp64( sourceReg1F ).sign : fp32( sourceReg1F ).sign;
    uint1   sign2F <:: df ? fp64( sourceReg2F ).sign : fp32( sourceReg2F ).sign;

    uint64  qNAN <:: df ? 64h7FF8000000000000 : 32h7fc00000;

    uint10  FCLASS <:: {    typeAF[1,1],                                                                          // 512  qNAN
                            typeAF[2,1],                                                                          // 256  sNAN
                            typeAF[3,1] & ~sign1F,                                                                // 128  +INF
                            ~|typeAF & ~sign1F,                                                                   // 64   +NORMAL
                            typeAF[0,1] & ~sign1F & ~TRUEZERO,                                                    // 32   +SUBNORMAL
                            typeAF[0,1] & ~sign1F & TRUEZERO,                                                     // 16   +0
                            typeAF[0,1] & sign1F & TRUEZERO,                                                      // 8    -0
                            typeAF[0,1] & sign1F & ~TRUEZERO,                                                     // 4    -SUBNORMAL
                            ~|typeAF & sign1F,                                                                    // 2    -NORMAL
                            typeAF[3,1] & sign1F                                                                  // 1    -INF
            };
    uint64  MINMAX <:: df ? NAN ? qNAN : typeAF[1,1] ? ( typeBF[1,1] ? qNAN : sourceReg2F ) : typeBF[1,1] | ( function3[0,1] ^ FPUlteq.less ) ? sourceReg1F : sourceReg2F :
                            { 32hffffffff, NAN ? qNAN[0,32] : typeAF[1,1] ? ( typeBF[1,1] ? qNAN[0,32] : sourceReg2F[0,32] ) :
                                                              typeBF[1,1] | ( function3[0,1] ^ FPUlteq.less ) ? sourceReg1F[0,32] : sourceReg2F[0,32] };

    uint5   flagsMINMAX <:: { NAN, 4b0000 };
    uint1   COMPARE <:: ~NAN & LTEQ[ function3, 1 ];
    uint5   flagsCOMPARE <:: { function3[1,1] ? ( typeAF[2,1] | typeBF[2,1] ) : NAN, 4b0000 };
    uint64  SIGN <:: df ? { function3[1,1] ? sign1F ^ sign2F : function3[0,1] ^ sign2F, sourceReg1F[0,63] } :
                          { 32hffffffff, function3[1,1] ? sign1F ^ sign2F: function3[0,1] ^ sign2F, sourceReg1F[0,31] };

    always_after {
        {
            switch( function7[3,2] ) {                                                                                          // RESULT
                case 2b00: { result = function7[0,1] ? MINMAX : SIGN; }                                                         // FMIN FMAX FSGNJ FSGNJN FSGNJX ( NAN BOXED FOR FLOAT )
                case 2b10: { result = COMPARE; }                                                                                // FEQ FLT FLE
                default: { result = function7[1,1] ? df ? sourceReg1 : { 32hffffffff, sourceReg1[0,32] } :                           // FCLASS FMV.X.W FMV.W.X
                                    function3[0,1] ? FCLASS : df ? sourceReg1F : { {32{sourceReg1F[31,1]}}, sourceReg1F[0,32] }; }
            }
        }
        {
            switch( function7[3,2] ) {                                                                                          // FLAGS
                case 2b00: { FPUnewflags = FPUflags | ( function7[0,1] ? flagsMINMAX : 0 ); }                                   // FMIN.S FMAX.S FSGNJ.S FSGNJN.S FSGNJX.S
                case 2b10: { FPUnewflags = FPUflags | flagsCOMPARE; }                                                           // FEQ.S FLT.S FLE.S
                default: { FPUnewflags = FPUflags; }                                                                            // FCLASS.S FMV.X.W FMV.W,X
            }
        }
        { frd = function7[3,1] ? function7[1,1] : ~|function7[3,2]; }                                                           // FRD for FMIN.S FMAX.S FSGNJ.S FSGNJN.S FSGNJX.S AND FMV.W.X
    }
}

// CONVERSION FCVT.dest.source
unit fpuclz64(
    input   uint64  number,
    output! uint7   zeros
) <reginputs> {
    always_after {
        ( zeros ) = clz_silice_64( number );
    }
}

unit intlong2float(
    input   uint1   dounsigned,
    input   uint1   il,
    input   uint64  sourceReg1,
    input   uint32  S1_abs32,
    input   uint64  S1_abs64,
    output  uint64  result,
    input   uint5   FPUflags,
    output  uint5   FPUnewflags
) <reginputs> {
    // COUNT LEADING ZEROS - RETURNS NX IF NUMBER IS TOO LARGE
    fpuclz64 CLZ( number <: number );
    uint1   sign <:: ~dounsigned & sourceReg1[ il ? 63 : 31, 1 ];
    uint64  number <:: il ? sign ? S1_abs64 : sourceReg1 : sign ? S1_abs32 : sourceReg1[0,32];
    uint1   NX <:: il ? 0 : ( CLZ.zeros < 40 );
    int13   exponent <:: 190 - CLZ.zeros;
    uint64  fraction <:: number << CLZ.zeros;

    always_after {
        { result = ( il ? |sourceReg1 : |sourceReg1[0,32] ) ? { 32hffffffff, sign, exponent[0,8], fraction[40,23] } : 64hffffffff00000000; }             // RESULT NAN BOXED
        { FPUnewflags = FPUflags | { 4b0, NX }; }                                                                               // FLAGS
    }
}
unit intlong2double(
    input   uint1   dounsigned,
    input   uint1   il,
    input   uint64  sourceReg1,
    input   uint32  S1_abs32,
    input   uint64  S1_abs64,
    output  uint64  result,
    input   uint5   FPUflags,
    output  uint5   FPUnewflags
) <reginputs> {
    // COUNT LEADING ZEROS - RETURNS NX IF NUMBER IS TOO LARGE
    fpuclz64 CLZ( number <: number );
    uint1   sign <:: ~dounsigned & sourceReg1[ il ? 63 : 31, 1 ];
    uint64  number <:: il ? sign ? S1_abs64 : sourceReg1 : sign ? S1_abs32 : sourceReg1[0,32];
    uint1   NX <:: il ? ( CLZ.zeros < 10 ) : 0;
    int13   exponent <:: 1086  - CLZ.zeros;
    uint64  fraction <:: number << CLZ.zeros;

    always_after {
        { result = ( il ? |sourceReg1 : |sourceReg1[0,32] ) ? { sign, exponent[0,11], fraction[11,52] } : 64h0000000000000000; }                         // RESULT
        { FPUnewflags = FPUflags | { 4b0, NX }; }                                                                               // FLAGS
    }
}
unit floatdouble2int(
    input   uint1   dounsigned,
    input   uint1   df,
    input   uint64  sourceReg1F,
    input   uint4   typeAF,
    output  uint64  result,
    input   uint5   FPUflags,
    output  uint5   FPUnewflags
) <reginputs> {
    uint1   sign <:: sourceReg1F[ df ? 63 : 31, 1 ];
    int13   exp <:: ( df ? fp64( sourceReg1F ).exponent : fp32( sourceReg1F ).exponent ) - ( df ? 1023 : 127 );
    uint1   IF <:: typeAF[3,1];
    uint1   NN <:: |typeAF[1,2];
    uint1   ZERO <:: typeAF[0,1];
    uint1   NV <:: ( exp > ( dounsigned ? 31 : 30 ) ) | ( dounsigned & sign ) | IF | NN;
    uint33  fraction <:: ( df ? { 1b1, sourceReg1F[20,32] } : { 1b1, fp32( sourceReg1F ).fraction, 9b0 } ) >> ( 31 - exp );
    uint32  unsignedfraction <:: ( fraction[1,32] + fraction[0,1] );

    always_after {
        {
            if( ZERO ) {
                result = 0;
            } else {
                if( dounsigned ) {
                    if( IF | NN ) {
                        result = NN ? 64hffffffffffffffff : sign ? 0 :  64hffffffffffffffff;
                    } else {
                        result = sign ? 0 : NV ? 64hffffffffffffffff : unsignedfraction;
                    }
                } else {
                    if( IF | NN ) {
                        result = NN ? 64h000000007fffffff : sign ? 0 : 64h000000007fffffff;
                    } else {
                        result = NV ? { {64{~sign}} } : sign ? { 32hffffffff, -unsignedfraction } : unsignedfraction;
                    }
                }
            }
        }
        { FPUnewflags = FPUflags | { NV, 4b0000 }; }                                            // FLAGS
    }
}
unit floatdouble2long(
    input   uint1   dounsigned,
    input   uint1   df,
    input   uint64  sourceReg1F,
    input   uint4   typeAF,
    output  uint64  result,
    input   uint5   FPUflags,
    output  uint5   FPUnewflags
) <reginputs> {
    uint1   sign <:: sourceReg1F[ df ? 63 : 31, 1 ];
    int13   exp <:: ( df ? fp64( sourceReg1F ).exponent : fp32( sourceReg1F ).exponent ) - ( df ? 1023 : 127 );
    uint1   IF <:: typeAF[3,1];
    uint1   NN <:: |typeAF[1,2];
    uint1   ZERO <:: typeAF[0,1];
    uint1   NV <:: ( exp > ( dounsigned ? 63 : 62 ) ) | ( dounsigned & sign ) | IF | NN;
    uint65  fraction <:: ( df ? { 1b1, fp64( sourceReg1F ).fraction, 12b0 } : { 1b1, fp32( sourceReg1F ).fraction, 41b0 } ) >> ( 63 - exp );
    uint64  unsignedfraction <:: ( fraction[1,64] + fraction[0,1] );

    always_after {
        {
            if( ZERO ) {
                result = 0;
            } else {
                if( dounsigned ) {
                    if( IF | NN ) {
                        result = NN ? 64hffffffffffffffff : sign ? 0 :  64hffffffffffffffff;
                    } else {
                        result = ( sign ) ? 0 : NV ? 64hffffffffffffffff : unsignedfraction;
                    }
                } else {
                    if( IF | NN ) {
                        result = NN ? 64h7fffffffffffffff : sign ? 64h8000000000000000 : 64h7fffffffffffffff;
                    } else {
                        result = NV ? { {64{~sign}} } : sign ? -unsignedfraction : unsignedfraction;
                    }
                }
            }
        }
        { FPUnewflags = FPUflags | { NV, 4b0000 }; }                                            // FLAGS
    }
}
unit float2double(
    input   uint32  sourceReg1F,
    input   uint4   typeAF,

    output  uint64  result,
    input   uint5   FPUflags,
    output  uint5   FPUnewflags
) <reginputs> {
    int13   exp <:: fp32( sourceReg1F ).exponent - 127 + 1023;

    always_after {
        {
            switch( typeAF ) {
                default: { result = { fp32( sourceReg1F ).sign, exp[0,11], fp32( sourceReg1F ).fraction, 29b0 }; }
                case 4b1000: { result = 63h7FF0000000000000; }
                case 4b0100: { result = 64h7FF4000000000000; }
                case 4b0010: { result = 64h7FF8000000000000; }
                case 4b0001: { result = { fp32( sourceReg1F ).sign, 63h0 }; }
            }
        }
        { FPUnewflags = FPUflags; }                                            // FLAGS
    }
}
unit double2float(
    input   uint64  sourceReg1F,
    input   uint4   typeAF,

    output  uint64  result,
    input   uint5   FPUflags,
    output  uint5   FPUnewflags
) <reginputs> {
    int13   exp <:: fp64( sourceReg1F ).exponent - 1023 + 127;

    always_after {
        {
            switch( typeAF ) {
                default: {
                    if( exp > 254 ) {
                        result = { 32hffffffff, fp64( sourceReg1F ).sign, 31h7f800000 };
                    } else {
                        if( exp < ( -127 ) ) {
                            result = { 32hffffffff, fp64( sourceReg1F ).sign, 31h0 };
                        } else {
                            result = { 32hffffffff, fp64( sourceReg1F ).sign, exp[0,8], fp64( sourceReg1F ).fraction[29,23] };
                        }
                    }
                }
                case 4b1000: { result = { 32hffffffff, fp64( sourceReg1F ).sign, 31h7f800000 }; }
                case 4b0100: { result = 64hffffffff7fa00000; }
                case 4b0010: { result = 64hffffffff7fc00000; }
                case 4b0001: { result = { 32hffffffff, fp64( sourceReg1F ).sign, 31h0 }; }
            }
        }
        { FPUnewflags = FPUflags; }                                            // FLAGS
    }
}

// FPU CALCULATION BLOCKS FUSED ADD SUB MUL DIV SQRT
unit floatcalc(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint1   df,
    input   uint5   opCode,
    input   uint5   function7,
    input   uint64  sourceReg1F,
    input   uint64  sourceReg2F,
    input   uint64  sourceReg3F,
    input   uint4   typeAF,
    input   uint4   typeBF,
    input   uint4   typeCF,

    input   uint5   FPUflags,
    output  uint5   FPUnewflags,
    output  uint64  result
) <reginputs> {
    // CLASSIFY THE RESULT OF MULTIPLICATION
    typeF typeMF( df <: df, a <: FPUmultiply.result );

    // ADD/SUB/MULT have changeable inputs due to 2 input and 3 input fused operations
    floataddsub FPUaddsub( df <: df, OF <: MAKERESULT.OF, UF <: MAKERESULT.UF, combined <: MAKERESULT.combined );
    floatmultiply FPUmultiply( df <: df, a <: sourceReg1F, b <: sourceReg2F, typeAF <: typeAF, typeBF <: typeBF, OF <: MAKERESULT.OF, UF <: MAKERESULT.UF, combined <: MAKERESULT.combined );
    floatdivide FPUdivide( df <: df, a <: sourceReg1F, b <: sourceReg2F, typeAF <: typeAF, typeBF <: typeBF, OF <: MAKERESULT.OF, UF <: MAKERESULT.UF, combined <: MAKERESULT.combined );
    floatsqrt FPUsqrt( df <: df, a <: sourceReg1F, typeAF <: typeAF, OF <: MAKERESULT.OF, UF <: MAKERESULT.UF, combined <: MAKERESULT.combined );

    // NORMALISE RESULT OF ADD SUB DIV
    donormal DONORMAL( df <: df, exp <: FPUaddsub.tonormaliseexp );

    // ROUNDING AND COMBINING OF FINAL RESULTS
    doroundcombine MAKERESULT( df <: df );

    // UNIT BUSY FLAG
    uint4   unitbusy <:: { FPUsqrt.busy, FPUdivide.busy, FPUmultiply.busy, FPUaddsub.busy };
    uint1   isbusy <:: |unitbusy;

    FPUaddsub.start := 0; FPUmultiply.start := 0; FPUdivide.start := 0; FPUsqrt.start := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1;
                if( opCode[2,1] ) {
                    switch( function7[0,2] ) {                                                                          // START 2 REGISTER FPU OPERATIONS
                        default: { FPUaddsub.start = 1; }                                                               // FADD.S FSUB.S
                        case 2b10: { FPUmultiply.start = 1; }                                                           // FMUL.S
                        case 2b11: { FPUsqrt.start = function7[3,1]; FPUdivide.start = ~function7[3,1]; }               // FSQRT.S // FDIV.S
                    }
                    while( isbusy ) {}                                                                                  // WAIT FOR FINISH
                } else {
                    FPUmultiply.start = 1; while( isbusy ) {}                                                           // START 3 REGISTER FUSED FPU OPERATION - MULTIPLY
                    FPUaddsub.start = 1; while( isbusy ) {}                                                             //                                        ADD / SUBTRACT
                }
                busy = 0;
            }
        }
    }

    always_after {
        // UNIT RESULT FLAGS
        uint5   flags = uninitialised;

        // PASS ADDSUB OR DIVIDE BITSTREAM TO NORMALISATION UNIT
        { DONORMAL.bitstream = opCode[2,1] & ( &function7[0,2] ) ? FPUdivide.tonormalisebitstream : FPUaddsub.tonormalisebitstream; }

        // CONTROL INPUTS TO ROUNDING AND COMBINING
        {
            if( isbusy ) {
                onehot( unitbusy ) {
                    case 0: { MAKERESULT.exponent = DONORMAL.newexponent; }
                    case 1: { MAKERESULT.exponent = FPUmultiply.productexp; }
                    case 2: { MAKERESULT.exponent = FPUdivide.quotientexp; }
                    case 3: { MAKERESULT.exponent = FPUsqrt.squarerootexp; }
                }
            }
        }
        {
            if( isbusy ) {
                onehot( unitbusy ) {
                    default: { MAKERESULT.bitstream = DONORMAL.normalfraction; }    // ADDSUB DIVIDE
                    case 1: { MAKERESULT.bitstream = FPUmultiply.normalfraction; }
                    case 3: { MAKERESULT.bitstream = FPUsqrt.normalfraction; }
                }
            }
        }
        { if( isbusy ) { MAKERESULT.sign = |( { 1b0, FPUdivide.quotientsign, FPUmultiply.productsign, FPUaddsub.resultsign } & unitbusy ); } }

        // SET INPUTS TO ADDSUB FOR SINGLE AND FUSED OPERATIONS
        {
            FPUaddsub.a = opCode[2,1] ? sourceReg1F :
                                        df ? { opCode[1,1] ^ FPUmultiply.result[63,1], FPUmultiply.result[0,63] } :
                                             { 32hffffffff, opCode[1,1] ^ FPUmultiply.result[31,1], FPUmultiply.result[0,31] };
        }
        {
            FPUaddsub.b = opCode[2,1] ? df ? { function7[0,1] ^ sourceReg2F[63,1], sourceReg2F[0,63] } : { 32hffffffff, function7[0,1] ^ sourceReg2F[31,1], sourceReg2F[0,31] }:
                                        df ? { opCode[0,1] ^ sourceReg3F[63,1], sourceReg3F[0,63] } : { 32hffffffff, opCode[0,1] ^ sourceReg3F[31,1], sourceReg3F[0,31] };
        }
        { FPUaddsub.typeAF = opCode[2,1] ? typeAF : typeMF.type; }
        { FPUaddsub.typeBF = opCode[2,1] ? typeBF : typeCF; }

        // SELECT RESULT
        {
            if( opCode[2,1] ) {                                                                                         // SINGLE OPERATION
                switch( function7[0,2] ) {
                    default: { result = FPUaddsub.result; }                                                             // FADD.S FSUB.S
                    case 2b10: { result = FPUmultiply.result; }                                                         // FMUL.S
                    case 2b11: { result = function7[3,1] ? FPUsqrt.result : FPUdivide.result; }                         // FSQRT.S FDIV.S
                }
            } else {                                                                                                    // FUSED OPERATIONS
                result = FPUaddsub.result;
            }
        }
        // SELECT FLAGS
        {
            if( opCode[2,1] ) {                                                                                         // SINGLE OPERATION
                switch( function7[0,2] ) {
                    default: { flags = FPUaddsub.flags & 5b00110; }                                                     // FADD.S FSUB.S
                    case 2b10: { flags = FPUmultiply.flags & 5b00110; }                                                 // FMUL.S
                    case 2b11: { flags = function7[3,1] ? FPUsqrt.flags & 5b00110 : FPUdivide.flags & 5b01110; }        // FSQRT.S FDIV.S
                }
            } else {                                                                                                    // FUSED OPERATIONS
                flags = ( FPUmultiply.flags & 5b10110 ) | ( FPUaddsub.flags & 5b00110 );
            }
        }
        { FPUnewflags = FPUflags | flags; }                                                                             // RETURN NEW FLAGS
    }
}

// Rob Shelton ( @robng15 Twitter, @rob-ng15 GitHub )
// Simple 32bit FPU calculation/conversion routines
// Designed for as small as FPGA usage as possible,
// not for speed.
//
// Copyright (c) 2021 Rob Shelton
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// Donated to Silice by @sylefeb
// MIT license, see LICENSE_MIT in Silice repo root
//
// Parameters for calculations: ( 32 bit float { sign, exponent, mantissa } format )
// addsub, multiply and divide a and b ( as floating point numbers ), addsub flag == 0 for add, == 1 for sub
//
// Parameters for conversion:
// intotofloat a as 32 bit integer, dounsigned == 1 dounsigned, == 0 signed conversion
// floattouint and floattoint a as 32 bit float
//
// Control:
// start == 1 to start operation
// busy gives status, == 0 not running or complete, == 1 running
//
// Output:
// result gives result of conversion or calculation
//
// NB: Error states are those required by Risc-V floating point

// IDENTIFY { infinity, signalling NAN, quiet NAN, ZERO }
// CHECKS FOR NAN-BOXING OF FLOAT
unit typeF(
    input   uint1   df,
    input   uint64  a,
    output  uint4   type
) <reginputs> {
    uint1   expFF <:: df ? &fp64(a).exponent : &fp32(a).exponent;                                                               // CHECK FOR EXP = ALL 1s ( signals INF/NAN )
    uint1   zeroFRACTION <:: df ? ~|fp64(a).fraction : ~|fp32(a).fraction;                                                      // FRACTION == 0, INF, == 100... qNAN, == 0xxx... ( xxx... != 0 ) sNAN
    uint1   boxed <:: &a[32,32];                                                                                                // NAN-boxing, upper 32 bits all 1s

    always_after {
        type = df ? { expFF & zeroFRACTION,                                                                                     // INF
                      expFF & ~fp64(a).fraction[51,1] & ~zeroFRACTION,                                                          // sNAN
                      expFF & fp64(a).fraction[51,1],                                                                           // qNAN
                      ~|( fp64(a).exponent ) } :                                                                                  // ZERO / SUBNORMAL
               boxed ?
                    { expFF & zeroFRACTION,                                                                                     // INF
                      expFF & ~fp32(a).fraction[22,1] & ~zeroFRACTION,                                                          // sNAN
                      expFF & fp32(a).fraction[22,1],                                                                           // qNAN
                      ~|( fp32(a).exponent ) } :                                                                                // ZERO / SUBNORMAL
                    4b0010;                                                                                                     // FLOAT NOT BOXED, ISSUE qNAN

    }
}

// NORMALISE A 106 BIT MANTISSA SO THAT THE MSB IS ONE, FOR ADDSUB ALSO DECREMENT THE EXPONENT FOR EACH SHIFT LEFT
// EXTRACT THE 53 (double) 24 (float) BITS FOLLOWING THE MSB (1.xxxx) FOR ROUNDING
unit clz106(
    input   uint106  bitstream,
    output! uint7   count
) <reginputs> {
    uint2   bitstream3 <:: bitstream[104,2];        uint8   bitstream2 <:: bitstream[96,8];
    uint32  bitstream1 <:: bitstream[64,32];        uint64  bitstream0 <:: bitstream[0,64];
    uint7   clz_3 = uninitialised;                  uint7   clz_2 = uninitialised;
    uint7   clz_1 = uninitialised;                  uint7   clz_0 = uninitialised;

    always_after {
        { ( clz_3 ) = clz_silice_2( bitstream3 ); }
        { ( clz_2 ) = clz_silice_8( bitstream2 ); }
        { ( clz_1 ) = clz_silice_32( bitstream1 ); }
        { ( clz_0 ) = clz_silice_64( bitstream0 ); }
        {
            count = |bitstream3 ? clz_3 :                                                                                       // COUNT LEADING ZEROS FOR NORMALISATION SHIFT
                    |bitstream2 ? clz_2 + 2 :
                    |bitstream1 ? clz_1 + 10 :
                                  clz_0 + 42;
        }
     }
}
// NORMALISE RESULT FOR ADD SUB DIVIDE
unit donormal(
    input   uint1   df,
    input   int13   exp,
    input   uint106 bitstream,
    output  int13   newexponent,
    output  uint53  normalfraction
) <reginputs> {
    // COUNT LEADING ZEROS
    uint106 temporary <:: ( bitstream << CLZ106.count );
    clz106 CLZ106( bitstream <: bitstream );

    always_after {
        { normalfraction = df ? temporary[ 52, 53 ] : { temporary[ 81, 25 ], 28b0 }; }                                                // EXTRACT 53 ( double) 24 ( float ) BITS ( 1 extra for rounding )
        { newexponent = exp - CLZ106.count; }                                                                                   // ADDSUB EXPONENT ADJUSTMENT
    }
}

// FAST NORMALISE RESULT FOR MULTIPLICATION AND SQUARE ROOT
unit fastnormal(
    input   uint1   df,
    input   uint106 tonormal,
    output  uint53  normalfraction
) <reginputs> {
    always_after {
        normalfraction = df ? tonormal[ tonormal[105,1] ? 52 : 51, 53 ] : { tonormal[ tonormal[105,1] ? 82 : 81, 24 ], 29b0 };
    }
}

// ROUND 52 ( double ) 23 ( float ) BIT FRACTION FROM NORMALISED FRACTION USING NEXT TRAILING BIT
// ADD BIAS TO EXPONENT AND ADJUST EXPONENT IF ROUNDING FORCES
// COMBINE COMPONENTS TO FLOATING POINT NUMBER - USED BY CALCULATIONS
// UNDERFLOW return 0, OVERFLOW return infinity
unit overflow(
    input   uint1   df,
    input   int13   exponent,
    output! uint1   OF
) <reginputs> {
    always_after { OF = ( exponent > ( df ? 2046 : 254 ) ); }
}
unit newexp(
    input   uint1   df,
    input   uint53  roundfraction,
    input   uint1   lsb,
    input   int13   exponent,
    output  int13   newexponent
) <reginputs> {
    always_after {
        newexponent = df ? ( ( ~|roundfraction[0,52] & lsb ) ? 1024 : 1023 ) + exponent :
                           ( ( ~|roundfraction[0,23] & lsb ) ? 128 : 127 ) + exponent;
    }
}
unit doroundcombine(
    input   uint1   df,
    input   uint1   sign,
    input   uint53  bitstream,
    input   int13   exponent,
    output! uint1   OF,
    output! uint1   UF,
    output! uint64  combined
) <reginputs> {
    uint52  roundfraction <:: df ? ( bitstream[1,52] + bitstream[0,1] ) : ( bitstream[29,23] + bitstream[28,1] );
    newexp EXP( df <: df, roundfraction <: roundfraction, exponent <: exponent );
    overflow OVER( df <: df, exponent <: EXP.newexponent, OF :> OF );

    EXP.lsb := bitstream[ df ? 0 : 28, 1 ];

    always_after {
        { UF = EXP.newexponent[12,1];  }
        { combined = EXP.newexponent[12,1] ? df ? 64h0000000000000000 : 64hffffffff00000000 :
                                             df ? { sign, OVER.OF ? 63h7FF0000000000000 : { EXP.newexponent[0,11], roundfraction } } :
                                                  { 32hffffffff, sign, OVER.OF ? 31h7f800000 : { EXP.newexponent[0,8], roundfraction[0,23] } };

        }
    }
}

// ADDSUB ADD/SUBTRACT TWO FLOATING POresult NUMBERS ( SUBTRACT ACHIEVED BY ALTERING SIGN OF SECOND INPUT )
unit equaliseexpaddsub(
    input   uint1   df,
    input   uint64  a,
    input   uint64  b,
    output  uint106 newsigA,
    output  uint106 newsigB,
    output  int13   resultexp,
) <reginputs> {
    // BREAK DOWN INITIAL float32 INPUTS - SWITCH SIGN OF B IF SUBTRACTION
    uint106 sigA <:: df ? { 2b01, fp64(a).fraction, 52b0 } : { 2b01, fp32(a).fraction, 81b0 };
    uint106 sigB <:: df ? { 2b01, fp64(b).fraction, 52b0 } : { 2b01, fp32(b).fraction, 81b0 };
    uint1   AvB <:: ( df ? fp64(a).exponent : fp32(a).exponent ) < ( df ? fp64(b).exponent : fp32(b).exponent );
    uint106 aligned <:: ( AvB ? sigA : sigB ) >> ( ( AvB ? ( df ? fp64(b).exponent : fp32(b).exponent ) : ( df ? fp64(a).exponent : fp32(a).exponent ) ) -
                                                   ( AvB ? ( df ? fp64(a).exponent : fp32(a).exponent ) : ( df ? fp64(b).exponent : fp32(b).exponent ) ) );

    always_after {
        { newsigA = AvB ? aligned : sigA; }
        { newsigB = AvB ? sigB : aligned;  }
        { resultexp = ( AvB ? ( df ? fp64(b).exponent : fp32(b).exponent ) : ( df ? fp64(a).exponent : fp32(a).exponent ) ) - ( df ? 1022 : 126 ); }
    }
}
unit dofloataddsub(
    input   uint1   df,
    input   uint1   signA,
    input   uint106 sigA,
    input   uint1   signB,
    input   uint106 sigB,
    output  uint1   resultsign,
    output  uint106 resultfraction
) <reginputs> {
    uint1   AvB <:: ( sigA > sigB );
    uint1   sign <:: ( signA ^ signB ) ? ( signA ? AvB : ~AvB ) : signA;

    always_after {
        // PERFORM ADDITION/SUBTRACTION ACCOUTING FOR INPUT AND RESULT SIGNS
        { resultsign = sign; }
        { if( signA ^ signB ) { resultfraction = ( signA ^ sign ? sigB : sigA ) - ( signA ^ sign ? sigA : sigB ); } else { resultfraction = sigA + sigB; } }
    }
}
unit floataddsub(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint1   df,
    input   uint64  a,
    input   uint64  b,
    input   uint4   typeAF,
    input   uint4   typeBF,
    output  int13   tonormaliseexp,
    output  uint106 tonormalisebitstream,
    output  uint1   resultsign,
    input   uint1   OF,
    input   uint1   UF,
    input   uint64  combined,
    output  uint5   flags,
    output  uint64  result
) <reginputs> {
    // CLASSIFY THE INPUTS AND FLAG INFINITY, NAN, ZERO AND INVALID ( INF - INF )
    uint1   IF <:: ( typeAF[3,1] | typeBF[3,1] );
    uint1   NN <:: ( typeAF[2,1] | typeAF[1,1] | typeBF[2,1] | typeBF[1,1] );
    uint1   NV <:: ( typeAF[3,1] & typeBF[3,1]) & ( df ? ( fp64( a ).sign ^ fp64( b).sign ) : ( fp32( a ).sign ^ fp32( b).sign ) );
    uint2   ACTION <:: { IF | NN, typeAF[0,1] | typeBF[0,1] };

    uint64  qNAN <:: df ? 64h7FF8000000000000 : 64hffffffff7fc00000;
    uint64  ZERO <:: df ? 0 : 64hffffffff00000000;

    // EQUALISE THE EXPONENTS
    equaliseexpaddsub EQUALISEEXP( df <: df, a <: a, b <: b, resultexp :> tonormaliseexp );

    // PERFORM THE ADDITION/SUBTRACION USING THE EQUALISED FRACTIONS, 1 IS ADDED TO THE EXPONENT IN CASE OF OVERFLOW - NORMALISING WILL ADJUST WHEN SHIFTING
    dofloataddsub ADDSUB( df <: df, sigA <: EQUALISEEXP.newsigA, sigB <: EQUALISEEXP.newsigB, resultsign :> resultsign, resultfraction :> tonormalisebitstream );

    ADDSUB.signA := df ? fp64( a ).sign : fp32( a ).sign; ADDSUB.signB := df ? fp64( b ).sign : fp32( b).sign;

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1;
                if( ~|ACTION & |ADDSUB.resultfraction ) {
                    // VALID RESULT, ALLOW FOR NORMALISATION AND COMBINING OF FINAL RESULT
                    ++: ++: busy = 0;
                } else { busy = 0; }
            }
        }
    }

    always_after {
        {
            switch( ACTION ) {
                case 2b00: { result = |ADDSUB.resultfraction ? combined : ZERO; }
                case 2b01: { result = (typeAF[0,1] & typeBF[0,1] ) ? ZERO : df ? ( typeBF[0,1] ? a : b ) : { 32hffffffff, typeBF[0,1] ? a[0,32] : b[0,32] }; }
                default: {
                    switch( { IF, NN } ) {
                        case 2b10: { result = NV ? qNAN : df ? ( typeAF[3,1] ? a : b ) : { 32hffffffff, typeAF[3,1] ? a[0,32] : b[0,32] }; }
                        default: { result = qNAN; }
                    }
                }
            }
        }
        { flags = { NV, 1b0, ~|ACTION & OF, ~|ACTION & UF, 1b0 }; }
    }
}

// MULTIPLY TWO FLOATING POresult NUMBERS
unit floatmultiply(
    input   uint1   df,
    input   uint1   start,
    output  uint1   busy(0),
    input   uint64  a,
    input   uint64  b,
    input   uint4   typeAF,
    input   uint4   typeBF,
    output  uint1   productsign,
    output  int13   productexp,
    output  uint53  normalfraction,
    input   uint1   OF,
    input   uint1   UF,
    input   uint64  combined,

    output  uint5   flags,
    output  uint64  result
) <reginputs> {
    // CLASSIFY THE INPUTS AND FLAG INFINITY, NAN, ZERO AND INVALID ( INF x ZERO )
    uint1   ZERO <:: (typeAF[0,1] | typeBF[0,1] );
    uint1   IF <:: ( typeAF[3,1] | typeBF[3,1] );
    uint1   NN <:: ( typeAF[2,1] | typeAF[1,1] | typeBF[2,1] | typeBF[1,1] );
    uint1   NV <:: IF & ZERO;
    uint2   ACTION <:: { IF | NN, ZERO };

    uint64  qNAN <:: df ? 64h7FF8000000000000 : 64hffffffff7fc00000;
    uint64  xINF <:: df ? { productsign, 63h7FF0000000000000 } : { 32hffffffff, productsign, 31h7f800000 };

    uint106  product <:: df ? { 1b1, fp64( a ).fraction } * { 1b1, fp64( b ).fraction } :
                              { 1b1, fp32( a ).fraction, 29b0 } * { 1b1, fp32( b ).fraction, 29b0 };

    // NORMALISE THE RESULTING PRODUCT AND EXTRACT THE 24 BITS AFTER THE LEADING 1.xxxx
    fastnormal NORMAL( df <: df, tonormal <: product, normalfraction :> normalfraction );

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1;
                if( ~|ACTION ) {
                    // STEPS: SETUP -> DOMUL -> NORMALISE -> ROUND -> ADJUSTEXP -> COMBINE
                    // ALLOW 2 CYCLES TO PERFORM THE MULTIPLICATION, NORMALISATION AND ROUNDING
                    ++: ++: busy = 0;
                } else { busy = 0; }
            }
        }
    }

    always_after {
        // BREAK DOWN INITIAL float32 INPUTS, PERFORM THE MULTIPLICATION, AND FIND SIGN OF RESULT AND EXPONENT OF PRODUCT ( + 1 IF PRODUCT OVERFLOWS, MSB == 1 )
        { productsign = ( df ? fp64( a ).sign : fp32( a ).sign ) ^ ( df ? fp64( b ).sign : fp32( b ).sign ); }
        { productexp = ( df ? fp64( a ).exponent : fp32( a ).exponent ) + ( df ? fp64( b ).exponent : fp32( b ).exponent )
                       - ( df ? ( product[105,1] ? 2045 : 2046 ) : ( product[105,1] ? 253 : 254 ) ); }

        {
            switch( ACTION ) {
                case 2b00: { result = combined; }
                case 2b01: { result = df ? { productsign, 63b0 } : { 32hffffffff, productsign, 31b0 }; }
                default: {
                    switch( { IF, ZERO } ) {
                        case 2b11: { result = qNAN; }
                        case 2b10: { result = NN ? qNAN : xINF; }
                        default: { result = qNAN; }
                    }
                }
            }
        }
        {  flags = { NV, 1b0, ~|ACTION & OF, ~|ACTION & UF, 1b0 }; }
    }
}

// DIVIDE TWO FLOATING POresult NUMBERS
unit dofloatdivide(
    input   uint1   df,
    input   uint1   start,
    output  uint1   busy(0),
    input   uint108 sigA,
    input   uint108 sigB,
    output  uint108 quotient(0)
) <reginputs> {
    uint7   bit(127);
    uint108 remainder = uninitialised;
    uint108 temporary <:: df ? { remainder[0,107], sigA[bit,1] } : { remainder[0,49], sigA[bit,1] };
    uint1   bitresult <:: __unsigned(temporary) >= __unsigned(sigB);
    uint108 remainderNEXT <:: __unsigned(temporary) - ( bitresult ? __unsigned(sigB) : 0 );
    uint2   normalshift <:: quotient[ df ? 107 : 49, 1 ] ? 2 : quotient[ df ? 106 : 48, 1 ];

    always_after {
        // FIND QUOTIENT AND ENSURE 48 BIT FRACTION ( ie BITS 48 and 49 clear )
        if( &bit ) {
            if( start ) { busy = 1; bit = df ? 107 : 49; quotient = 0; remainder = 0; } else { quotient = quotient[ normalshift, 106 ]; busy = 0; }
        } else {
            remainder = remainderNEXT;
            quotient[bit,1] = bitresult;
            bit = bit - 1;
        }
    }
}
unit floatdivide(
    input   uint1   df,
    input   uint1   start,
    output  uint1   busy(0),
    input   uint64  a,
    input   uint64  b,
    input   uint4   typeAF,
    input   uint4   typeBF,
    output  uint1   quotientsign,
    output  int13   quotientexp,
    output  uint106 tonormalisebitstream,
    input   uint1   OF,
    input   uint1   UF,
    input   uint64  combined,
    output  uint5   flags,
    output  uint64  result
) <reginputs> {
    // CLASSIFY THE INPUTS AND FLAG INFINITY, NAN, ZERO AND DIVIDE ZERO
    uint1   IF <:: ( typeAF[3,1] | typeBF[3,1] );
    uint1   NN <:: ( typeAF[2,1] | typeAF[1,1] | typeBF[2,1] | typeBF[1,1] );
    uint2   ACTION <:: { IF | NN, typeAF[0,1] | typeBF[0,1] };

    uint64  qNAN <:: df ? 64h7FF8000000000000 : 64hffffffff7fc00000;
    uint64  xINF <:: df ? { quotientsign, 63h7FF0000000000000 } : { 32hffffffff, quotientsign, 31h7f800000 };
    uint64  xZERO <:: df ? { quotientsign, 63h0 } : { 32hffffffff, quotientsign, 63h0 };

    // PREPARE THE DIVISION, DO THE DIVISION, NORMALISE THE RESULT
    dofloatdivide DODIVIDE( df <: df, quotient :> tonormalisebitstream );

    DODIVIDE.start := start & ~|ACTION; busy := start | DODIVIDE.busy;

    always_after {
        // BREAK DOWN INITIAL float32 INPUTS AND FIND SIGN OF RESULT AND EXPONENT OF QUOTIENT ( -1 IF DIVISOR > DIVIDEND )
        // ALIGN DIVIDEND TO THE LEFT, DIVISOR TO THE RIGHT
        { quotientsign = ( df ? fp64( a ).sign : fp32( a ).sign ) ^ ( df ? fp64( b ).sign : fp32( b ).sign ); }
        {
            quotientexp = ( df ? fp64( a ).exponent : fp32( a ).exponent ) - ( df ? fp64( b ).exponent : fp32( b ).exponent )
                          - ( ( df ? fp64(b).fraction : fp32(b).fraction ) > ( df ? fp64(a).fraction : fp32(a).fraction ) ); }
        { DODIVIDE.sigA = df ? { 1b1, fp64(a).fraction, 55b0 } : { 1b1, fp32(a).fraction, 26b0 }; }
        { DODIVIDE.sigB = df ? { 56b1, fp64(b).fraction } : { 27b1, fp32(b).fraction }; }

        {
            switch( ACTION ) {
                case 2b00: { result = combined; }
                case 2b01: { result = (typeAF[0,1] & typeBF[0,1] ) ? qNAN : typeBF[0,1] ? xINF : xZERO; }
                default: { result = ( typeAF[3,1] & typeBF[3,1] ) | NN | typeBF[0,1] ? qNAN : (typeAF[0,1] | typeBF[3,1] ) ? xZERO : xINF; }
            }
        }
        { flags = { 1b0, typeBF[0,1], ~|ACTION & OF, ~|ACTION & UF, 1b0}; }
    }
}

// ADAPTED FROM https://projectf.io/posts/square-root-in-verilog/
//
// MIT License
//
// Copyright (c) 2021 Will Green, Project F
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
unit dofloatsqrt(
    input   uint1   df,
    input   uint1   start,
    output  uint1   busy(0),
    input   uint108 start_ac,
    input   uint106 start_x,
    output  uint106 squareroot
) <reginputs> {
    uint108 test_res <:: ac - { squareroot, 2b01 }; uint108 ac = uninitialised;
    uint106 x = uninitialised;
    uint7   i(105);
    busy := start | ( i != 105 );

    always_after {
        if( i == 105 ) {
            if( start ) { i = df ? 0 : 58; squareroot = 0; ac = start_ac; x = start_x; }
        } else {
            ac = { test_res[107,1] ? ac[0,105] : test_res[0,105], x[104,2] };
            squareroot = { squareroot[0,105], ~test_res[107,1] };
            x = { x[0,104], 2b00 };
            i = i + 1;
        }
    }
}
unit floatsqrt(
    input   uint1   df,
    input   uint1   start,
    output  uint1   busy(0),
    input   uint64  a,
    input   uint4   typeAF,
    output  int13   squarerootexp,
    output  uint106 normalfraction,
    input   uint1   OF,
    input   uint1   UF,
    input   uint64  combined,
    output  uint5   flags,
    output  uint64  result
) <reginputs> {
    // CLASSIFY THE INPUTS AND FLAG INFINITY, NAN, ZERO AND NOT VALID
    uint1   NN <:: typeAF[2,1] | typeAF[1,1];
    uint1   NV <:: typeAF[3,1] | NN | fp32( a ).sign;
    uint1   ACTION <:: ~|{ typeAF[3,1] | NN, typeAF[0,1] | ( df ? fp64( a ).sign : fp32( a ).sign ) };

    uint64  qNAN <:: df ? 64h7FF8000000000000 : 64hffffffff7fc00000;

    // EXPONENT OF INPUT ( used to determine if 1x.xxxxx or 01.xxxxx for fixed point fraction to sqrt )
    // SQUARE ROOT EXPONENT IS HALF OF INPUT EXPONENT
    int13   expA  <:: ( df ? fp64( a ).exponent : fp32( a ).exponent ) - ( df ? 1023 : 127 );

    // PERFORM THE SQUAREROOT, FAST NORMALISE THE RESULT
    dofloatsqrt DOSQRT( df <: df );
    fastnormal NORMAL( df <: df, normalfraction :> normalfraction );

    DOSQRT.start := start & ACTION; busy := start | DOSQRT.busy;

    always_after {
        { DOSQRT.start_ac = expA[0,1] ? { 106b0, 1b1, a[ df ? 51 : 22, 1 ] } : 1; }
        { DOSQRT.start_x = expA[0,1] ? df ? { a[0,51], 55b0 } : { a[0,22], 84b0 } : df ? { fp64( a ).fraction, 54b0 } : { fp32( a ).fraction, 83b0 }; }
        { NORMAL.tonormal = df ? DOSQRT.squareroot : ( DOSQRT.squareroot << 59 ); }
        { squarerootexp = expA >>> 1; }
        {
            if( ACTION ) {
                // STEPS: SETUP -> DOSQRT -> NORMALISE -> ROUND -> ADJUSTEXP -> COMBINE
                result = combined;
            } else {
                // DETECT sNAN, qNAN, -INF, -x -> qNAN AND  INF -> INF, 0 -> 0
                result = ( df ? fp64( a ).sign : fp32( a ).sign ) ? qNAN : a;
            }
        }
        { flags = { NV, 1b0, ACTION & OF, ACTION & UF, 1b0 }; }
    }
}

// FLOATING POresult COMPARISONS - ADAPTED FROM SOFT-FLOAT

/*============================================================================

License for Berkeley SoftFloat Release 3e

John R. Hauser
2018 January 20

The following applies to the whole of SoftFloat Release 3e as well as to
each source file individually.

Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018 The Regents of the
University of California.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions, and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors
    may be used to endorse or promote products derived from this software
    without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS resultERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

unit floatcompare(
    input   uint1   df,
    input   uint64  a,
    input   uint64  b,
    input   uint4   typeAF,
    input   uint4   typeBF,
    output  uint1   less,
    output  uint1   equal
) <reginputs> {
    uint1   NAN <:: typeAF[2,1] | typeBF[2,1] | typeAF[1,1] | typeBF[1,1];
    uint1   aequalb <:: a == b;
    uint1   aorbleft1equal0 <:: ~|( ( df ? a[0,63] : a[0,31] ) | ( df ? b[0,63] : b[0,31] ) );

    uint1   signA <:: df ? fp64( a ).sign : fp32( a ).sign;
    uint1   signB <:: df ? fp64( b ).sign : fp32( b ).sign;

    // IDENTIFY NaN, RETURN 0 IF NAN, OTHERWISE RESULT OF COMPARISONS
    always_after {
        { less = ~NAN & ( ( signA ^ signB ) ? signA & ~aorbleft1equal0 : ~aequalb & ( signA ^ ( ( df ? a : a[0,32] ) < ( df ? b : b[0,32] ) ) ) ); }
        { equal = ~NAN & ( aequalb | aorbleft1equal0 ); }
    }
}
