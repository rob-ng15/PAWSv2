// ALU - ALU for immediate-register operations and register-register operations

// DECODE ALU INSTRUCTIONS
unit aludecode(
    input   uint1   regreg,
    input   uint7   function7,
    input   uint3   function3,
    input   uint5   rs2,

    output  uint1   domul,
    output  uint1   doalt,
    output  uint1   dosra,
    output  uint1   dorotate,
    output  uint1   dobclrext,
    output  uint1   dobinv,
    output  uint1   dobset,
    output  uint1   doshxadd,
    output  uint1   docount,
    output  uint1   dominmax,
    output  uint1   dosignx,
    output  uint1   dopack,
    output  uint1   doorc,
    output  uint1   doxperm,
    output  uint1   dorev,
    output  uint1   dozip
) <reginputs> {
    uint1   f70000100 <:: ( function7 == 7b0000100 );
    uint1   f70110100 <:: ( function7 == 7b0110100 );
    uint1   f70110000 <:: ( function7 == 7b0110000 );
    uint1   f70100000 <:: ( function7 == 7b0100000 );
    uint1   f70010100 <:: ( function7 == 7b0010100 );

    always_after {
        { doalt = regreg & f70100000; }                                             // ADD/SUB AND/ANDN OR/ORN XOR/XNOR ( register - register only )
        { dosra = f70100000; }                                                      // SRA SRAI
        { dopack = regreg & f70000100; }                                            // ZEXT.H PACK PACKH ( ZEXT.H when rs2 == 0 )
        { dozip = ~regreg & f70000100; }                                            // UNZIP ZIP
        { dobinv = f70110100; }                                                     // BINV BINVI
        { dorev = ~regreg & f70110100; }                                            // REV8
        { dorotate = f70110000; }                                                   // ROL ROR RORI
        { docount = ~regreg & f70110000 & ~rs2[2,1]; }                              // CLZ CPOP CTZ ( immediate only )
        { dosignx = ~regreg & f70110000 & rs2[2,1]; }                               // SEXT.B SEXT.H
        { dobset = f70010100; }                                                     // ( F3 == 001 ) BSET BSETI
        { doorc = ~regreg & f70010100; }                                            // ( F3 = 101 ) ORC.B
        { doxperm = regreg & f70010100; }                                           // ( F3 == 010 ) XPERM4 ( F3 = 100 ) XPERM8
        { domul = regreg & ( function7 == 7b0000001 ); }                            // MULTIPLICATION
        { dobclrext = ( function7 == 7b0100100 ); }                                 // BCLR BCLRI BEXT BEXTI
        { doshxadd = regreg & ( function7 == 7b0010000 ); }                         // SH1ADD SH2ADD SH3ADD ( register - register only )
        { dominmax = regreg & function3[2,1] & ( function7 == 7b0000101 ); }        // MAX MAXU MIN MINU ( register - register only )
    }
}

unit alu(
    input   uint5   opCode,
    input   uint3   function3,
    input   uint7   function7,
    input   uint5   rs1,
    input   uint5   rs2,
    input   int32   sourceReg1,
    input   int32   sourceReg2,
    input   int32   negSourceReg2,
    input   int32   immediateValue,
    input   uint1   LT,                                                             // SIGNED COMPARE sourceReg1 < operand2
    input   uint1   LTU,                                                            // UNSIGNED COMPARE sourceReg1 < operand2

    output  int32   result
) <reginputs> {
    uint5   shiftcount <:: opCode[3,1] ? sourceReg2[0,5] : rs2;
    uint6   shiftother <:: 32 - ( opCode[3,1] ? sourceReg2[0,5] : rs2 );
    uint32  mask <:: 1 << ( opCode[3,1] ? sourceReg2[0,5] : rs2 );
    uint32  operand2 <:: opCode[3,1] ? sourceReg2 : immediateValue;
    uint32  operand2inv <:: ~sourceReg2;

    // DECODE THE ALU OPERATION
    aludecode AD( regreg <: opCode[3,1], function7 <: function7, function3 <: function3, rs2 <: rs2 );

    // ADD SUBTRACT
    uint32  ADDSUB <:: sourceReg1 + ( AD.doalt ? negSourceReg2 : operand2 );

    // SHIFT AND ROTATE
    uint32  SLL <:: sourceReg1 << shiftcount;
    uint32  SRL <:: sourceReg1 >> shiftcount;
    uint32  SRA <:: __signed(sourceReg1) >>> shiftcount;
    uint32  ROTATE <:: function3[2,1] ? ( ( sourceReg1 << shiftother ) | SRL ) : ( SLL | ( sourceReg1 >> shiftother ) );

    // 1 BIT FUNCTIONS
    uint32  CLR <:: sourceReg1 & ~mask;             uint32  INV <:: sourceReg1 ^ mask;
    uint32  SET <:: sourceReg1 | mask;              uint32  EXT <:: sourceReg1[ shiftcount, 1 ];

    // BINARY LOGIC
    uint32  AND <:: sourceReg1 & ( AD.doalt ? operand2inv : operand2 );
    uint32  OR <:: sourceReg1 | ( AD.doalt ? operand2inv : operand2 );
    uint32  XOR <:: sourceReg1 ^ ( AD.doalt ? operand2inv : operand2 );

    // SHxADD
    uint32  SHxADD <:: sourceReg2 + ( sourceReg1 << function3[1,2] );

    // CLZ CTZ CPOP
    uint6   COUNT = uninitialised;

    // PACK PACKH ( ZEXT.H when rs2 == 0 )
    uint32  PACK <:: { sourceReg2[0,16], sourceReg1[0,16] };
    uint32  PACKH <:: { 16b0, sourceReg2[0,8], sourceReg1[0,8] };

    // MIN[U] MAX[U]
    uint32  MINMAX <:: function3[1,1] ^ ( function3[0,1] ? LTU : LT ) ? sourceReg1 : sourceReg2;

    // SEXT.B SEXT.H
    uint32  EXTEND <:: rs2[0,1] ? { {16{sourceReg1[15,1]}}, sourceReg1[0,16] } : { {24{sourceReg1[7,1]}}, sourceReg1[0,8] };

    // ZIP UNZIP
    uint32  ZIP <:: {
                        $$for i=0,14 do
                            sourceReg1[$16+(15-i)$,1],
                            sourceReg1[$(15-i)$,1],
                        $$end
                        sourceReg1[16,1],
                        sourceReg1[0,1]
                    };
    uint32  UNZIP <:: {
                        $$for i=0,15 do
                            sourceReg1[$(15-i)*2+1$,1],
                        $$end
                        $$for i=0,14 do
                            sourceReg1[$(15-i)*2$,1],
                        $$end
                        sourceReg1[0,1]
                    };

    // XPERM[4][8]
    uint32  XPERM4 <:: {    { |sourceReg2[31,1] ? 4b0000 : sourceReg1[ {sourceReg2[28,3], 2b00}, 4 ] },
                            { |sourceReg2[27,1] ? 4b0000 : sourceReg1[ {sourceReg2[24,3], 2b00}, 4 ]  },
                            { |sourceReg2[23,1] ? 4b0000 : sourceReg1[ {sourceReg2[20,3], 2b00}, 4 ] },
                            { |sourceReg2[19,1] ? 4b0000 : sourceReg1[ {sourceReg2[16,3], 2b00}, 4 ] },
                            { |sourceReg2[15,1] ? 4b0000 : sourceReg1[ {sourceReg2[12,3], 2b00}, 4 ]  },
                            { |sourceReg2[11,1] ? 4b0000 : sourceReg1[ {sourceReg2[8,3], 2b00}, 4 ] },
                            { |sourceReg2[7,1] ? 4b0000 : sourceReg1[ {sourceReg2[4,3], 2b00}, 4 ] },
                            { |sourceReg2[3,1] ? 4b0000 : sourceReg1[ {sourceReg2[0,3], 2b00}, 4 ] }
                       };
    uint32  XPERM8 <:: {    { |sourceReg2[26,2] ? 8b00000000 : sourceReg1[ {sourceReg2[24,2], 3b000}, 8 ] },
                            { |sourceReg2[18,2] ? 8b00000000 : sourceReg1[ {sourceReg2[16,2], 3b000}, 8 ] },
                            { |sourceReg2[10,2] ? 8b00000000 : sourceReg1[ {sourceReg2[8,2], 3b000}, 8 ] },
                            { |sourceReg2[2,2] ? 8b00000000 : sourceReg1[ {sourceReg2[0,2], 3b000}, 8 ] }
                       };

    // ORC.B REV8 BREV8
    uint32  ORC <:: { {8{ |sourceReg1[24,8] }}, {8{ |sourceReg1[16,8] }}, {8{ |sourceReg1[8,8] }}, {8{ |sourceReg1[0,8] }} };
    uint32  REV8 <:: rs2[2,1] ? {
                                    $$for i=0,7 do
                                        sourceReg1[$24+i$,1],
                                    $$end
                                    $$for i=0,7 do
                                        sourceReg1[$16+i$,1],
                                    $$end
                                    $$for i=0,7 do
                                        sourceReg1[$8+i$,1],
                                    $$end
                                    $$for i=0,6 do
                                        sourceReg1[$i$,1],
                                    $$end
                                    sourceReg1[7,1]
                                } : { sourceReg1[0,8], sourceReg1[8,8], sourceReg1[16,8], sourceReg1[24,8] };

    // UNSIGNED / SIGNED 33 by 33 bit multiplication giving 66 bit product using DSP blocks
    uint2   dosigned <:: function3[1,1] ? function3[0,1] ? 2b00 : 2b01 : 2b11;
    int33   factor_1 <:: { dosigned[0,1] & sourceReg1[ 31, 1 ], sourceReg1 }; // SIGN EXTEND IF SIGNED MULTIPLY
    int33   factor_2 <:: { dosigned[1,1] & sourceReg2[ 31, 1 ], sourceReg2 }; // SIGN EXTEND IF SIGNED MULTIPLY
    int66   product <:: factor_1 * factor_2;
    uint32  MULT <:: product[ { |function3[0,2], 5b0 }, 32 ];

    always_after {
        {
            if( ~|sourceReg1 ) {
                COUNT = { ~rs2[1,1], 5b00000 };
            } else {
                switch( rs2[0,2] ) {
                    case 2b00: { ( COUNT ) = clz_silice_32( sourceReg1 ); }
                    case 2b01: { ( COUNT ) = ctz_silice_32( sourceReg1 ); }
                    default: { ( COUNT ) = cpop_silice_32( sourceReg1 ); }
                }
            }
        }

        {
            switch( function3 ) {
                case 3b000: { result = AD.domul ? MULT : ADDSUB; }
                case 3b001: { result = AD.domul ? MULT : AD.dosignx ? EXTEND : AD.docount ? COUNT : AD.dobclrext ? CLR : AD.dobinv ? INV : AD.dobset ? SET : AD.dozip ? ZIP : AD.dorotate ? ROTATE : SLL; }
                case 3b010: { result = AD.domul ? MULT : AD.doshxadd ? SHxADD : AD.doxperm ? XPERM4 : LT; }
                case 3b011: { result = AD.domul ? MULT : opCode[3,1] ? ( ~|rs1 ) ? ( |operand2 ) : LTU : ( operand2 == 1 ) ? ( ~|sourceReg1 ) : LTU; }
                case 3b100: { result = AD.dominmax ? MINMAX : AD.doshxadd ? SHxADD : AD.dopack ? PACK : AD.doxperm ? XPERM8 : XOR; }
                case 3b101: { result = AD.doorc ? ORC : AD.dorev ? REV8 : AD.dominmax ? MINMAX : AD.dobclrext ? EXT : AD.dozip ? UNZIP : AD.dorotate ? ROTATE : AD.dosra ? SRA : SRL; }
                case 3b110: { result = AD.dominmax ? MINMAX : AD.doshxadd ? SHxADD : OR; }
                case 3b111: { result = AD.dominmax ? MINMAX : AD.dopack ? PACKH : AND; }
            }
        }
    }
}

// ALU - M EXTENSION
// ALU FOR DIVISION
// UNSIGNED / SIGNED 32 by 32 bit division giving 32 bit remainder and quotient
unit douintdivide(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint32  dividend,
    input   uint32  divisor,
    output  uint32  quotient,
    output  uint32  remainder
) <reginputs> {
    uint6   bit(63);
    uint32  temporary <:: { remainder[0,31], dividend[bit,1] };
    uint1   bitresult <:: __unsigned(temporary) >= __unsigned(divisor);

    busy := start | ( ~&bit );

    always_after {
        if( start ) {
            bit = 31; quotient = 0; remainder = 0;
        } else {
            quotient[bit,1] = bitresult;
            remainder = __unsigned(temporary) - ( bitresult ? __unsigned(divisor) : 0 );
            bit = bit - 1;
        }
    }
}

unit aluMD(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint2   function3,
    input   uint32  sourceReg1,
    input   uint32  sourceReg2,
    input   uint32  abssourceReg1,
    input   uint32  abssourceReg2,
    output  uint32  result
) <reginputs> {
    douintdivide DODIVIDE();
    DODIVIDE.dividend := function3[0,1] ? sourceReg1 : abssourceReg1;
    DODIVIDE.divisor := function3[0,1] ? sourceReg2 : abssourceReg2;
    DODIVIDE.start := start & |sourceReg2; busy := start | DODIVIDE.busy;

    // START DIVIDER AND EXTRACT RESULT
    always_after {
        if( busy ) {
            result = ( |sourceReg2 ) ? function3[1,1] ? DODIVIDE.remainder : ( ( ~function3[0,1] & ( sourceReg1[31,1] ^ sourceReg2[31,1] ) ) ? -DODIVIDE.quotient : DODIVIDE.quotient ) :
            function3[1,1] ? sourceReg1 : 32hffffffff;
        }
    }
}

// ALU FOR CARRYLESS MULTIPLY FROM B-EXTENSION
unit doclmul(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint32  sourceReg1,
    input   uint32  sourceReg2,
    input   uint6   startat,
    input   uint6   stopat,
    input   uint2   mode,
    output  uint32  result
) <reginputs> {
    uint6   count = uninitialised;                  uint32  resultNEXT <:: result ^ ( ( mode[1,1] ) ? ( sourceReg1 >> ( ( mode[0,1] ? 31 : 32 ) - count ) ) : ( sourceReg1 << count ) );

    always_after {
        if( start ) {
            busy = 1; result = 0; count = startat;
        } else {
            if( busy ) {
                if( sourceReg2[ count, 1 ] ) { result = resultNEXT; }
                if( count == stopat ) { busy = 0; } else { count = count + 1; }
            }
        }
    }
}
unit aluCLMUL(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint2   function3,
    input   uint32  sourceReg1,
    input   uint32  sourceReg2,
    output  uint32  result
) <reginputs> {
    doclmul DOCLMUL( sourceReg1 <: sourceReg1, sourceReg2 <: sourceReg2, mode <: function3, result :> result );
    DOCLMUL.start := start; DOCLMUL.startat := &function3; DOCLMUL.stopat := function3[0,1] ? 32 : 31;
    busy := start | DOCLMUL.busy;
}

// ATOMIC A EXTENSION ALU
unit alulogic(
    input   uint32  sourceReg1,
    input   uint32  operand2,
    output  uint32  AND,
    output  uint32  OR,
    output  uint32  XOR
) <reginputs> {
    always_after {
        { AND = sourceReg1 & operand2; }             { OR = sourceReg1 | operand2; }
        { XOR = sourceReg1 ^ operand2; }
    }
}
unit aluA (
    input   uint7   function7,
    input   uint32  memoryinput,
    input   uint32  sourceReg2,
    output  uint32  result
) <reginputs> {
    alulogic LOGIC( sourceReg1 <: memoryinput, operand2 <: sourceReg2 );

    always_after {
        if( function7[4,1] ) {                                                      // AMOMAX[U] AMOMIN[U]
            result = ( function7[2,1] ^ ( function7[3,1] ? ( __unsigned(memoryinput) < __unsigned(sourceReg2) ) :  ( __signed(memoryinput) < __signed(sourceReg2) ) ) ) ?
                     memoryinput : sourceReg2;
        } else {
            switch( function7[0,4] ) {
                default: { result = memoryinput + sourceReg2; }                     // AMOADD
                case 4b0001: { result = sourceReg2; }                               // AMOSWAP
                case 4b0100: { result = LOGIC.XOR; }                                // AMOXOR
                case 4b1000: { result = LOGIC.OR; }                                 // AMOOR
                case 4b1100: { result = LOGIC.AND; }                                // AMOAND
            }
        }
    }
}
