// STRUCTURE OF A COPPER PROGRAM ENTRY
bitfield CU{
    uint3   command,
    uint3   flag,
    uint1   valueflag,
    uint10  value,
    uint4   mode,
    uint7   colour_alt,
    uint7   colour
}

unit background_writer(
    input   uint10  pix_x,
    input   uint9   pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,

    input   uint7   backgroundcolour,
    input   uint7   backgroundcolour_alt,
    input   uint4   backgroundcolour_mode,
    input   uint2   background_update,

    input   uint1   copper_program,
    input   uint7   copper_address,
    input   uint3   copper_command,
    input   uint3   copper_condition,
    input   uint11  copper_coordinate,
    input   uint4   copper_mode,
    input   uint7   copper_alt,
    input   uint7   copper_colour,

    output  uint7   BACKGROUNDcolour,
    output  uint7   BACKGROUNDalt,
    output  uint4   BACKGROUNDmode,

    simple_dualport_bram_port1 copper_commands,
    simple_dualport_bram_port1 copper_conditions,
    simple_dualport_bram_port1 copper_coordinates,
    simple_dualport_bram_port1 copper_modes,
    simple_dualport_bram_port1 copper_alts,
    simple_dualport_bram_port1 copper_colours
) <reginputs> {
    copper_commands.addr1 := copper_address; copper_commands.wdata1 := copper_command; copper_commands.wenable1 := copper_program;
    copper_conditions.addr1 := copper_address; copper_conditions.wdata1 := copper_condition; copper_conditions.wenable1 := copper_program;
    copper_coordinates.addr1 := copper_address; copper_coordinates.wdata1 := copper_coordinate; copper_coordinates.wenable1 := copper_program;
    copper_modes.addr1 := copper_address; copper_modes.wdata1 := copper_mode; copper_modes.wenable1 := copper_program;
    copper_alts.addr1 := copper_address; copper_alts.wdata1 := copper_alt; copper_alts.wenable1 := copper_program;
    copper_colours.addr1 := copper_address; copper_colours.wdata1 := copper_colour; copper_colours.wenable1 := copper_program;

    always_after {
        switch( background_update ) {
            case 2b00: {}                                           // CHANGE A PROGRAM LINE IN THE COPPER MEMORY
            case 2b01: { BACKGROUNDcolour = backgroundcolour; }     // UPDATE THE BACKGROUND FROM RISC-V
            case 2b10: { BACKGROUNDalt = backgroundcolour_alt; }
            case 2b11: { BACKGROUNDmode = backgroundcolour_mode; }
        }
    }
}
unit background_copper(
    input   uint10  pix_x,
    input   uint9   pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,

    input   uint7   backgroundcolour,
    input   uint7   backgroundcolour_alt,
    input   uint4   backgroundcolour_mode,

    input   uint1   copper_status,
    input   uint10  copper_cpu_input,

    output! uint7   BACKGROUNDcolour,
    output! uint7   BACKGROUNDalt,
    output! uint4   BACKGROUNDmode,

    simple_dualport_bram_port0 copper_commands,
    simple_dualport_bram_port0 copper_conditions,
    simple_dualport_bram_port0 copper_coordinates,
    simple_dualport_bram_port0 copper_modes,
    simple_dualport_bram_port0 copper_alts,
    simple_dualport_bram_port0 copper_colours
) <reginputs> {
    uint1   copper_execute = uninitialised;         uint1   copper_branch = uninitialised;
    uint7   PC = 0;                                 uint7   PCplus1 <:: PC + 1;
    uint10  copper_variable = 0;

    // COPPER PROGRAM ENTRY
    uint10  value <:: copper_coordinates.rdata0[10,1]? copper_cpu_input : copper_coordinates.rdata0[0,10];

    // COPPER FLAGS
    copper_commands.addr0 := PC; copper_conditions.addr0 := PC; copper_coordinates.addr0 := PC;
    copper_modes.addr0 := PC; copper_alts.addr0 := PC; copper_colours.addr0 := PC;
    copper_execute := 0; copper_branch := 0;

    always_after {
        // UPDATE THE BACKGROUND GENERATOR FROM THE COPPER
        if( copper_status ) {
            switch( copper_commands.rdata0 ) {
                case 3b000: {
                    // JUMP ON CONDITION
                    switch( copper_conditions.rdata0 ) {
                        default: { copper_branch = 1; }
                        case 3b001: { copper_branch = ( pix_vblank == value[0,1] ); }
                        case 3b010: { copper_branch = ( pix_active == value[0,1] ); }
                        case 3b011: { copper_branch = ( pix_y < value ); }
                        case 3b100: { copper_branch = ( pix_x < value ); }
                        case 3b101: { copper_branch = ( copper_variable < value ); }
                    }
                    PC = copper_branch ? copper_colours.rdata0 : PCplus1;
                }
                default: {
                    switch( copper_commands.rdata0 ) {
                        case 3b001: { copper_execute = pix_vblank; }
                        case 3b010: { copper_execute = ~pix_active; }
                        case 3b011: { copper_execute = ( pix_y == value ); }
                        case 3b100: { copper_execute = ( pix_x == value ); }
                        case 3b101: { copper_execute = ( copper_variable == ( value[0,1] ? pix_x : pix_y ) ); }
                        case 3b110: {
                            copper_variable = copper_conditions.rdata0[0,1] ? value : copper_variable + ( copper_conditions.rdata0[2,1] ? ( -value ) : value );
                            copper_branch = 1;
                        }
                        default: {
                            if( copper_conditions.rdata0[0,1] ) { BACKGROUNDcolour = copper_variable; }
                            if( copper_conditions.rdata0[1,1] ) { BACKGROUNDalt = copper_variable; }
                            if( copper_conditions.rdata0[2,1] ) { BACKGROUNDmode = copper_variable;}
                            copper_branch = 1;
                        }
                    }
                    if( copper_execute ) {
                        if( copper_conditions.rdata0[0,1] ) { BACKGROUNDcolour = copper_colours.rdata0; }
                        if( copper_conditions.rdata0[1,1] ) { BACKGROUNDalt = copper_alts.rdata0; }
                        if( copper_conditions.rdata0[2,1] ) { BACKGROUNDmode = copper_modes.rdata0; }
                        copper_branch = 1;
                    }
                    if( copper_branch ) { PC = PCplus1; }
                }
            }
        } else{
            BACKGROUNDcolour = backgroundcolour; BACKGROUNDalt = backgroundcolour_alt; BACKGROUNDmode = backgroundcolour_mode;
            PC = 0;
        }
    }
}
unit background_display(
    input   uint10  pix_x,
    input   uint9   pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint7   pixel,

    input   uint2  staticGenerator,

    input   uint7   b_colour,
    input   uint7   b_alt,
    input   uint4   b_mode
) <reginputs> {
    uint1   tophalf <:: ( pix_y < 240 );            uint1   lefthalf <:: ( pix_x < 320 );               uint2   checkmode <:: b_mode - 7;
    uint2   condition = uninitialised;

    rainbow RAINBOW( y <: pix_y[6,3] );             starfield STARS( pix_x <: pix_x, pix_y <: pix_y );

    algorithm <autorun> {
        while(1) {
            // DETERMINE BACKGROUND PATTERN
            switch( b_mode ) {
                case 0: { condition = 1; }                                              // SOLID
                case 1: { condition = tophalf; }                                        // 50:50 HORIZONTAL SPLIT
                case 2: { condition = ( lefthalf ); }                                   // 50:50 VERTICAL SPLIT
                case 3: { condition = ( lefthalf ^ tophalf ); }                         // QUARTERS
                case 5: { condition  = STARS.star; }                                    // SNOW (from @sylefeb)
                case 11: { condition = ( pix_x[0,1] | pix_y[0,1] ); }                   // CROSSHATCH
                case 12: { condition = ( pix_x[0,2] == pix_y[0,2] ); }                  // LSLOPE
                case 13: { condition = ( pix_x[0,2] == ~pix_y[0,2] ); }                 // RSLOPE
                case 14: { condition = pix_x[0,1]; }                                    // VSTRIPES
                case 15: { condition = pix_y[0,1]; }                                    // HSTRIPES
                case 4: { condition = 2; } case 6: { condition = 3; }                   // STATIC AND RAINBOW (placeholder, done in main)
                default: { condition = ( pix_x[checkmode,1] ^ pix_y[checkmode,1] ); }   // CHECKERBOARDS (7,8,9,10)
            }
        }
    }

    always_after {
        // SWITCH TO THE APPROPRIATE COLOUR
        switch( condition ) {
            case 0: { pixel = b_alt; }                                              // EVERYTHING ELSE
            case 1: { pixel = b_colour; }
            case 2: { pixel = RAINBOW.colour; }                                     // RAINBOW
            case 3: { pixel = {3{staticGenerator}}; }                               // STATIC
        }
    }
}

unit rainbow(
    input   uint3   y,
    output  uint7   colour
) <reginputs> {
    uint7   rainbow[] = { 7b100000, 7b110000, 7b111000, 7b111100, 7b001100, 7b000011, 7b010010, 7b011011 };

    always_after {
        colour = rainbow[ y ];
    }
}

unit starfield(
    input   uint10  pix_x,
    input   uint9   pix_y,
    output  uint1   star
) <reginputs> {
    // Variables for SNOW (from @sylefeb)
    int10   dotpos <:: ( frame >> rand_x[10,2] ) + rand_x;
    int12   rand_x = 0;
    int12   rand_xNEXT <:: rand_x * 31421 + 6927;
    int32   frame = 0;

    always_after {
        // Increment frame number for the snow/star field
        frame = frame + ( ( pix_x == 639 ) & ( pix_y == 479 ) );
        rand_x = ( ~|pix_x )  ? 1 : rand_xNEXT;
        star = ( pix_y == dotpos );
    }
}
