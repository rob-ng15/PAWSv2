// RISC-ICE-V
// inspired by https://github.com/sylefeb/Silice/blob/master/projects/ice-v/ice-v.ice
//
// A simple Risc-V RV32IMAFC processor

// RISC-V - MAIN CPU LOOP
//          ALU FUNCTIONALITY LISTED IN ALU-

// ON CPU INSTRUCTION CACHE DEFINITIONS
$$ addr_width = 27

// L0 CACHE SIZES FOR HART ID 0 AND 1
// MAX size is 64 due to bram limits
// size and blocks must be a power of 2
$$ L0Isize = 64
$$ L0Icacheaddrwidth = clog2(L0Isize)

// HART 0 - MAIN
$$ L00Iblocks = 8
$$ L00Icount = clog2(L00Iblocks)
$$ L00Ipartaddresswidth = addr_width - 1 - L00Icount - L0Icacheaddrwidth
$$ L00Ipartaddressstart = 1 + L00Icount + L0Icacheaddrwidth
bitfield L00cacheI{ uint30 instruction, uint1 compressed }

// HART 1 - SMT
$$ L01Iblocks = 2
$$ L01Icount = clog2(L01Iblocks)
$$ L01Ipartaddresswidth = addr_width - 1 - L01Icount - L0Icacheaddrwidth
$$ L01Ipartaddressstart = 1 + L01Icount + L0Icacheaddrwidth
bitfield L01cacheI{ uint30 instruction, uint1 compressed }

unit PAWSCPU(
    input   uint1   clock_CPUdecoder,
    input   uint1   clock_cache,
    output  uint2   accesssize,
    output  uint27  address(0),
    output  uint1   cacheselect(0),
    output  uint16  writedata,
    output  uint1   writememory,
    input   uint16  readdata,
    output  uint1   readmemory,
    input   uint1   memorybusy,

    // SMT
    input   uint1   SMTRUNNING,
    input   uint27  SMTSTARTPC,

    // MINI DMA CONTROLLER
    input   uint27  DMASOURCE,
    input   uint27  DMASOURCEADD,
    input   uint27  DMADEST,
    input   uint27  DMADESTADD,
    input   uint27  DMACOUNT,
    input   uint8   DMACYCLES,
    input   uint4   DMAMODE,
    input   uint8   DMASET,
    output! uint2   DMAACTIVE
) <reginputs> {
    // CPU REGISTERS AND THREAD SELECTION
    uint1   COMMIT = uninitialized;                 uint1   SMT = 0;                                    uint1   COMMIT_SMT = uninitialised;
    uint32  instruction = uninitialized;            uint1   compressed = uninitialized;
    uint27  pc = 0;                                 uint27  pc_next <:: SMT ? pc :  AGU.newPC;                                      // HART 0 pc + UPDATE
    uint27  pcSMT = uninitialized;                  uint27  pcSMT_next <:: SMT ? AGU.newPC : SMTRUNNING ? pcSMT : SMTSTARTPC;       // HART 1 pc + update
    uint27  PC <:: SMT ? pcSMT : pc;                                                                                                // SELECT PC FOR THIS CYCLE

    // RISC-V 32 BIT CONTROLLER
    uint32  result <: RV32CONTROL.FASTPATH ? EXECUTEFAST.result : EXECUTESLOW.result;
    uint1   frd <:: RV32CONTROL.FASTPATH ? RV32CONTROL.writeRegisterF : EXECUTESLOW.frd;
    uint1   write <:: COMMIT & RV32CONTROL.writeRegister;
    control RV32CONTROL <@clock_CPUdecoder> (
        cacheselect <: cacheselect,
        DMAACTIVE <: DMAACTIVE[0,1],
        DMA16BIT <: DMA.DMA16BIT,
        SMT <:: SMT,
        COMMIT_SMT <:: COMMIT_SMT,
        frd <: frd,
        write <: write,
        result <: result,
        instruction <: instruction,
        accesssize :> accesssize
    );

    // RISC-V ADDRESS GENERATOR
    addressgenerator AGU <@clock_CPUdecoder> (
        instruction <: instruction,
        immediateValue <: RV32CONTROL.immediateValue,
        PC <: PC,
        sourceReg1 <: RV32CONTROL.sourceReg1,
        AMO <: RV32CONTROL.IS_ATOMIC,
        compressed <: compressed,
        incPC <: RV32CONTROL.incPC,
        takeBranch <: takeBranch
    );

    // MEMORY CONTROL UNITS
    uint4 memorycontrols <: { FETCH.busy, LOAD.busy, STORE.busy, |DMAACTIVE };

    // MINI DMA CONTROLLER
    dma DMA(
        DMASOURCE <: DMASOURCE,
        DMASOURCEADD <: DMASOURCEADD,
        DMADEST <: DMADEST,
        DMADESTADD <: DMADESTADD,
        DMACOUNT <: DMACOUNT,
        DMACYCLES <: DMACYCLES,
        DMAMODE <: DMAMODE,
        DMASET <: DMASET,
        DMAACTIVE :> DMAACTIVE,
        readdata <: readdata,
        memorybusy <: memorybusy
    );

    // FETCH UNIT
    fetch FETCH(
        clock_CPUdecoder <: clock_CPUdecoder,
        PC <: PC,
        readdata <: readdata,
        memorybusy <: memorybusy
    );

    // LOAD UNIT
    load LOAD(
        clock_CPUdecoder <: clock_CPUdecoder,
        loadAddress <: AGU.loadAddress,
        accesssize <: accesssize,
        dounsigned <: RV32CONTROL.function3[2,1],
        readdata <: readdata,
        memorybusy <: memorybusy
    );

    // STORE VALUE SELECTION
    uint1   STORE168FAST <:: ( ~AGU.storeAddress[26,1] & ~AGU.storeAddress[25,1] & ~accesssize[1,1] );
    uint32  storeValue <:: RV32CONTROL.FASTPATH ? EXECUTEFAST.memoryoutput : EXECUTESLOW.memoryoutput;
    store STORE(
        storeAddress <: AGU.storeAddress,
        storeValue <: storeValue,
        accesssize <: accesssize,
        memorybusy <: memorybusy
    );

    // EXECUTE MULTICYCLE INSTRUCTIONS, INTEGER DIVIDE, FPU, CSR AND ALU-A
    cpuexecuteSLOWPATH EXECUTESLOW(
        SMT <: SMT,
        instruction <: instruction,
        opCode <: RV32CONTROL.opCode,
        function3 <: RV32CONTROL.function3,
        function7 <: RV32CONTROL.function7,
        rs1 <: RV32CONTROL.rs1,
        rs2 <: RV32CONTROL.rs2,
        sourceReg1 <: RV32CONTROL.sourceReg1,
        sourceReg2 <: RV32CONTROL.sourceReg2,
        abssourceReg1 <: RV32CONTROL.sourceReg1abs,
        abssourceReg2 <: RV32CONTROL.sourceReg2abs,
        sourceReg1F <: RV32CONTROL.sourceReg1F,
        sourceReg2F <: RV32CONTROL.sourceReg2F,
        sourceReg3F <: RV32CONTROL.sourceReg3F,
        memoryinput <: LOAD.memoryinput,
        incCSRinstret <: COMMIT,
        isALUM <: RV32CONTROL.IS_ALUM,
        isALUCLM <: RV32CONTROL.IS_ALUCLM,
        isCSR <: RV32CONTROL.IS_CSR,
        isATOMIC <: RV32CONTROL.IS_ATOMIC,
        isFPU <: RV32CONTROL.IS_FPU,
        FASTPATHFPU <: RV32CONTROL.FASTPATHFPU
    );

    // EXECUTE SINGLE CYLE INSTRUCTIONS, MOST OF BASE PLUS INTEGER MULTIPLICATION
    uint1   takeBranch <:: RV32CONTROL.FASTPATH & EXECUTEFAST.takeBranch;
    cpuexecuteFASTPATH EXECUTEFAST(
        opCode <: RV32CONTROL.opCode,
        function3 <: RV32CONTROL.function3,
        function7 <: RV32CONTROL.function7,
        rs1 <: RV32CONTROL.rs1,
        rs2 <: RV32CONTROL.rs2,
        sourceReg1 <: RV32CONTROL.sourceReg1,
        sourceReg2 <: RV32CONTROL.sourceReg2,
        negSourceReg2 <: RV32CONTROL.sourceReg2neg,
        sourceReg2F <: RV32CONTROL.sourceReg2F,
        immediateValue <: RV32CONTROL.immediateValue,
        memoryinput <: LOAD.memoryinput,
        AUIPCLUI <: AGU.AUIPCLUI,
        nextPC <: AGU.nextPC,
        isALUMM <: RV32CONTROL.IS_ALUM,
        isLOAD <: RV32CONTROL.IS_LOAD,
        isBRANCH <: RV32CONTROL.IS_BRANCH,
        isAUIPCLUI <: RV32CONTROL.IS_AUIPCLUI,
        isJAL <: RV32CONTROL.IS_JAL
    );

    // SMALL ON CPU L0 CACHE - 1 per HART - RESET when pc == 0 @ START OF BIOS
    // L0 INSTRUCTION CACHE { tag, instruction, compressed, valid } split into units
    $$for i=0,(L00Iblocks-1) do
        simple_dualport_bram uint31 L00cache_$i$ <@clock_cache,@clock> [$L0Isize$] = uninitialized;
        simple_dualport_bram uint$L00Ipartaddresswidth$ L00tags_$i$ <@clock_cache,@clock> [$L0Isize$] = uninitialized;
    $$end
    $$for i=0,(L01Iblocks-1) do
        simple_dualport_bram uint31 L01cache_$i$ <@clock_cache,@clock> [$L0Isize$] = uninitialized;
        simple_dualport_bram uint$L01Ipartaddresswidth$ L01tags_$i$ <@clock_cache,@clock> [$L0Isize$] = uninitialized;
    $$end

    il00cache_read ICACHE_0 <@clock_cache> (
        $$for i=0,(L00Iblocks-1) do
            L0cache_$i$ <:> L00cache_$i$, L0tags_$i$ <:> L00tags_$i$,
        $$end
        CLS <: ICACHE_0W.CLS,
        address <: pc
    );
    il01cache_read ICACHE_1 <@clock_cache> (
        $$for i=0,(L01Iblocks-1) do
            L0cache_$i$ <:> L01cache_$i$, L0tags_$i$ <:> L01tags_$i$,
        $$end
        CLS <: ICACHE_1W.CLS,
        address <: pcSMT
    );
    il00cache_write ICACHE_0W(
        $$for i=0,(L00Iblocks-1) do
            L0cache_$i$ <:> L00cache_$i$, L0tags_$i$ <:> L00tags_$i$,
        $$end
        address <: pc, newinstruction <: instruction[2,30], newcompressed <: compressed
    );
    il01cache_write ICACHE_1W(
        $$for i=0,(L01Iblocks-1) do
            L0cache_$i$ <:> L01cache_$i$, L0tags_$i$ <:> L01tags_$i$,
        $$end
        address <: pcSMT, newinstruction <: instruction[2,30], newcompressed <: compressed
    );
    uint1   L0match <:: ( ~SMT & ICACHE_0.tagmatch ) | ( SMT & ICACHE_1.tagmatch );
    uint1   L0update_0 <:: ~SMT & ~ICACHE_0.tagmatch;
    uint1   L0update_1 <:: SMT & ~ICACHE_1.tagmatch;
    ICACHE_0W.update := 0; ICACHE_1W.update := 0; ICACHE_0.invalidate := ~|pc; ICACHE_1.invalidate := ~|pc; ICACHE_0W.invalidate := ~|pc; ICACHE_1W.invalidate := ~|pc;

    // CONTROLS FOR MEMORY ACCESSES AND UNIT START FLAGS
    FETCH.start := 0; LOAD.start := 0; STORE.start := 0; DMA.start := 0; EXECUTESLOW.start := 0; COMMIT := 0;
    readmemory := DMA.readmemory | LOAD.readmemory | FETCH.readmemory; writememory := DMA.writememory | STORE.writememory;

    algorithm <autorun> {
        while( memorybusy | EXECUTESLOW.busy ) {}                                                                                   // WAIT FDR MEMORY AND CPU TO FINISH
        cacheselect = 0; FETCH.start = 1;                                                                                           // FETCH FIRST INSTRUCTION

        while(1) {
            COMMIT_SMT = SMT;

            if( L0match ) {                                                                                                         // FETCH INSTRUCTION
                instruction =  { SMT ? ICACHE_1.instruction : ICACHE_0.instruction, 2b11 };                                             // FROM CACHE
                compressed = SMT ? ICACHE_1.compressed : ICACHE_0.compressed;
            } else {
                if( FETCH.busy ) { while( FETCH.busy ) {} } else { cacheselect = 0; }                                                   // FROM MEMORY
                instruction = FETCH.instruction; compressed = FETCH.compressed;
            }
            // DECODE, REGISTER FETCH, ADDRESS GENERATION AUTOMATICALLY TAKES PLACE AS SOON AS THE INSTRUCTION IS LOADED
            ICACHE_0W.update = L0update_0; ICACHE_1W.update = L0update_1;                                                               // UPDATE ICACHE

            cacheselect = 1; ++:                                                                                                        // SWITCH TO DATA CACHE

            switch( { RV32CONTROL.IS_LOAD, RV32CONTROL.FASTPATH, RV32CONTROL.IS_STORE } ) {
                case 3b000: { ++: EXECUTESLOW.start = 1; while( EXECUTESLOW.busy ) {} }                                                 // DIVISION, CLMUL, FLOATING POINT, CSR
                case 3b010: { ++: }                                                                                                     // FAST PATH - ALL BASE + MULTIPLICATION + B EXTENSION (except CLMUL)
                case 3b011: { STORE.start = 1; while( STORE.busy ) {} }                                                                 // INTEGER + FLOAT STORE
                default: {                                                                                                              // ATOMIC LOAD - MODIFY - STORE
                    LOAD.start = RV32CONTROL.IS_LOAD; while( LOAD.busy ) {}                                                             // + EMULATION OR LR.W AND SC.W
                    EXECUTESLOW.start = ~RV32CONTROL.FASTPATH; while( EXECUTESLOW.busy ) {}
                    STORE.start = RV32CONTROL.IS_STORE; while( STORE.busy ) {}
                }
                case 3b110: { LOAD.start = 1; while( LOAD.busy ) {} }                                                                   // INTEGER + FLOAT LOAD
            }
            COMMIT = 1; pc = pc_next; pcSMT = pcSMT_next; SMT = ~SMT & SMTRUNNING;                                                      // UPDATE PC AND SWITCH THREADS IF SMT ENABLED

            DMA.start = |DMAMODE;
            if( |DMAMODE ) {                                                                                                            // PROCESS MINI-DMA ENGINE REQUESTS
                while( |DMAACTIVE ) { }
            } else { DMA.start = 0; }

            cacheselect = 0; FETCH.start = ~L0match;                                                                                    // START FETCH OF NEXT INSTRUCTION IF NOT IN ICACHE
        } // RISC-V
    }

    always_after {
        if( |memorycontrols ) {
            onehot( memorycontrols ) {
                case 0: { address = DMA.address; writedata = DMA.writedata; }                                                           // COPY MEMORY REQUESTS FROM DMA ENGINE
                case 1: { address = STORE.address; writedata = STORE.writedata; }                                                       // COPY MEMORY REQUESTS FROM THE STORE UNIT
                case 2: { address = LOAD.address; }                                                                                     // COPY MEMORY REQUESTS FROM DMA ENGINE
                case 3: { address = FETCH.address; }                                                                                    // COPY MEMORY REQUESTS FROM DMA ENGINE
            }
        }
    }
}

// HART ID 0 L0 CACHE
unit il00cache_read(
$$for i=0,(L00Iblocks-1) do
    simple_dualport_bram_port0 L0cache_$i$,
    simple_dualport_bram_port0 L0tags_$i$,
$$end
    input   uint$addr_width$  address,
    input   uint1   invalidate,
    input   uint1   CLS,
    output  uint30  instruction,
    output  uint1   compressed,
    output  uint1   tagmatch
) <reginputs> {
    uint$L00Ipartaddresswidth$ tag = uninitialised;

    always_after {
        $$for i=0,(L00Iblocks-1) do
            L0cache_$i$.addr0 = address[$1+L00Icount$,$L0Icacheaddrwidth$]; L0tags_$i$.addr0 = address[$1+L00Icount$,$L0Icacheaddrwidth$];
        $$end

        switch( address[1,$L00Icount$] ) {
            $$for i=0,(L00Iblocks-1) do
                case $i$: { tag = L0tags_$i$.rdata0; instruction = L00cacheI ( L0cache_$i$.rdata0 ).instruction; compressed =  L00cacheI( L0cache_$i$.rdata0 ).compressed; }
            $$end
        }
        tagmatch = ~( invalidate | CLS ) & |instruction & ( tag == address[$L00Ipartaddressstart$,$L00Ipartaddresswidth$] );
    }
}

unit il00cache_write(
$$for i=0,(L00Iblocks-1) do
    simple_dualport_bram_port1 L0cache_$i$,
    simple_dualport_bram_port1 L0tags_$i$,
$$end
    input   uint$addr_width$  address,
    input   uint30  newinstruction,
    input   uint1   newcompressed,
    input   uint1   update,
    input   uint1   invalidate,
    output  uint1   CLS
) <reginputs> {
    uint$L0Icacheaddrwidth+1$ count = $L0Isize$; uint$L0Icacheaddrwidth+1$ countP1 <:: count + 1;

    $$for i=0,(L00Iblocks-1) do
        L0cache_$i$.wenable1 := 1; L0tags_$i$.wenable1 := 1;
    $$end

    always_after {
        switch( { CLS, invalidate } ) {
            case 2b00: {
                if( update ) {
                    switch( address[1,$L00Icount$] ) {
                        $$for i=0,(L00Iblocks-1) do
                            case $i$: {
                                L0cache_$i$.addr1 = address[$1+L00Icount$,$L0Icacheaddrwidth$]; L0cache_$i$.wdata1 = { newinstruction, newcompressed };
                                L0tags_$i$.addr1 = address[$1+L00Icount$,$L0Icacheaddrwidth$]; L0tags_$i$.wdata1 = address[$L00Ipartaddressstart$,$L00Ipartaddresswidth$];
                            }
                        $$end
                    }
                }
            }
            case 2b10: {
                $$for i=0,(L00Iblocks-1) do
                    L0cache_$i$.addr1 = count; L0cache_$i$.wdata1 = 0;
                $$end
                count = countP1;
            }
            default: { count = 0; }
        }
        CLS = ( count != $L0Isize$ );
    }
}

// HART ID 1 L0 CACHE
unit il01cache_read(
$$for i=0,(L01Iblocks-1) do
    simple_dualport_bram_port0 L0cache_$i$,
    simple_dualport_bram_port0 L0tags_$i$,
$$end
    input   uint$addr_width$  address,
    input   uint1   invalidate,
    input   uint1   CLS,
    output  uint30  instruction,
    output  uint1   compressed,
    output  uint1   tagmatch
) <reginputs> {
    uint$L01Ipartaddresswidth$ tag = uninitialised;

    always_after {
        $$for i=0,(L01Iblocks-1) do
            L0cache_$i$.addr0 = address[$1+L01Icount$,$L0Icacheaddrwidth$]; L0tags_$i$.addr0 = address[$1+L01Icount$,$L0Icacheaddrwidth$];
        $$end

        switch( address[1,$L01Icount$] ) {
            $$for i=0,(L01Iblocks-1) do
                case $i$: { tag = L0tags_$i$.rdata0; instruction = L01cacheI ( L0cache_$i$.rdata0 ).instruction; compressed =  L01cacheI( L0cache_$i$.rdata0 ).compressed; }
            $$end
        }
        tagmatch = ~( invalidate | CLS ) & |instruction & ( tag == address[$L01Ipartaddressstart$,$L01Ipartaddresswidth$] );
    }
}

unit il01cache_write(
$$for i=0,(L01Iblocks-1) do
    simple_dualport_bram_port1 L0cache_$i$,
    simple_dualport_bram_port1 L0tags_$i$,
$$end
    input   uint$addr_width$  address,
    input   uint30  newinstruction,
    input   uint1   newcompressed,
    input   uint1   update,
    input   uint1   invalidate,
    output  uint1   CLS
) <reginputs> {
    uint$L0Icacheaddrwidth+1$ count = $L0Isize$; uint$L0Icacheaddrwidth+1$ countP1 <:: count + 1;

    $$for i=0,(L01Iblocks-1) do
        L0cache_$i$.wenable1 := 1; L0tags_$i$.wenable1 := 1;
    $$end

    always_after {
        switch( { CLS, invalidate } ) {
            case 2b00: {
                if( update ) {
                    switch( address[1,$L01Icount$] ) {
                        $$for i=0,(L01Iblocks-1) do
                            case $i$: {
                                L0cache_$i$.addr1 = address[$1+L01Icount$,$L0Icacheaddrwidth$]; L0tags_$i$.addr1 = address[$1+L01Icount$,$L0Icacheaddrwidth$];
                                L0cache_$i$.wdata1 = { newinstruction, newcompressed }; L0tags_$i$.wdata1 = address[$L01Ipartaddressstart$,$L01Ipartaddresswidth$];
                            }
                        $$end
                    }
                }
            }
            case 2b10: {
                $$for i=0,(L01Iblocks-1) do
                    L0cache_$i$.addr1 = count; L0cache_$i$.wdata1 = 0;
                $$end
                count = countP1;
            }
            default: { count = 0; }
        }
        CLS = ( count != $L0Isize$ );
    }
}

unit cpuexecuteSLOWPATH(
    input   uint1   start,
    output  uint1   busy(0),
    input   uint1   SMT,
    input   uint32  instruction,
    input   uint5   opCode,
    input   uint3   function3,
    input   uint7   function7,
    input   uint5   rs1,
    input   uint5   rs2,
    input   int32   sourceReg1,
    input   int32   sourceReg2,
    input   int32   abssourceReg1,
    input   int32   abssourceReg2,
    input   uint32  sourceReg1F,
    input   uint32  sourceReg2F,
    input   uint32  sourceReg3F,
    input   int32   memoryinput,
    output  uint1   frd,
    output  int32   memoryoutput,
    output  int32   result,
    input   uint1   incCSRinstret,
    input   uint1   isCSR,
    input   uint1   isATOMIC,
    input   uint1   isFPU,
    input   uint1   isALUM,
    input   uint1   isALUCLM,
    input   uint1   FASTPATHFPU
) <reginputs> {
    // M EXTENSION - DIVISION
    aluMD ALUMD( function3 <: function3[0,2], sourceReg1 <: sourceReg1, sourceReg2 <: sourceReg2, abssourceReg1 <: abssourceReg1, abssourceReg2 <: abssourceReg2 );

    // ATOMIC MEMORY OPERATIONS
    aluA ALUA( function7 <: function7, memoryinput <: memoryinput, sourceReg2 <: sourceReg2 );

    // B EXTENSION - CLMUL
    aluCLMUL ALUBCLMUL( function3 <: function3[0,2], sourceReg1 <: sourceReg1, sourceReg2 <: sourceReg2 );

    // FLOATING POINT REGISTERS CLASSIFICATION
    classifyF class1F( a <: sourceReg1F ); classifyF class2F( a <: sourceReg2F ); classifyF class3F( a <: sourceReg3F );

    // FLOATING POINT SLOW OPERATIONS - CALCULATIONS AND CONVERSIONS
    floatconvert FPUCONVERT(
        FPUflags <: CSR.FPUflags,
        function7 <: function7[2,5], rs2 <: rs2[0,1],
        sourceReg1 <: sourceReg1, abssourceReg1 <: abssourceReg1, sourceReg1F <: sourceReg1F,
        classA <: class1F.class
    );

    floatcalc FPUCALC(
        FPUflags <: CSR.FPUflags,
        opCode <: opCode, function7 <: function7[2,5],
        sourceReg1F <: sourceReg1F, sourceReg2F <: sourceReg2F, sourceReg3F <: sourceReg3F,
        classA <: class1F.class, classB <: class2F.class, classC <: class3F.class
    );

    // FLOATING POINT FAST OPERATIONS
    fpufast FPUFAST(
        FPUflags <: CSR.FPUflags,
        function3 <: function3[0,2], function7 <: function7[2,5],
        sourceReg1 <: sourceReg1, sourceReg1F <: sourceReg1F, sourceReg2F <: sourceReg2F,
        classA <: class1F.class, classB <: class2F.class
    );

    // MANDATORY RISC-V CSR REGISTERS + HARTID == 0 MAIN THREAD == 1 SMT THREAD
    uint5   FPUnewflags <:: FASTPATHFPU ? FPUFAST.FPUnewflags : fpuconvert ? FPUCONVERT.FPUnewflags : FPUCALC.FPUnewflags;
    CSRblock CSR(
        SMT <: SMT,
        instruction <: instruction,
        function3 <: function3,
        rs1 <: rs1,
        sourceReg1 <: sourceReg1,
        FPUnewflags <: FPUnewflags,
        incCSRinstret <: incCSRinstret
    );

    // Classify the instruction
    uint1   fpuconvert <:: ( opCode == 5b10100 ) & ( function7[4,3] == 3b110 );
    uint1   fpufast <:: ( isFPU & FASTPATHFPU ) | fpuconvert;
    uint1   fpucalc <:: isFPU & ~fpufast;
    uint4   operation <:: { ~|{fpufast,isATOMIC,isCSR}, fpufast, isATOMIC, isCSR };

    // START AND BUSY FLAGS
    uint1   unitbusy <:: ( FPUCALC.busy | ALUMD.busy | ALUBCLMUL.busy );
    ALUMD.start := start & isALUM;                                                                          // INTEGER DIVISION
    ALUBCLMUL.start := start & isALUCLM;                                                                    // CARRYLESS MULTIPLY
    FPUCALC.start := start & fpucalc;                                                                       // FPU CALCULATIONS
    CSR.start := start & isCSR & |function3;                                                                // CSR

    // Deal with updating fpuflags and writing to fpu registers
    CSR.updateFPUflags := 0; frd := fpuconvert ? FPUCONVERT.frd : fpufast ? FPUFAST.frd : fpucalc ? 1 : 0;

    algorithm <autorun> {
        // PROVIDE WAIT STATE FOR APPROPRIATE OPERATION
        while(1) {
            if( start ) {
                busy = 1;
                onehot( operation ) {
                    case 0: { ++: }                                                                                     // CSR
                    case 1: {}                                                                                          // ATOMIC OPERATIONS
                    case 2: { ++: }                                                                                     // FPU FAST COMPARE, MIN/MAX, CLASS, MOVE, CONVERT
                    case 3: { while( unitbusy ) {} }                                                                    // FPU CALCULATIONS AND INTEGER DIVISION
                }
                busy = 0;
                CSR.updateFPUflags = fpuconvert | fpucalc;
            }
        }
    }

    // COLLECT THE APPROPRIATE RESULT
    always_after {
        if( busy ) {
            onehot( operation ) {
                case 0: { result = |function3 ? CSR.result : 0; }                                                   // CSR
                case 1: {
                    if( function7[3,1] ) {
                        result = memoryinput; memoryoutput = ALUA.result;                                           // ATOMIC LOAD - MODIFY - STORE
                    } else {
                        result = function7[2,1] ? 0 : memoryinput;                                                  // LR.W SC.W
                        memoryoutput = sourceReg2;
                    }
                }
                case 2: { result = fpuconvert ? FPUCONVERT.result : FPUFAST.result; }                               // FPU FAST COMPARE, MIN/MAX, CLASS, MOVE, CONVERT
                case 3: { result = fpucalc ? FPUCALC.result : function3[2,1] ? ALUMD.result : ALUBCLMUL.result; }   // FPU CALCULATIONS AND INTEGER DIVISION
            }
        }
    }
}

unit cpuexecuteFASTPATH(
    input   uint5   opCode,
    input   uint3   function3,
    input   uint7   function7,
    input   uint5   rs1,
    input   uint5   rs2,
    input   int32   sourceReg1,
    input   int32   sourceReg2,
    input   int32   negSourceReg2,
    input   uint32  sourceReg2F,
    input   int32   immediateValue,
    input   int32   memoryinput,
    input   uint32  AUIPCLUI,
    input   uint32  nextPC,
    input   uint1   isALUMM,
    input   uint1   isLOAD,
    input   uint1   isBRANCH,
    input   uint1   isAUIPCLUI,
    input   uint1   isJAL,
    output  uint1   takeBranch,
    output  int32   memoryoutput,
    output  int32   result
) <reginputs> {
    // COMPARISON UNIT
    compare COMPARE( sourceReg1 <: sourceReg1, sourceReg2 <: sourceReg2, immediateValue <: immediateValue, regimm <: opCode[3,1] );

    // BRANCH COMPARISON UNIT
    branchcomparison BRANCHUNIT( function3 <: function3, sourceReg1 <: sourceReg1, sourceReg2 <: sourceReg2, LT <: COMPARE.LT, LTU <: COMPARE.LTU, EQ <: COMPARE.EQ );

    // ALU
    alu ALU(
        opCode <: opCode, function3 <: function3, function7 <: function7,
        rs1 <: rs1, rs2 <: rs2,
        sourceReg1 <: sourceReg1, sourceReg2 <: sourceReg2, negSourceReg2 <: negSourceReg2,
        immediateValue <: immediateValue,
        LT <: COMPARE.LT, LTU <: COMPARE.LTU
    );

    // M EXTENSION - MULTIPLICATION
    aluMM ALUMM( function3 <: function3[0,2], sourceReg1 <: sourceReg1, sourceReg2 <: sourceReg2 );

    always_after {
        takeBranch = isBRANCH & BRANCHUNIT.takeBranch;                  // BRANCH
        memoryoutput = opCode[0,1] ? sourceReg2F : sourceReg2;          // FLOAT STORE OR STORE
        result = isAUIPCLUI ? AUIPCLUI :                                // LUI AUIPC
                            isJAL ? nextPC :                            // JAL[R]
                            isLOAD ? memoryinput :                      // [FLOAT]LOAD
                            isALUMM ? ALUMM.result : ALU.result;        // INTEGER ALU AND MULTIPLICATION
    }
}

// FETCH UNIT, INCLUDING COMPRESSED INSTRUCTION EXPANSION
unit fetch(
    input   uint1   clock_CPUdecoder,
    input   uint1   start,
    output!  uint1   busy(0),
    input!  uint27  PC,
    output  uint32  instruction,
    output  uint1   compressed,

    output! uint27  address,
    input!  uint16  readdata,
    output! uint1   readmemory,
    input!  uint1   memorybusy
) <reginputs> {
    uint27  PC2 <:: PC + 2;

    // COMPRESSED INSTRUCTION EXPANDER
    compressed00 COMPRESSED00 <@clock_CPUdecoder> ( i16 <: readdata ); compressed01 COMPRESSED01 <@clock_CPUdecoder> ( i16 <: readdata ); compressed10 COMPRESSED10 <@clock_CPUdecoder> ( i16 <: readdata );

    readmemory := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1;
                address = PC; readmemory = 1; while( memorybusy ) {}                                                                            // FETCH POTENTIAL COMPRESSED OR 1ST 16 BITS
                compressed = ( ~&readdata[0,2] );
                if( compressed ) {
                    switch( readdata[0,2] ) {                                                                                                   // EXPAND COMPRESSED INSTRUCTION
                        case 2b00: { instruction = { COMPRESSED00.i32, 2b11 }; }
                        case 2b01: { instruction = { COMPRESSED01.i32, 2b11 }; }
                        case 2b10: { instruction = { COMPRESSED10.i32, 2b11 }; }
                        default: {}
                    }
                    busy = 0;
                } else {
                    instruction[0,16] = readdata; address = PC2; readmemory = 1; while( memorybusy ) {} instruction[16,16] = readdata;         // 32 BIT INSTRUCTION FETCH 2ND 16 BITS
                    busy = 0;
                }
            } else { busy = 0; }
        }
    }
}

// LOAD UNIT - INCLUDING SIGN EXTENSION FOR 8/16 BIT SIGNED LOADS
unit load(
    input   uint1   clock_CPUdecoder,
    input   uint1   start,
    output! uint1   busy(0),
    input   uint27  loadAddress,
    input   uint2   accesssize,
    input   uint1   dounsigned,
    output  int32   memoryinput,

    output! uint27  address,
    input!  uint16  readdata,
    output! uint1   readmemory,
    input!  uint1   memorybusy
) <reginputs> {
    uint27  LA2 <:: loadAddress + 2;

    // SIGN EXTENDER FOR 8 AND 16 BIT LOADS
    signextend SIGNEXTEND <@clock_CPUdecoder> (
        readdata <: readdata,
        is16or8 <: accesssize[0,1],
        byteaccess <: loadAddress[0,1],
        dounsigned <: dounsigned
    );

    readmemory := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1;
                address = loadAddress; readmemory = 1;                                                          // START READ OF 1ST 8 or 16 BITS
                switch( accesssize[1,1] ) {
                    case 0: {
                        while( memorybusy ) {} memoryinput = SIGNEXTEND.memory168; busy = 0;                    // RETURN 8 OR 16 BIT READ WITH OPTIONAL SIGN EXTENSION
                    }
                    case 1: {
                        while( memorybusy ) {} memoryinput[0,16] = readdata; address = LA2; readmemory = 1;     // START READ OF 2ND 16 BITS
                        while( memorybusy ) {} memoryinput[16,16] = readdata; busy = 0;                         // RETURN 32 BIT READ
                    }
                }
            }
        }
    }
}

// STORE UNIT FOR NON-FAST STORES ( to BRAM/SDRAM or 32 bit )
unit store(
    input   uint1   start,
    output! uint1   busy(0),
    input   uint27  storeAddress,
    input   int32   storeValue,
    input   uint2   accesssize,

    output! uint27  address,
    output! uint16  writedata,
    output! uint1   writememory,
    input!  uint1   memorybusy
) <reginputs> {
    uint1   FASTSTORE <:: ~storeAddress[26,1] & ~storeAddress[25,1];
    uint27  SA2 <:: storeAddress + 2;
    writememory := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) {
                busy = 1; address = storeAddress; writedata = storeValue[0,16]; writememory = 1;                                            // STORE 8, 16 BITS OR 1ST 16 BITS OF 32
                switch( accesssize[1,1] ) {
                    case 0: { if( FASTSTORE ) { ++: } else { while( memorybusy ) {} } busy = 0; }
                    case 1: {
                        if( FASTSTORE ) { ++: } else { while( memorybusy ) {} }
                        address = SA2; writedata = storeValue[16,16]; writememory = 1;                                                      // STORE 2ND 16 BITS OF 32
                        if( FASTSTORE ) { ++: } else { while( memorybusy ) {} } busy = 0;
                    }
                }
            }
        }
    }
}

// MINI DMA CONTROLLER
unit dma(
    input   uint27  DMASOURCE,
    input   uint27  DMASOURCEADD,
    input   uint27  DMADEST,
    input   uint27  DMADESTADD,
    input   uint27  DMACOUNT,
    input   uint8   DMACYCLES,
    input   uint4   DMAMODE,
    input   uint8   DMASET,
    output  uint1   DMA16BIT(0),
    output! uint2   DMAACTIVE(0),

    input   uint1   start,
    output! uint27  address,
    output! uint16  writedata,
    output! uint1   writememory,
    output! uint1   readmemory,
    input!  uint16  readdata,
    input!  uint1   memorybusy
) <reginputs> {
    uint1   srcBRAM <:: ~DMASOURCE[26,1] & ~DMASOURCE[25,1] & ~DMASOURCE[15,1];                         // SOURCE IS BRAM
    uint1   destBRAM <:: ~DMADEST[26,1] & ~DMADEST[25,1] & ~DMADEST[15,1];                              // DEST IS BRAM

    uint1   srcSET <:: ( DMASOURCE == 27hfe0e );                                                        // SOURCE IS THE SET VALUE REGISTER, NO LOADING REQUIRED
    uint1   src16bit <:: ( srcSET | DMASOURCE[26,1] | DMASOURCE[25,1] | srcBRAM ) & ~DMASOURCE[0,1];    // SOURCE IS 16 BIT CAPABLE
    uint1   destIO <:: ~DMADEST[26,1] & ~DMADEST[25,1] & DMADEST[15,1];                                 // DESTINATION IS I/O REGISTER
    uint1   dest16bit <:: ( DMADEST[26,1] | DMADEST[25,1] | destBRAM ) & ~DMADEST[0,1];                 // DESTINATION IS 16 BIT CAPABLE

    uint4   dmamode = uninitialized;                uint27  dmacount = uninitialised;                   uint27  dmacountNEXT <:: dmacount - ( DMA16BIT ? 2 : 1 );
    uint8   dmacycles = uninitialised;              uint8   dmacyclesNEXT <:: dmacycles - 1;
    uint27  dmasrc = uninitialised;                 uint27  dmasrc2 <:: dmasrc + 2;                     uint27  dmasrcNEXT <:: DMA16BIT ? dmasrc2 : dmasrc + 1;
    uint27  dmasrcADD <:: dmasrc + DMASOURCEADD;    uint27  dmasrcNEXTLINE <:: dmasrcADD - DMACOUNT;
    uint27  dmadest = uninitialised;                uint27  dmadest2 <:: dmadest + 2;                   uint27  dmadestNEXT <:: DMA16BIT ? dmadest2 : dmadest + 1;
    uint27  dmadestADD <:: dmadest + DMADESTADD;    uint27  dnadestNEXTLINE <:: dmadestADD - DMACOUNT;
    uint1   dmablue <:: ( dmadest[0,4] == 4h6 );
    uint16  memoryinput = uninitialised;
    uint1   FASTSTORE <:: ~dmadest[26,1] & ~dmadest[25,1];

    writememory := 0; readmemory := 0;

    algorithm <autorun> {
        while(1) {
            if( start ) {
                dmamode = DMAMODE; dmasrc = DMASOURCE; dmadest = DMADEST; dmacount = DMACOUNT; dmacycles = DMACYCLES;
                switch( dmamode ) {
                    default: { DMA16BIT = 0; }                                                                                       // DEFAULT TO 8 BIT MODE
                    case 3: { DMA16BIT = src16bit & dest16bit & ~DMACOUNT[0,1]; }                                                    // MEMCPY IS 16 BIT CAPABLE
                    case 4: { DMA16BIT = srcSET & dest16bit & ~DMACOUNT[0,1]; }                                                      // MEMSET IS 16 BIT CAPABLE
                    case 8: { DMA16BIT = src16bit & dest16bit & ~DMASOURCEADD[0,1] & ~DMADESTADD[0,1] & ~DMACOUNT[0,1]; }            // MEMCPY RECTANGLE IS 16 BIT CAPABLE
                    case 9: { DMA16BIT = srcSET & dest16bit & ~DMASOURCEADD[0,1] & ~DMADESTADD[0,1] & ~DMACOUNT[0,1]; }              // MEMSET RECTANGLE IS 16 BIT CAPABLE
                }
                DMAACTIVE = &dmamode[0,3] ? 2 : 1;
                switch( dmamode[3,1] ) {
                    case 0: {
                        while( |dmacount ) {                                                                                        // SINGLE CYCLE MODE
                            address = dmasrc; readmemory = ~srcSET; writedata = { DMASET, DMASET };
                            switch( { srcSET, DMAACTIVE[1,1] } ) {
                                case 2b00: {
                                    while( memorybusy ) {} memoryinput = readdata;
                                    address = dmadest; writedata = DMA16BIT ? memoryinput :  memoryinput[ { dmasrc[0,1], 3b000 }, 8 ];
                                    if( FASTSTORE ) { writememory = 1; } else { writememory = 1; while( memorybusy ) {} }
                                }
                                case 2b01: {
                                    while( memorybusy ) {} memoryinput = readdata;
                                    address = dmadest; writedata = memoryinput[0,8]; writememory = 1;
                                    ++: ++:
                                    writedata = memoryinput[8,8]; writememory = 1;
                                }
                                case 2b10: {
                                    address = dmadest;
                                    if( FASTSTORE ) { writememory = 1; } else { writememory = 1; while( memorybusy ) {} }
                                }
                                case 2b11: {
                                    address = dmadest; writememory = 1;
                                    ++: ++:
                                    writememory = 1;
                                }
                            }
                            switch( dmamode[0,3] ) {
                                default: {}                                                                                         // INACTIVE / UNDEFINED
                                case 1: { dmasrc = dmasrcNEXT; }                                                                    // DMA multi-src to single-dest PIXEL BLOCK 8 bit + SDCARD WRITE
                                case 2: { dmasrc = dmasrcNEXT; if( dmablue ) { dmadest = 27hd672; } else { dmadest = dmadest2; } }  // DMA SPECIAL PIXEL BLOCK RGB
                                case 3: { dmasrc = dmasrcNEXT; dmadest = dmadestNEXT; }                                             // DMA multi-src to multi-dest MEMCPY
                                case 4: { dmadest = dmadestNEXT; }                                                                  // DMA single-src to multi-dest MEMSET + SDCARD READ
                                case 5: {}                                                                                          // DMA single-src to single-dest SET TILE/CBLITTER to single value
                                case 6: { dmasrc = dmasrcADD; dmadest = dmadestADD; }                                               // DMA increase src and dest by additions
                                case 7: { dmasrc = dmasrc2; }                                                                       // DMA 16bit to 2 pixels for PIXEL BLOCK special mode
                            }
                            dmacount = dmacountNEXT;
                        }
                    }
                    case 1: {
                        while( |dmacycles ) {
                            while( |dmacount ) {                                                                                    // MULTI-CYCLE MODE
                                address = dmasrc; readmemory = ~srcSET; writedata = { DMASET, DMASET };
                                switch( { srcSET, FASTSTORE } ) {
                                    case 2b00: {
                                        while( memorybusy ) {} memoryinput = readdata;
                                        address = dmadest; writedata = DMA16BIT ? memoryinput :  memoryinput[ { dmasrc[0,1], 3b000 }, 8 ];
                                        writememory = 1; while( memorybusy ) {}
                                    }
                                    case 2b01: {
                                        while( memorybusy ) {} memoryinput = readdata;
                                        address = dmadest; writedata = DMA16BIT ? memoryinput :  memoryinput[ { dmasrc[0,1], 3b000 }, 8 ];
                                        writememory = 1;
                                    }
                                    case 2b10: {
                                        address = dmadest;  writememory = 1; while( memorybusy ) {}
                                    }
                                    case 2b11: {
                                        address = dmadest; writememory = 1;
                                    }
                                }
                                switch( dmamode[0,1] ) {
                                    case 0: { dmasrc = dmasrcNEXT; dmadest = dmadestNEXT; }                                         // MEMCPY_RECTANGLE
                                    case 1: { dmadest = dmadestNEXT; }                                                              // MEMSET RECTANGLE
                                }
                                dmacount = dmacountNEXT;
                            }
                            switch( dmamode[0,1] ) {
                                case 0: { dmasrc = dmasrcNEXTLINE; }
                                case 1: {}
                            }
                            dmadest = dnadestNEXTLINE; dmacount = DMACOUNT; dmacycles = dmacyclesNEXT;
                        }
                    }
                }
                DMAACTIVE = 0;
            } else { DMAACTIVE = 0; }
        }
    }
}
